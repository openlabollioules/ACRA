#!/usr/bin/env node
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (hasOwn(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      if (oc && typeof oc.getOwnPropertyDescriptors === "function") {
        object = oc.create(null, oc.getOwnPropertyDescriptors(object));
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function hasOwn(object, key) {
      return Object.prototype.hasOwnProperty.call(object, key);
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (hasOwn(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var HTML_BOOLEAN_ATTRIBUTES = freeze({
      allowfullscreen: true,
      async: true,
      autofocus: true,
      autoplay: true,
      checked: true,
      controls: true,
      default: true,
      defer: true,
      disabled: true,
      formnovalidate: true,
      hidden: true,
      ismap: true,
      itemscope: true,
      loop: true,
      multiple: true,
      muted: true,
      nomodule: true,
      novalidate: true,
      open: true,
      playsinline: true,
      readonly: true,
      required: true,
      reversed: true,
      selected: true
    });
    function isHTMLBooleanAttribute(name) {
      return hasOwn(HTML_BOOLEAN_ATTRIBUTES, name.toLowerCase());
    }
    var HTML_VOID_ELEMENTS = freeze({
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    });
    function isHTMLVoidElement(tagName) {
      return hasOwn(HTML_VOID_ELEMENTS, tagName.toLowerCase());
    }
    var HTML_RAW_TEXT_ELEMENTS = freeze({
      script: false,
      style: false,
      textarea: true,
      title: true
    });
    function isHTMLRawTextElement(tagName) {
      var key = tagName.toLowerCase();
      return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && !HTML_RAW_TEXT_ELEMENTS[key];
    }
    function isHTMLEscapableRawTextElement(tagName) {
      var key = tagName.toLowerCase();
      return hasOwn(HTML_RAW_TEXT_ELEMENTS, key) && HTML_RAW_TEXT_ELEMENTS[key];
    }
    function isHTMLMimeType(mimeType) {
      return mimeType === MIME_TYPE.HTML;
    }
    function hasDefaultHTMLNamespace(mimeType) {
      return isHTMLMimeType(mimeType) || mimeType === MIME_TYPE.XML_XHTML_APPLICATION;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring
       *      WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType
       *      registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/xml`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType
       *      registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var _MIME_TYPES = Object.keys(MIME_TYPE).map(function(key) {
      return MIME_TYPE[key];
    });
    function isValidMimeType(mimeType) {
      return _MIME_TYPES.indexOf(mimeType) > -1;
    }
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace.
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find;
    exports2.freeze = freeze;
    exports2.HTML_BOOLEAN_ATTRIBUTES = HTML_BOOLEAN_ATTRIBUTES;
    exports2.HTML_RAW_TEXT_ELEMENTS = HTML_RAW_TEXT_ELEMENTS;
    exports2.HTML_VOID_ELEMENTS = HTML_VOID_ELEMENTS;
    exports2.hasDefaultHTMLNamespace = hasDefaultHTMLNamespace;
    exports2.hasOwn = hasOwn;
    exports2.isHTMLBooleanAttribute = isHTMLBooleanAttribute;
    exports2.isHTMLRawTextElement = isHTMLRawTextElement;
    exports2.isHTMLEscapableRawTextElement = isHTMLEscapableRawTextElement;
    exports2.isHTMLMimeType = isHTMLMimeType;
    exports2.isHTMLVoidElement = isHTMLVoidElement;
    exports2.isValidMimeType = isValidMimeType;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@xmldom/xmldom/lib/errors.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    function extendError(constructor, writableName) {
      constructor.prototype = Object.create(Error.prototype, {
        constructor: { value: constructor },
        name: { value: constructor.name, enumerable: true, writable: writableName }
      });
    }
    var DOMExceptionName = conventions.freeze({
      /**
       * the default value as defined by the spec
       */
      Error: "Error",
      /**
       * @deprecated
       * Use RangeError instead.
       */
      IndexSizeError: "IndexSizeError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      DomstringSizeError: "DomstringSizeError",
      HierarchyRequestError: "HierarchyRequestError",
      WrongDocumentError: "WrongDocumentError",
      InvalidCharacterError: "InvalidCharacterError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      NoDataAllowedError: "NoDataAllowedError",
      NoModificationAllowedError: "NoModificationAllowedError",
      NotFoundError: "NotFoundError",
      NotSupportedError: "NotSupportedError",
      InUseAttributeError: "InUseAttributeError",
      InvalidStateError: "InvalidStateError",
      SyntaxError: "SyntaxError",
      InvalidModificationError: "InvalidModificationError",
      NamespaceError: "NamespaceError",
      /**
       * @deprecated
       * Use TypeError for invalid arguments,
       * "NotSupportedError" DOMException for unsupported operations,
       * and "NotAllowedError" DOMException for denied requests instead.
       */
      InvalidAccessError: "InvalidAccessError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      ValidationError: "ValidationError",
      /**
       * @deprecated
       * Use TypeError instead.
       */
      TypeMismatchError: "TypeMismatchError",
      SecurityError: "SecurityError",
      NetworkError: "NetworkError",
      AbortError: "AbortError",
      /**
       * @deprecated
       * Just to match the related static code, not part of the spec.
       */
      URLMismatchError: "URLMismatchError",
      QuotaExceededError: "QuotaExceededError",
      TimeoutError: "TimeoutError",
      InvalidNodeTypeError: "InvalidNodeTypeError",
      DataCloneError: "DataCloneError",
      EncodingError: "EncodingError",
      NotReadableError: "NotReadableError",
      UnknownError: "UnknownError",
      ConstraintError: "ConstraintError",
      DataError: "DataError",
      TransactionInactiveError: "TransactionInactiveError",
      ReadOnlyError: "ReadOnlyError",
      VersionError: "VersionError",
      OperationError: "OperationError",
      NotAllowedError: "NotAllowedError",
      OptOutError: "OptOutError"
    });
    var DOMExceptionNames = Object.keys(DOMExceptionName);
    function isValidDomExceptionCode(value) {
      return typeof value === "number" && value >= 1 && value <= 25;
    }
    function endsWithError(value) {
      return typeof value === "string" && value.substring(value.length - DOMExceptionName.Error.length) === DOMExceptionName.Error;
    }
    function DOMException(messageOrCode, nameOrMessage) {
      if (isValidDomExceptionCode(messageOrCode)) {
        this.name = DOMExceptionNames[messageOrCode];
        this.message = nameOrMessage || "";
      } else {
        this.message = messageOrCode;
        this.name = endsWithError(nameOrMessage) ? nameOrMessage : DOMExceptionName.Error;
      }
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }
    extendError(DOMException, true);
    Object.defineProperties(DOMException.prototype, {
      code: {
        enumerable: true,
        get: function() {
          var code = DOMExceptionNames.indexOf(this.name);
          if (isValidDomExceptionCode(code)) return code;
          return 0;
        }
      }
    });
    var ExceptionCode = {
      INDEX_SIZE_ERR: 1,
      DOMSTRING_SIZE_ERR: 2,
      HIERARCHY_REQUEST_ERR: 3,
      WRONG_DOCUMENT_ERR: 4,
      INVALID_CHARACTER_ERR: 5,
      NO_DATA_ALLOWED_ERR: 6,
      NO_MODIFICATION_ALLOWED_ERR: 7,
      NOT_FOUND_ERR: 8,
      NOT_SUPPORTED_ERR: 9,
      INUSE_ATTRIBUTE_ERR: 10,
      INVALID_STATE_ERR: 11,
      SYNTAX_ERR: 12,
      INVALID_MODIFICATION_ERR: 13,
      NAMESPACE_ERR: 14,
      INVALID_ACCESS_ERR: 15,
      VALIDATION_ERR: 16,
      TYPE_MISMATCH_ERR: 17,
      SECURITY_ERR: 18,
      NETWORK_ERR: 19,
      ABORT_ERR: 20,
      URL_MISMATCH_ERR: 21,
      QUOTA_EXCEEDED_ERR: 22,
      TIMEOUT_ERR: 23,
      INVALID_NODE_TYPE_ERR: 24,
      DATA_CLONE_ERR: 25
    };
    var entries = Object.entries(ExceptionCode);
    for (i = 0; i < entries.length; i++) {
      key = entries[i][0];
      DOMException[key] = entries[i][1];
    }
    var key;
    var i;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    extendError(ParseError);
    exports2.DOMException = DOMException;
    exports2.DOMExceptionName = DOMExceptionName;
    exports2.ExceptionCode = ExceptionCode;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/@xmldom/xmldom/lib/grammar.js"(exports2) {
    "use strict";
    function detectUnicodeSupport(RegExpImpl) {
      try {
        if (typeof RegExpImpl !== "function") {
          RegExpImpl = RegExp;
        }
        var match = new RegExpImpl("\u{1D306}", "u").exec("\u{1D306}");
        return !!match && match[0].length === 2;
      } catch (error) {
      }
      return false;
    }
    var UNICODE_SUPPORT = detectUnicodeSupport();
    function chars(regexp) {
      if (regexp.source[0] !== "[") {
        throw new Error(regexp + " can not be used with chars");
      }
      return regexp.source.slice(1, regexp.source.lastIndexOf("]"));
    }
    function chars_without(regexp, search) {
      if (regexp.source[0] !== "[") {
        throw new Error("/" + regexp.source + "/ can not be used with chars_without");
      }
      if (!search || typeof search !== "string") {
        throw new Error(JSON.stringify(search) + " is not a valid search");
      }
      if (regexp.source.indexOf(search) === -1) {
        throw new Error('"' + search + '" is not is /' + regexp.source + "/");
      }
      if (search === "-" && regexp.source.indexOf(search) !== 1) {
        throw new Error('"' + search + '" is not at the first postion of /' + regexp.source + "/");
      }
      return new RegExp(regexp.source.replace(search, ""), UNICODE_SUPPORT ? "u" : "");
    }
    function reg(args) {
      var self2 = this;
      return new RegExp(
        Array.prototype.slice.call(arguments).map(function(part) {
          var isStr = typeof part === "string";
          if (isStr && self2 === void 0 && part === "|") {
            throw new Error("use regg instead of reg to wrap expressions with `|`!");
          }
          return isStr ? part : part.source;
        }).join(""),
        UNICODE_SUPPORT ? "mu" : "m"
      );
    }
    function regg(args) {
      if (arguments.length === 0) {
        throw new Error("no parameters provided");
      }
      return reg.apply(regg, ["(?:"].concat(Array.prototype.slice.call(arguments), [")"]));
    }
    var UNICODE_REPLACEMENT_CHARACTER = "\uFFFD";
    var Char = /[-\x09\x0A\x0D\x20-\x2C\x2E-\uD7FF\uE000-\uFFFD]/;
    if (UNICODE_SUPPORT) {
      Char = reg("[", chars(Char), "\\u{10000}-\\u{10FFFF}", "]");
    }
    var _SChar = /[\x20\x09\x0D\x0A]/;
    var SChar_s = chars(_SChar);
    var S = reg(_SChar, "+");
    var S_OPT = reg(_SChar, "*");
    var NameStartChar = /[:_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    if (UNICODE_SUPPORT) {
      NameStartChar = reg("[", chars(NameStartChar), "\\u{10000}-\\u{10FFFF}", "]");
    }
    var NameStartChar_s = chars(NameStartChar);
    var NameChar = reg("[", NameStartChar_s, chars(/[-.0-9\xB7]/), chars(/[\u0300-\u036F\u203F-\u2040]/), "]");
    var Name = reg(NameStartChar, NameChar, "*");
    var Nmtoken = reg(NameChar, "+");
    var EntityRef = reg("&", Name, ";");
    var CharRef = regg(/&#[0-9]+;|&#x[0-9a-fA-F]+;/);
    var Reference = regg(EntityRef, "|", CharRef);
    var PEReference = reg("%", Name, ";");
    var EntityValue = regg(
      reg('"', regg(/[^%&"]/, "|", PEReference, "|", Reference), "*", '"'),
      "|",
      reg("'", regg(/[^%&']/, "|", PEReference, "|", Reference), "*", "'")
    );
    var AttValue = regg('"', regg(/[^<&"]/, "|", Reference), "*", '"', "|", "'", regg(/[^<&']/, "|", Reference), "*", "'");
    var NCNameStartChar = chars_without(NameStartChar, ":");
    var NCNameChar = chars_without(NameChar, ":");
    var NCName = reg(NCNameStartChar, NCNameChar, "*");
    var QName = reg(NCName, regg(":", NCName), "?");
    var QName_exact = reg("^", QName, "$");
    var QName_group = reg("(", QName, ")");
    var SystemLiteral = regg(/"[^"]*"|'[^']*'/);
    var PI = reg(/^<\?/, "(", Name, ")", regg(S, "(", Char, "*?)"), "?", /\?>/);
    var PubidChar = /[\x20\x0D\x0Aa-zA-Z0-9-'()+,./:=?;!*#@$_%]/;
    var PubidLiteral = regg('"', PubidChar, '*"', "|", "'", chars_without(PubidChar, "'"), "*'");
    var COMMENT_START = "<!--";
    var COMMENT_END = "-->";
    var Comment = reg(COMMENT_START, regg(chars_without(Char, "-"), "|", reg("-", chars_without(Char, "-"))), "*", COMMENT_END);
    var PCDATA = "#PCDATA";
    var Mixed = regg(
      reg(/\(/, S_OPT, PCDATA, regg(S_OPT, /\|/, S_OPT, QName), "*", S_OPT, /\)\*/),
      "|",
      reg(/\(/, S_OPT, PCDATA, S_OPT, /\)/)
    );
    var _children_quantity = /[?*+]?/;
    var children = reg(
      /\([^>]+\)/,
      _children_quantity
      /*regg(choice, '|', seq), _children_quantity*/
    );
    var contentspec = regg("EMPTY", "|", "ANY", "|", Mixed, "|", children);
    var ELEMENTDECL_START = "<!ELEMENT";
    var elementdecl = reg(ELEMENTDECL_START, S, regg(QName, "|", PEReference), S, regg(contentspec, "|", PEReference), S_OPT, ">");
    var NotationType = reg("NOTATION", S, /\(/, S_OPT, Name, regg(S_OPT, /\|/, S_OPT, Name), "*", S_OPT, /\)/);
    var Enumeration = reg(/\(/, S_OPT, Nmtoken, regg(S_OPT, /\|/, S_OPT, Nmtoken), "*", S_OPT, /\)/);
    var EnumeratedType = regg(NotationType, "|", Enumeration);
    var AttType = regg(/CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS/, "|", EnumeratedType);
    var DefaultDecl = regg(/#REQUIRED|#IMPLIED/, "|", regg(regg("#FIXED", S), "?", AttValue));
    var AttDef = regg(S, Name, S, AttType, S, DefaultDecl);
    var ATTLIST_DECL_START = "<!ATTLIST";
    var AttlistDecl = reg(ATTLIST_DECL_START, S, Name, AttDef, "*", S_OPT, ">");
    var ABOUT_LEGACY_COMPAT = "about:legacy-compat";
    var ABOUT_LEGACY_COMPAT_SystemLiteral = regg('"' + ABOUT_LEGACY_COMPAT + '"', "|", "'" + ABOUT_LEGACY_COMPAT + "'");
    var SYSTEM = "SYSTEM";
    var PUBLIC = "PUBLIC";
    var ExternalID = regg(regg(SYSTEM, S, SystemLiteral), "|", regg(PUBLIC, S, PubidLiteral, S, SystemLiteral));
    var ExternalID_match = reg(
      "^",
      regg(
        regg(SYSTEM, S, "(?<SystemLiteralOnly>", SystemLiteral, ")"),
        "|",
        regg(PUBLIC, S, "(?<PubidLiteral>", PubidLiteral, ")", S, "(?<SystemLiteral>", SystemLiteral, ")")
      )
    );
    var NDataDecl = regg(S, "NDATA", S, Name);
    var EntityDef = regg(EntityValue, "|", regg(ExternalID, NDataDecl, "?"));
    var ENTITY_DECL_START = "<!ENTITY";
    var GEDecl = reg(ENTITY_DECL_START, S, Name, S, EntityDef, S_OPT, ">");
    var PEDef = regg(EntityValue, "|", ExternalID);
    var PEDecl = reg(ENTITY_DECL_START, S, "%", S, Name, S, PEDef, S_OPT, ">");
    var EntityDecl = regg(GEDecl, "|", PEDecl);
    var PublicID = reg(PUBLIC, S, PubidLiteral);
    var NotationDecl = reg("<!NOTATION", S, Name, S, regg(ExternalID, "|", PublicID), S_OPT, ">");
    var Eq = reg(S_OPT, "=", S_OPT);
    var VersionNum = /1[.]\d+/;
    var VersionInfo = reg(S, "version", Eq, regg("'", VersionNum, "'", "|", '"', VersionNum, '"'));
    var EncName = /[A-Za-z][-A-Za-z0-9._]*/;
    var EncodingDecl = regg(S, "encoding", Eq, regg('"', EncName, '"', "|", "'", EncName, "'"));
    var SDDecl = regg(S, "standalone", Eq, regg("'", regg("yes", "|", "no"), "'", "|", '"', regg("yes", "|", "no"), '"'));
    var XMLDecl = reg(/^<\?xml/, VersionInfo, EncodingDecl, "?", SDDecl, "?", S_OPT, /\?>/);
    var DOCTYPE_DECL_START = "<!DOCTYPE";
    var CDATA_START = "<![CDATA[";
    var CDATA_END = "]]>";
    var CDStart = /<!\[CDATA\[/;
    var CDEnd = /\]\]>/;
    var CData = reg(Char, "*?", CDEnd);
    var CDSect = reg(CDStart, CData);
    exports2.chars = chars;
    exports2.chars_without = chars_without;
    exports2.detectUnicodeSupport = detectUnicodeSupport;
    exports2.reg = reg;
    exports2.regg = regg;
    exports2.ABOUT_LEGACY_COMPAT = ABOUT_LEGACY_COMPAT;
    exports2.ABOUT_LEGACY_COMPAT_SystemLiteral = ABOUT_LEGACY_COMPAT_SystemLiteral;
    exports2.AttlistDecl = AttlistDecl;
    exports2.CDATA_START = CDATA_START;
    exports2.CDATA_END = CDATA_END;
    exports2.CDSect = CDSect;
    exports2.Char = Char;
    exports2.Comment = Comment;
    exports2.COMMENT_START = COMMENT_START;
    exports2.COMMENT_END = COMMENT_END;
    exports2.DOCTYPE_DECL_START = DOCTYPE_DECL_START;
    exports2.elementdecl = elementdecl;
    exports2.EntityDecl = EntityDecl;
    exports2.EntityValue = EntityValue;
    exports2.ExternalID = ExternalID;
    exports2.ExternalID_match = ExternalID_match;
    exports2.Name = Name;
    exports2.NotationDecl = NotationDecl;
    exports2.Reference = Reference;
    exports2.PEReference = PEReference;
    exports2.PI = PI;
    exports2.PUBLIC = PUBLIC;
    exports2.PubidLiteral = PubidLiteral;
    exports2.QName = QName;
    exports2.QName_exact = QName_exact;
    exports2.QName_group = QName_group;
    exports2.S = S;
    exports2.SChar_s = SChar_s;
    exports2.S_OPT = S_OPT;
    exports2.SYSTEM = SYSTEM;
    exports2.SystemLiteral = SystemLiteral;
    exports2.UNICODE_REPLACEMENT_CHARACTER = UNICODE_REPLACEMENT_CHARACTER;
    exports2.UNICODE_SUPPORT = UNICODE_SUPPORT;
    exports2.XMLDecl = XMLDecl;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    var find = conventions.find;
    var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    var hasOwn = conventions.hasOwn;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
    var isHTMLVoidElement = conventions.isHTMLVoidElement;
    var MIME_TYPE = conventions.MIME_TYPE;
    var NAMESPACE = conventions.NAMESPACE;
    var PDC = Symbol();
    var errors = require_errors();
    var DOMException = errors.DOMException;
    var DOMExceptionName = errors.DOMExceptionName;
    var g = require_grammar();
    function checkSymbol(symbol) {
      if (symbol !== PDC) {
        throw new TypeError("Illegal constructor");
      }
    }
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!hasOwn(current, element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function validateQualifiedName(qualifiedName) {
      if (!g.QName_exact.test(qualifiedName)) {
        throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in qualified name "' + qualifiedName + '"');
      }
    }
    function validateAndExtract(namespace, qualifiedName) {
      validateQualifiedName(qualifiedName);
      namespace = namespace || null;
      var prefix = null;
      var localName = qualifiedName;
      if (qualifiedName.indexOf(":") >= 0) {
        var splitResult = qualifiedName.split(":");
        prefix = splitResult[0];
        localName = splitResult[1];
      }
      if (prefix !== null && namespace === null) {
        throw new DOMException(DOMException.NAMESPACE_ERR, "prefix is non-null and namespace is null");
      }
      if (prefix === "xml" && namespace !== conventions.NAMESPACE.XML) {
        throw new DOMException(DOMException.NAMESPACE_ERR, 'prefix is "xml" and namespace is not the XML namespace');
      }
      if ((prefix === "xmlns" || qualifiedName === "xmlns") && namespace !== conventions.NAMESPACE.XMLNS) {
        throw new DOMException(
          DOMException.NAMESPACE_ERR,
          'either qualifiedName or prefix is "xmlns" and namespace is not the XMLNS namespace'
        );
      }
      if (namespace === conventions.NAMESPACE.XMLNS && prefix !== "xmlns" && qualifiedName !== "xmlns") {
        throw new DOMException(
          DOMException.NAMESPACE_ERR,
          'namespace is the XMLNS namespace and neither qualifiedName nor prefix is "xmlns"'
        );
      }
      return [namespace, prefix, localName];
    }
    function copy(src, dest) {
      for (var p in src) {
        if (hasOwn(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t = function() {
        };
        t.prototype = Super.prototype;
        t = new t();
        copy(pt, t);
        Class.prototype = pt = t;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var DocumentPosition = conventions.freeze({
      DOCUMENT_POSITION_DISCONNECTED: 1,
      DOCUMENT_POSITION_PRECEDING: 2,
      DOCUMENT_POSITION_FOLLOWING: 4,
      DOCUMENT_POSITION_CONTAINS: 8,
      DOCUMENT_POSITION_CONTAINED_BY: 16,
      DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32
    });
    function commonAncestor(a, b) {
      if (b.length < a.length) return commonAncestor(b, a);
      var c = null;
      for (var n in a) {
        if (a[n] !== b[n]) return c;
        c = a[n];
      }
      return c;
    }
    function docGUID(doc) {
      if (!doc.guid) doc.guid = Math.random();
      return doc.guid;
    }
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1
       * inclusive.
       *
       * @type {number}
       */
      length: 0,
      /**
       * Returns the item at `index`. If index is greater than or equal to the number of nodes in
       * the list, this returns null.
       *
       * @param index
       * Unsigned long Index into the collection.
       * @returns {Node | null}
       * The node at position `index` in the NodeList,
       * or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      /**
       * Returns a string representation of the NodeList.
       *
       * @param {unknown} nodeFilter
       * __A filter function? Not implemented according to the spec?__.
       * @returns {string}
       * A string representation of the NodeList.
       */
      toString: function(nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * Filters the NodeList based on a predicate.
       *
       * @param {function(Node): boolean} predicate
       * - A predicate function to filter the NodeList.
       * @returns {Node[]}
       * An array of nodes that satisfy the predicate.
       * @private
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * Returns the first index at which a given node can be found in the NodeList, or -1 if it is
       * not present.
       *
       * @param {Node} item
       * - The Node item to locate in the NodeList.
       * @returns {number}
       * The first index of the node in the NodeList; -1 if not found.
       * @private
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    NodeList.prototype[Symbol.iterator] = function() {
      var me = this;
      var index = 0;
      return {
        next: function() {
          if (index < me.length) {
            return {
              value: me[index++],
              done: false
            };
          } else {
            return {
              done: true
            };
          }
        },
        return: function() {
          return {
            done: true
          };
        }
      };
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (hasOwn(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = 0;
      while (i < list.length) {
        if (list[i] === node) {
          return i;
        }
        i++;
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length] = newAttr;
        list.length++;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i <= lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
          }
          attr.ownerElement = null;
        }
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      /**
       * Get an attribute by name. Note: Name is in lower case in case of HTML namespace and
       * document.
       *
       * @param {string} localName
       * The local name of the attribute.
       * @returns {Attr | null}
       * The attribute with the given local name, or null if no such attribute exists.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-name
       */
      getNamedItem: function(localName) {
        if (this._ownerElement && this._ownerElement._isInHTMLDocumentAndNamespace()) {
          localName = localName.toLowerCase();
        }
        var i = 0;
        while (i < this.length) {
          var attr = this[i];
          if (attr.nodeName === localName) {
            return attr;
          }
          i++;
        }
        return null;
      },
      /**
       * Set an attribute.
       *
       * @param {Attr} attr
       * The attribute to set.
       * @returns {Attr | null}
       * The old attribute with the same local name and namespace URI as the new one, or null if no
       * such attribute exists.
       * @throws {DOMException}
       * With code:
       * - {@link INUSE_ATTRIBUTE_ERR} - If the attribute is already an attribute of another
       * element.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
       */
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el !== this._ownerElement) {
          throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        if (oldAttr === attr) {
          return attr;
        }
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /**
       * Set an attribute, replacing an existing attribute with the same local name and namespace
       * URI if one exists.
       *
       * @param {Attr} attr
       * The attribute to set.
       * @returns {Attr | null}
       * The old attribute with the same local name and namespace URI as the new one, or null if no
       * such attribute exists.
       * @throws {DOMException}
       * Throws a DOMException with the name "InUseAttributeError" if the attribute is already an
       * attribute of another element.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-set
       */
      setNamedItemNS: function(attr) {
        return this.setNamedItem(attr);
      },
      /**
       * Removes an attribute specified by the local name.
       *
       * @param {string} localName
       * The local name of the attribute to be removed.
       * @returns {Attr}
       * The attribute node that was removed.
       * @throws {DOMException}
       * With code:
       * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given name is found.
       * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditem
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-name
       */
      removeNamedItem: function(localName) {
        var attr = this.getNamedItem(localName);
        if (!attr) {
          throw new DOMException(DOMException.NOT_FOUND_ERR, localName);
        }
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      /**
       * Removes an attribute specified by the namespace and local name.
       *
       * @param {string | null} namespaceURI
       * The namespace URI of the attribute to be removed.
       * @param {string} localName
       * The local name of the attribute to be removed.
       * @returns {Attr}
       * The attribute node that was removed.
       * @throws {DOMException}
       * With code:
       * - {@link DOMException.NOT_FOUND_ERR} if no attribute with the given namespace URI and local
       * name is found.
       * @see https://dom.spec.whatwg.org/#dom-namednodemap-removenameditemns
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-remove-by-namespace
       */
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        if (!attr) {
          throw new DOMException(DOMException.NOT_FOUND_ERR, namespaceURI ? namespaceURI + " : " + localName : localName);
        }
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      /**
       * Get an attribute by namespace and local name.
       *
       * @param {string | null} namespaceURI
       * The namespace URI of the attribute.
       * @param {string} localName
       * The local name of the attribute.
       * @returns {Attr | null}
       * The attribute with the given namespace URI and local name, or null if no such attribute
       * exists.
       * @see https://dom.spec.whatwg.org/#concept-element-attributes-get-by-namespace
       */
      getNamedItemNS: function(namespaceURI, localName) {
        if (!namespaceURI) {
          namespaceURI = null;
        }
        var i = 0;
        while (i < this.length) {
          var node = this[i];
          if (node.localName === localName && node.namespaceURI === namespaceURI) {
            return node;
          }
          i++;
        }
        return null;
      }
    };
    NamedNodeMap.prototype[Symbol.iterator] = function() {
      var me = this;
      var index = 0;
      return {
        next: function() {
          if (index < me.length) {
            return {
              value: me[index++],
              done: false
            };
          } else {
            return {
              done: true
            };
          }
        },
        return: function() {
          return {
            done: true
          };
        }
      };
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * Test if the DOM implementation implements a specific feature and version, as specified in
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/core.html#DOMFeatures DOM Features}.
       *
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given
       * feature is supported. The different implementations fairly diverged in what kind of
       * features were reported. The latest version of the spec settled to force this method to
       * always return true, where the functionality was accurate and in use.
       *
       * @deprecated
       * It is deprecated and modern browsers return true in all cases.
       * @function DOMImplementation#hasFeature
       * @param {string} feature
       * The name of the feature to test.
       * @param {string} [version]
       * This is the version number of the feature to test.
       * @returns {boolean}
       * Always returns true.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-5CED94D7 DOM Level 3 Core
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates a DOM Document object of the specified type with its document element. Note that
       * based on the {@link DocumentType}
       * given to create the document, the implementation may instantiate specialized
       * {@link Document} objects that support additional features than the "Core", such as "HTML"
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML}.
       * On the other hand, setting the {@link DocumentType} after the document was created makes
       * this very unlikely to happen. Alternatively, specialized {@link Document} creation methods,
       * such as createHTMLDocument
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#DOM2HTML DOM Level 2 HTML},
       * can be used to obtain specific types of {@link Document} objects.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document`
       * instance (with it's `type` set to `'xml'`).
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       *
       * @function DOMImplementation.createDocument
       * @param {string | null} namespaceURI
       * The
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-namespaceURI namespace URI}
       * of the document element to create or null.
       * @param {string | null} qualifiedName
       * The
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified name}
       * of the document element to be created or null.
       * @param {DocumentType | null} [doctype=null]
       * The type of document to be created or null. When doctype is not null, its
       * {@link Node#ownerDocument} attribute is set to the document being created. Default is
       * `null`
       * @returns {Document}
       * A new {@link Document} object with its document element. If the NamespaceURI,
       * qualifiedName, and doctype are null, the returned {@link Document} is empty with no
       * document element.
       * @throws {DOMException}
       * With code:
       *
       * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
       * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
       * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed, if the qualifiedName has a
       * prefix and the namespaceURI is null, or if the qualifiedName is null and the namespaceURI
       * is different from null, or if the qualifiedName has a prefix that is "xml" and the
       * namespaceURI is different from "{@link http://www.w3.org/XML/1998/namespace}"
       * {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#Namespaces XML Namespaces},
       * or if the DOM implementation does not support the "XML" feature but a non-null namespace
       * URI was provided, since namespaces were defined by XML.
       * - `WRONG_DOCUMENT_ERR`: Raised if doctype has already been used with a different document
       * or was created from a different implementation.
       * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
       * "XML" and the language exposed through the Document does not support XML Namespaces (such
       * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
       * @since DOM Level 2.
       * @see {@link #createHTMLDocument}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument DOM Living Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-2-Core-DOM-createDocument DOM
       *      Level 3 Core
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM
       *      Level 2 Core (initial)
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var contentType = MIME_TYPE.XML_APPLICATION;
        if (namespaceURI === NAMESPACE.HTML) {
          contentType = MIME_TYPE.XML_XHTML_APPLICATION;
        } else if (namespaceURI === NAMESPACE.SVG) {
          contentType = MIME_TYPE.XML_SVG_IMAGE;
        }
        var doc = new Document(PDC, { contentType });
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Creates an empty DocumentType node. Entity declarations and notations are not made
       * available. Entity reference expansions and default attribute additions do not occur.
       *
       * **This behavior is slightly different from the one in the specs**:
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - `publicId` and `systemId` contain the raw data including any possible quotes,
       *   so they can always be serialized back to the original value
       * - `internalSubset` contains the raw string between `[` and `]` if present,
       *   but is not parsed or validated in any form.
       *
       * @function DOMImplementation#createDocumentType
       * @param {string} qualifiedName
       * The {@link https://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-qualifiedname qualified
       * name} of the document type to be created.
       * @param {string} [publicId]
       * The external subset public identifier.
       * @param {string} [systemId]
       * The external subset system identifier.
       * @param {string} [internalSubset]
       * the internal subset or an empty string if it is not present
       * @returns {DocumentType}
       * A new {@link DocumentType} node with {@link Node#ownerDocument} set to null.
       * @throws {DOMException}
       * With code:
       *
       * - `INVALID_CHARACTER_ERR`: Raised if the specified qualified name is not an XML name
       * according to {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#XML XML 1.0}.
       * - `NAMESPACE_ERR`: Raised if the qualifiedName is malformed.
       * - `NOT_SUPPORTED_ERR`: May be raised if the implementation does not support the feature
       * "XML" and the language exposed through the Document does not support XML Namespaces (such
       * as {@link https://www.w3.org/TR/DOM-Level-3-Core/references.html#HTML40 HTML 4.01}).
       * @since DOM Level 2.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType
       *      MDN
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living
       *      Standard
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Level-3-Core-DOM-createDocType DOM
       *      Level 3 Core
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM
       *      Level 2 Core
       * @see https://github.com/xmldom/xmldom/blob/master/CHANGELOG.md#050
       * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-Core-DocType-internalSubset
       * @prettierignore
       */
      createDocumentType: function(qualifiedName, publicId, systemId, internalSubset) {
        validateQualifiedName(qualifiedName);
        var node = new DocumentType(PDC);
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        node.internalSubset = internalSubset || "";
        node.childNodes = new NodeList();
        return node;
      },
      /**
       * Returns an HTML document, that might already have a basic DOM structure.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - If the first argument is `false` no initial nodes are added (steps 3-7 in the specs are
       * omitted)
       * - `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       *
       * @param {string | false} [title]
       * A string containing the title to give the new HTML document.
       * @returns {Document}
       * The HTML document.
       * @since WHATWG Living Standard.
       * @see {@link #createDocument}
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createhtmldocument
       * @see https://dom.spec.whatwg.org/#html-document
       */
      createHTMLDocument: function(title) {
        var doc = new Document(PDC, { contentType: MIME_TYPE.HTML });
        doc.implementation = this;
        doc.childNodes = new NodeList();
        if (title !== false) {
          doc.doctype = this.createDocumentType("html");
          doc.doctype.ownerDocument = doc;
          doc.appendChild(doc.doctype);
          var htmlNode = doc.createElement("html");
          doc.appendChild(htmlNode);
          var headNode = doc.createElement("head");
          htmlNode.appendChild(headNode);
          if (typeof title === "string") {
            var titleNode = doc.createElement("title");
            titleNode.appendChild(doc.createTextNode(title));
            headNode.appendChild(titleNode);
          }
          htmlNode.appendChild(doc.createElement("body"));
        }
        return doc;
      }
    };
    function Node(symbol) {
      checkSymbol(symbol);
    }
    Node.prototype = {
      /**
       * The first child of this node.
       *
       * @type {Node | null}
       */
      firstChild: null,
      /**
       * The last child of this node.
       *
       * @type {Node | null}
       */
      lastChild: null,
      /**
       * The previous sibling of this node.
       *
       * @type {Node | null}
       */
      previousSibling: null,
      /**
       * The next sibling of this node.
       *
       * @type {Node | null}
       */
      nextSibling: null,
      /**
       * The parent node of this node.
       *
       * @type {Node | null}
       */
      parentNode: null,
      /**
       * The parent element of this node.
       *
       * @type {Element | null}
       */
      get parentElement() {
        return this.parentNode && this.parentNode.nodeType === this.ELEMENT_NODE ? this.parentNode : null;
      },
      /**
       * The child nodes of this node.
       *
       * @type {NodeList}
       */
      childNodes: null,
      /**
       * The document object associated with this node.
       *
       * @type {Document | null}
       */
      ownerDocument: null,
      /**
       * The value of this node.
       *
       * @type {string | null}
       */
      nodeValue: null,
      /**
       * The namespace URI of this node.
       *
       * @type {string | null}
       */
      namespaceURI: null,
      /**
       * The prefix of the namespace for this node.
       *
       * @type {string | null}
       */
      prefix: null,
      /**
       * The local part of the qualified name of this node.
       *
       * @type {string | null}
       */
      localName: null,
      /**
       * The baseURI is currently always `about:blank`,
       * since that's what happens when you create a document from scratch.
       *
       * @type {'about:blank'}
       */
      baseURI: "about:blank",
      /**
       * Is true if this node is part of a document.
       *
       * @type {boolean}
       */
      get isConnected() {
        var rootNode = this.getRootNode();
        return rootNode && rootNode.nodeType === rootNode.DOCUMENT_NODE;
      },
      /**
       * Checks whether `other` is an inclusive descendant of this node.
       *
       * @param {Node | null | undefined} other
       * The node to check.
       * @returns {boolean}
       * True if `other` is an inclusive descendant of this node; false otherwise.
       * @see https://dom.spec.whatwg.org/#dom-node-contains
       */
      contains: function(other) {
        if (!other) return false;
        var parent = other;
        do {
          if (this === parent) return true;
          parent = other.parentNode;
        } while (parent);
        return false;
      },
      /**
       * @typedef GetRootNodeOptions
       * @property {boolean} [composed=false]
       */
      /**
       * Searches for the root node of this node.
       *
       * **This behavior is slightly different from the in the specs**:
       * - ignores `options.composed`, since `ShadowRoot`s are unsupported, always returns root.
       *
       * @param {GetRootNodeOptions} [options]
       * @returns {Node}
       * Root node.
       * @see https://dom.spec.whatwg.org/#dom-node-getrootnode
       * @see https://dom.spec.whatwg.org/#concept-shadow-including-root
       */
      getRootNode: function(options) {
        var parent = this;
        do {
          if (!parent.parentNode) {
            return parent;
          }
          parent = parent.parentNode;
        } while (parent);
      },
      /**
       * Checks whether the given node is equal to this node.
       *
       * @param {Node} [otherNode]
       * @see https://dom.spec.whatwg.org/#concept-node-equals
       */
      isEqualNode: function(otherNode) {
        if (!otherNode) return false;
        if (this.nodeType !== otherNode.nodeType) return false;
        switch (this.nodeType) {
          case this.DOCUMENT_TYPE_NODE:
            if (this.name !== otherNode.name) return false;
            if (this.publicId !== otherNode.publicId) return false;
            if (this.systemId !== otherNode.systemId) return false;
            break;
          case this.ELEMENT_NODE:
            if (this.namespaceURI !== otherNode.namespaceURI) return false;
            if (this.prefix !== otherNode.prefix) return false;
            if (this.localName !== otherNode.localName) return false;
            if (this.attributes.length !== otherNode.attributes.length) return false;
            for (var i = 0; i < this.attributes.length; i++) {
              var attr = this.attributes.item(i);
              if (!attr.isEqualNode(otherNode.getAttributeNodeNS(attr.namespaceURI, attr.localName))) {
                return false;
              }
            }
            break;
          case this.ATTRIBUTE_NODE:
            if (this.namespaceURI !== otherNode.namespaceURI) return false;
            if (this.localName !== otherNode.localName) return false;
            if (this.value !== otherNode.value) return false;
            break;
          case this.PROCESSING_INSTRUCTION_NODE:
            if (this.target !== otherNode.target || this.data !== otherNode.data) {
              return false;
            }
            break;
          case this.TEXT_NODE:
          case this.COMMENT_NODE:
            if (this.data !== otherNode.data) return false;
            break;
        }
        if (this.childNodes.length !== otherNode.childNodes.length) {
          return false;
        }
        for (var i = 0; i < this.childNodes.length; i++) {
          if (!this.childNodes[i].isEqualNode(otherNode.childNodes[i])) {
            return false;
          }
        }
        return true;
      },
      /**
       * Checks whether or not the given node is this node.
       *
       * @param {Node} [otherNode]
       */
      isSameNode: function(otherNode) {
        return this === otherNode;
      },
      /**
       * Inserts a node before a reference node as a child of this node.
       *
       * @param {Node} newChild
       * The new child node to be inserted.
       * @param {Node | null} refChild
       * The reference node before which newChild will be inserted.
       * @returns {Node}
       * The new child node successfully inserted.
       * @throws {DOMException}
       * Throws a DOMException if inserting the node would result in a DOM tree that is not
       * well-formed, or if `child` is provided but is not a child of `parent`.
       * See {@link _insertBefore} for more details.
       * @since Modified in DOM L2
       */
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      /**
       * Replaces an old child node with a new child node within this node.
       *
       * @param {Node} newChild
       * The new node that is to replace the old node.
       * If it already exists in the DOM, it is removed from its original position.
       * @param {Node} oldChild
       * The existing child node to be replaced.
       * @returns {Node}
       * Returns the replaced child node.
       * @throws {DOMException}
       * Throws a DOMException if replacing the node would result in a DOM tree that is not
       * well-formed, or if `oldChild` is not a child of `this`.
       * This can also occur if the pre-replacement validity assertion fails.
       * See {@link _insertBefore}, {@link Node.removeChild}, and
       * {@link assertPreReplacementValidityInDocument} for more details.
       * @see https://dom.spec.whatwg.org/#concept-node-replace
       */
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      /**
       * Removes an existing child node from this node.
       *
       * @param {Node} oldChild
       * The child node to be removed.
       * @returns {Node}
       * Returns the removed child node.
       * @throws {DOMException}
       * Throws a DOMException if `oldChild` is not a child of `this`.
       * See {@link _removeChild} for more details.
       */
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      /**
       * Appends a child node to this node.
       *
       * @param {Node} newChild
       * The child node to be appended to this node.
       * If it already exists in the DOM, it is removed from its original position.
       * @returns {Node}
       * Returns the appended child node.
       * @throws {DOMException}
       * Throws a DOMException if appending the node would result in a DOM tree that is not
       * well-formed, or if `newChild` is not a valid Node.
       * See {@link insertBefore} for more details.
       */
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      /**
       * Determines whether this node has any child nodes.
       *
       * @returns {boolean}
       * Returns true if this node has any child nodes, and false otherwise.
       */
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      /**
       * Creates a copy of the calling node.
       *
       * @param {boolean} deep
       * If true, the contents of the node are recursively copied.
       * If false, only the node itself (and its attributes, if it is an element) are copied.
       * @returns {Node}
       * Returns the newly created copy of the node.
       * @throws {DOMException}
       * May throw a DOMException if operations within {@link Element#setAttributeNode} or
       * {@link Node#appendChild} (which are potentially invoked in this method) do not meet their
       * specific constraints.
       * @see {@link cloneNode}
       */
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      /**
       * Puts the specified node and all of its subtree into a "normalized" form. In a normalized
       * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.
       *
       * Specifically, this method merges any adjacent text nodes (i.e., nodes for which `nodeType`
       * is `TEXT_NODE`) into a single node with the combined data. It also removes any empty text
       * nodes.
       *
       * This method operates recursively, so it also normalizes any and all descendent nodes within
       * the subtree.
       *
       * @throws {DOMException}
       * May throw a DOMException if operations within removeChild or appendData (which are
       * potentially invoked in this method) do not meet their specific constraints.
       * @since Modified in DOM Level 2
       * @see {@link Node.removeChild}
       * @see {@link CharacterData.appendData}
       */
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      /**
       * Checks whether the DOM implementation implements a specific feature and its version.
       *
       * @deprecated
       * Since `DOMImplementation.hasFeature` is deprecated and always returns true.
       * @param {string} feature
       * The package name of the feature to test. This is the same name that can be passed to the
       * method `hasFeature` on `DOMImplementation`.
       * @param {string} version
       * This is the version number of the package name to test.
       * @returns {boolean}
       * Returns true in all cases in the current implementation.
       * @since Introduced in DOM Level 2
       * @see {@link DOMImplementation.hasFeature}
       */
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} namespaceURI
       * The namespace URI for which to find the associated prefix.
       * @returns {string | null}
       * The associated prefix, if found; otherwise, null.
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       * @prettierignore
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (hasOwn(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      /**
       * This function is used to look up the namespace URI associated with the given prefix,
       * starting from this node.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} prefix
       * The prefix for which to find the associated namespace URI.
       * @returns {string | null}
       * The associated namespace URI, if found; otherwise, null.
       * @since DOM Level 3
       * @see https://dom.spec.whatwg.org/#dom-node-lookupnamespaceuri
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI
       * @prettierignore
       */
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (hasOwn(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      /**
       * Determines whether the given namespace URI is the default namespace.
       *
       * The function works by looking up the prefix associated with the given namespace URI. If no
       * prefix is found (i.e., the namespace URI is not registered in the namespace map of this
       * node or any of its ancestors), it returns `true`, implying the namespace URI is considered
       * the default.
       *
       * **This behavior is different from the in the specs**:
       * - no node type specific handling
       * - uses the internal attribute _nsMap for resolving namespaces that is updated when changing attributes
       *
       * @param {string | null} namespaceURI
       * The namespace URI to be checked.
       * @returns {boolean}
       * Returns true if the given namespace URI is the default namespace, false otherwise.
       * @since DOM Level 3
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isDefaultNamespace
       * @see https://dom.spec.whatwg.org/#dom-node-isdefaultnamespace
       * @prettierignore
       */
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      },
      /**
       * Compares the reference node with a node with regard to their position in the document and
       * according to the document order.
       *
       * @param {Node} other
       * The node to compare the reference node to.
       * @returns {number}
       * Returns how the node is positioned relatively to the reference node according to the
       * bitmask. 0 if reference node and given node are the same.
       * @since DOM Level 3
       * @see https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#Node3-compare
       * @see https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
       */
      compareDocumentPosition: function(other) {
        if (this === other) return 0;
        var node1 = other;
        var node2 = this;
        var attr1 = null;
        var attr2 = null;
        if (node1 instanceof Attr) {
          attr1 = node1;
          node1 = attr1.ownerElement;
        }
        if (node2 instanceof Attr) {
          attr2 = node2;
          node2 = attr2.ownerElement;
          if (attr1 && node1 && node2 === node1) {
            for (var i = 0, attr; attr = node2.attributes[i]; i++) {
              if (attr === attr1)
                return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
              if (attr === attr2)
                return DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
            }
          }
        }
        if (!node1 || !node2 || node2.ownerDocument !== node1.ownerDocument) {
          return DocumentPosition.DOCUMENT_POSITION_DISCONNECTED + DocumentPosition.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC + (docGUID(node2.ownerDocument) > docGUID(node1.ownerDocument) ? DocumentPosition.DOCUMENT_POSITION_FOLLOWING : DocumentPosition.DOCUMENT_POSITION_PRECEDING);
        }
        if (attr2 && node1 === node2) {
          return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
        }
        if (attr1 && node1 === node2) {
          return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
        }
        var chain1 = [];
        var ancestor1 = node1.parentNode;
        while (ancestor1) {
          if (!attr2 && ancestor1 === node2) {
            return DocumentPosition.DOCUMENT_POSITION_CONTAINED_BY + DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          }
          chain1.push(ancestor1);
          ancestor1 = ancestor1.parentNode;
        }
        chain1.reverse();
        var chain2 = [];
        var ancestor2 = node2.parentNode;
        while (ancestor2) {
          if (!attr1 && ancestor2 === node1) {
            return DocumentPosition.DOCUMENT_POSITION_CONTAINS + DocumentPosition.DOCUMENT_POSITION_PRECEDING;
          }
          chain2.push(ancestor2);
          ancestor2 = ancestor2.parentNode;
        }
        chain2.reverse();
        var ca = commonAncestor(chain1, chain2);
        for (var n in ca.childNodes) {
          var child = ca.childNodes[n];
          if (child === node2) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          if (child === node1) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
          if (chain2.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_FOLLOWING;
          if (chain1.indexOf(child) >= 0) return DocumentPosition.DOCUMENT_POSITION_PRECEDING;
        }
        return 0;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    copy(DocumentPosition, Node);
    copy(DocumentPosition, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document(symbol, options) {
      checkSymbol(symbol);
      var opt = options || {};
      this.ownerDocument = this;
      this.contentType = opt.contentType || MIME_TYPE.XML_APPLICATION;
      this.type = isHTMLMimeType(this.contentType) ? "html" : "xml";
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, parent, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var childNodes = parent.childNodes;
        if (newChild && !newChild.nextSibling) {
          childNodes[childNodes.length++] = newChild;
        } else {
          var child = parent.firstChild;
          var i = 0;
          while (child) {
            childNodes[i++] = child;
            child = child.nextSibling;
          }
          childNodes.length = i;
          delete childNodes[childNodes.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      if (parentNode !== child.parentNode) {
        throw new DOMException(DOMException.NOT_FOUND_ERR, "child's parent is not parent");
      }
      var oldPreviousSibling = child.previousSibling;
      var oldNextSibling = child.nextSibling;
      if (oldPreviousSibling) {
        oldPreviousSibling.nextSibling = oldNextSibling;
      } else {
        parentNode.firstChild = oldNextSibling;
      }
      if (oldNextSibling) {
        oldNextSibling.previousSibling = oldPreviousSibling;
      } else {
        parentNode.lastChild = oldPreviousSibling;
      }
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (node.nodeType === Node.CDATA_SECTION_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_TYPE_NODE || node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE || node.nodeType === Node.TEXT_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(DOMException.NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          DOMException.HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent, node);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    Document.prototype = {
      /**
       * The implementation that created this document.
       *
       * @type DOMImplementation
       * @readonly
       */
      implementation: null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @type DocumentType
       * @readonly
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        newChild.ownerDocument = this;
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        var removed = _removeChild(this, oldChild);
        if (removed === this.documentElement) {
          this.documentElement = null;
        }
        return removed;
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        newChild.ownerDocument = this;
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * Creates a new `Element` that is owned by this `Document`.
       * In HTML Documents `localName` is the lower cased `tagName`,
       * otherwise no transformation is being applied.
       * When `contentType` implies the HTML namespace, it will be set as `namespaceURI`.
       *
       * __This implementation differs from the specification:__ - The provided name is not checked
       * against the `Name` production,
       * so no related error will be thrown.
       * - There is no interface `HTMLElement`, it is always an `Element`.
       * - There is no support for a second argument to indicate using custom elements.
       *
       * @param {string} tagName
       * @returns {Element}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
       * @see https://dom.spec.whatwg.org/#dom-document-createelement
       * @see https://dom.spec.whatwg.org/#concept-create-element
       */
      createElement: function(tagName) {
        var node = new Element(PDC);
        node.ownerDocument = this;
        if (this.type === "html") {
          tagName = tagName.toLowerCase();
        }
        if (hasDefaultHTMLNamespace(this.contentType)) {
          node.namespaceURI = NAMESPACE.HTML;
        }
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      /**
       * @returns {DocumentFragment}
       */
      createDocumentFragment: function() {
        var node = new DocumentFragment(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      /**
       * @param {string} data
       * @returns {Text}
       */
      createTextNode: function(data) {
        var node = new Text(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} data
       * @returns {Comment}
       */
      createComment: function(data) {
        var node = new Comment(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} data
       * @returns {CDATASection}
       */
      createCDATASection: function(data) {
        var node = new CDATASection(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.appendData(data);
        return node;
      },
      /**
       * @param {string} target
       * @param {string} data
       * @returns {ProcessingInstruction}
       */
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      /**
       * Creates an `Attr` node that is owned by this document.
       * In HTML Documents `localName` is the lower cased `name`,
       * otherwise no transformation is being applied.
       *
       * __This implementation differs from the specification:__ - The provided name is not checked
       * against the `Name` production,
       * so no related error will be thrown.
       *
       * @param {string} name
       * @returns {Attr}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createAttribute
       * @see https://dom.spec.whatwg.org/#dom-document-createattribute
       */
      createAttribute: function(name) {
        if (!g.QName_exact.test(name)) {
          throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'invalid character in name "' + name + '"');
        }
        if (this.type === "html") {
          name = name.toLowerCase();
        }
        return this._createAttribute(name);
      },
      _createAttribute: function(name) {
        var node = new Attr(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      /**
       * Creates an EntityReference object.
       * The current implementation does not fill the `childNodes` with those of the corresponding
       * `Entity`
       *
       * @deprecated
       * In DOM Level 4.
       * @param {string} name
       * The name of the entity to reference. No namespace well-formedness checks are performed.
       * @returns {EntityReference}
       * @throws {DOMException}
       * With code `INVALID_CHARACTER_ERR` when `name` is not valid.
       * @throws {DOMException}
       * with code `NOT_SUPPORTED_ERR` when the document is of type `html`
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-392B75AE
       */
      createEntityReference: function(name) {
        if (!g.Name.test(name)) {
          throw new DOMException(DOMException.INVALID_CHARACTER_ERR, 'not a valid xml name "' + name + '"');
        }
        if (this.type === "html") {
          throw new DOMException("document is an html document", DOMExceptionName.NotSupportedError);
        }
        var node = new EntityReference(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      /**
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @returns {Element}
       */
      createElementNS: function(namespaceURI, qualifiedName) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var node = new Element(PDC);
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = validated[0];
        node.prefix = validated[1];
        node.localName = validated[2];
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      /**
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @returns {Attr}
       */
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var node = new Attr(PDC);
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.specified = true;
        node.namespaceURI = validated[0];
        node.prefix = validated[1];
        node.localName = validated[2];
        return node;
      }
    };
    _extends(Document, Node);
    function Element(symbol) {
      checkSymbol(symbol);
      this._nsMap = /* @__PURE__ */ Object.create(null);
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      /**
       * The attributes of this element.
       *
       * @type {NamedNodeMap | null}
       */
      attributes: null,
      getQualifiedName: function() {
        return this.prefix ? this.prefix + ":" + this.localName : this.localName;
      },
      _isInHTMLDocumentAndNamespace: function() {
        return this.ownerDocument.type === "html" && this.namespaceURI === NAMESPACE.HTML;
      },
      /**
       * Implementaton of Level2 Core function hasAttributes.
       *
       * @returns {boolean}
       * True if attribute list is not empty.
       * @see https://www.w3.org/TR/DOM-Level-2-Core/#core-ID-NodeHasAttrs
       */
      hasAttributes: function() {
        return !!(this.attributes && this.attributes.length);
      },
      hasAttribute: function(name) {
        return !!this.getAttributeNode(name);
      },
      /**
       * Returns elements first attribute whose qualified name is `name`, and `null`
       * if there is no such attribute.
       *
       * @param {string} name
       * @returns {string | null}
       */
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr ? attr.value : null;
      },
      getAttributeNode: function(name) {
        if (this._isInHTMLDocumentAndNamespace()) {
          name = name.toLowerCase();
        }
        return this.attributes.getNamedItem(name);
      },
      /**
       * Sets the value of elements first attribute whose qualified name is qualifiedName to value.
       *
       * @param {string} name
       * @param {string} value
       */
      setAttribute: function(name, value) {
        if (this._isInHTMLDocumentAndNamespace()) {
          name = name.toLowerCase();
        }
        var attr = this.getAttributeNode(name);
        if (attr) {
          attr.value = attr.nodeValue = "" + value;
        } else {
          attr = this.ownerDocument._createAttribute(name);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        }
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      /**
       * Returns elements attribute whose namespace is `namespaceURI` and local name is
       * `localName`,
       * or `null` if there is no such attribute.
       *
       * @param {string} namespaceURI
       * @param {string} localName
       * @returns {string | null}
       */
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr ? attr.value : null;
      },
      /**
       * Sets the value of elements attribute whose namespace is `namespaceURI` and local name is
       * `localName` to value.
       *
       * @param {string} namespaceURI
       * @param {string} qualifiedName
       * @param {string} value
       * @see https://dom.spec.whatwg.org/#dom-element-setattributens
       */
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var validated = validateAndExtract(namespaceURI, qualifiedName);
        var localName = validated[2];
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        if (attr) {
          attr.value = attr.nodeValue = "" + value;
        } else {
          attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
          attr.value = attr.nodeValue = "" + value;
          this.setAttributeNode(attr);
        }
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      /**
       * Returns a LiveNodeList of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classNames` is an empty string or only contains HTML white space
       * characters.
       *
       * Warning: This returns a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames
       * Is a string representing the class name(s) to match; multiple class names are separated by
       * (ASCII-)whitespace.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      /**
       * Returns a LiveNodeList of elements with the given qualifiedName.
       * Searching for all descendants can be done by passing `*` as `qualifiedName`.
       *
       * All descendants of the specified element are searched, but not the element itself.
       * The returned list is live, which means it updates itself with the DOM tree automatically.
       * Therefore, there is no need to call `Element.getElementsByTagName()`
       * with the same element and arguments repeatedly if the DOM changes in between calls.
       *
       * When called on an HTML element in an HTML document,
       * `getElementsByTagName` lower-cases the argument before searching for it.
       * This is undesirable when trying to match camel-cased SVG elements (such as
       * `<linearGradient>`) in an HTML document.
       * Instead, use `Element.getElementsByTagNameNS()`,
       * which preserves the capitalization of the tag name.
       *
       * `Element.getElementsByTagName` is similar to `Document.getElementsByTagName()`,
       * except that it only searches for elements that are descendants of the specified element.
       *
       * @param {string} qualifiedName
       * @returns {LiveNodeList}
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbytagname
       */
      getElementsByTagName: function(qualifiedName) {
        var isHTMLDocument = (this.nodeType === DOCUMENT_NODE ? this : this.ownerDocument).type === "html";
        var lowerQualifiedName = qualifiedName.toLowerCase();
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node === base || node.nodeType !== ELEMENT_NODE) {
              return;
            }
            if (qualifiedName === "*") {
              ls.push(node);
            } else {
              var nodeQualifiedName = node.getQualifiedName();
              var matchingQName = isHTMLDocument && node.namespaceURI === NAMESPACE.HTML ? lowerQualifiedName : qualifiedName;
              if (nodeQualifiedName === matchingQName) {
                ls.push(node);
              }
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByClassName = Element.prototype.getElementsByClassName;
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr(symbol) {
      checkSymbol(symbol);
      this.namespaceURI = null;
      this.prefix = null;
      this.ownerElement = null;
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData(symbol) {
      checkSymbol(symbol);
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text(symbol) {
      checkSymbol(symbol);
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment(symbol) {
      checkSymbol(symbol);
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection(symbol) {
      checkSymbol(symbol);
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, Text);
    function DocumentType(symbol) {
      checkSymbol(symbol);
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation(symbol) {
      checkSymbol(symbol);
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity(symbol) {
      checkSymbol(symbol);
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference(symbol) {
      checkSymbol(symbol);
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment(symbol) {
      checkSymbol(symbol);
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction(symbol) {
      checkSymbol(symbol);
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, CharacterData);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, nodeFilter) {
      return nodeSerializeToString.call(node, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(nodeFilter) {
      var buf = [];
      var refNode = this.nodeType === DOCUMENT_NODE && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      var doc = node.nodeType === DOCUMENT_NODE ? node : node.ownerDocument;
      var isHTML = doc.type === "html";
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({
                prefix: attr.localName,
                namespace: attr.value
              });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          var canCloseTag = !child;
          if (canCloseTag && (isHTML || node.namespaceURI === NAMESPACE.HTML)) {
            canCloseTag = isHTMLVoidElement(nodeName);
          }
          if (canCloseTag) {
            buf.push("/>");
          } else {
            buf.push(">");
            if (isHTML && isHTMLRawTextElement(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
        case CDATA_SECTION_NODE:
          return buf.push(g.CDATA_START, node.data, g.CDATA_END);
        case COMMENT_NODE:
          return buf.push(g.COMMENT_START, node.data, g.COMMENT_END);
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push(g.DOCTYPE_DECL_START, " ", node.name);
          if (pubid) {
            buf.push(" ", g.PUBLIC, " ", pubid);
            if (sysid && sysid !== ".") {
              buf.push(" ", sysid);
            }
          } else if (sysid && sysid !== ".") {
            buf.push(" ", g.SYSTEM, " ", sysid);
          }
          if (node.internalSubset) {
            buf.push(" [", node.internalSubset, "]");
          }
          buf.push(">");
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor(PDC);
      for (var n in node) {
        if (hasOwn(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    exports2._updateLiveList = _updateLiveList;
    exports2.Attr = Attr;
    exports2.CDATASection = CDATASection;
    exports2.CharacterData = CharacterData;
    exports2.Comment = Comment;
    exports2.Document = Document;
    exports2.DocumentFragment = DocumentFragment;
    exports2.DocumentType = DocumentType;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Entity = Entity;
    exports2.EntityReference = EntityReference;
    exports2.LiveNodeList = LiveNodeList;
    exports2.NamedNodeMap = NamedNodeMap;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.Notation = Notation;
    exports2.Text = Text;
    exports2.ProcessingInstruction = ProcessingInstruction;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    var g = require_grammar();
    var errors = require_errors();
    var isHTMLEscapableRawTextElement = conventions.isHTMLEscapableRawTextElement;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isHTMLRawTextElement = conventions.isHTMLRawTextElement;
    var hasOwn = conventions.hasOwn;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = errors.ParseError;
    var DOMException = errors.DOMException;
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = /* @__PURE__ */ Object.create(null));
        parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
        domBuilder.endDocument();
      }
    };
    var ENTITY_REG = /&#?\w+;?/g;
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      var isHTML = isHTMLMimeType(domBuilder.mimeType);
      if (source.indexOf(g.UNICODE_REPLACEMENT_CHARACTER) >= 0) {
        errorHandler.warning("Unicode replacement character detected, source encoding issues?");
      }
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var complete = a2[a2.length - 1] === ";" ? a2 : a2 + ";";
        if (!isHTML && complete !== a2) {
          errorHandler.error("EntityRef: expecting ;");
          return a2;
        }
        var match = g.Reference.exec(complete);
        if (!match || match[0].length !== complete.length) {
          errorHandler.error("entity not matching Reference production: " + a2);
          return a2;
        }
        var k = complete.slice(1, -1);
        if (hasOwn(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substring(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(ENTITY_REG, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /\r\n?|\n|$/g;
      var locator = domBuilder.locator;
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = lineEnd;
          lineEnd = m.index + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var unclosedTags = [];
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!isHTML && unclosedTags.length > 0) {
              return errorHandler.fatalError("unclosed xml tag(s): " + unclosedTags.join(", "));
            }
            if (!source.substring(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substring(start));
              if (doc.documentElement) {
                return errorHandler.error("Extra content at the end of the document");
              }
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            var fromSource = source.substring(start, tagStart);
            if (!isHTML && unclosedTags.length === 0) {
              fromSource = fromSource.replace(new RegExp(g.S_OPT.source, "g"), "");
              fromSource && errorHandler.error("Unexpected content outside root element: '" + fromSource + "'");
            }
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 2);
              var tagNameRaw = source.substring(tagStart + 2, end > 0 ? end : void 0);
              if (!tagNameRaw) {
                return errorHandler.fatalError("end tag name missing");
              }
              var tagNameMatch = end > 0 && g.reg("^", g.QName_group, g.S_OPT, "$").exec(tagNameRaw);
              if (!tagNameMatch) {
                return errorHandler.fatalError('end tag name contains invalid characters: "' + tagNameRaw + '"');
              }
              if (!domBuilder.currentElement && !domBuilder.doc.documentElement) {
                return;
              }
              var currentTagName = unclosedTags[unclosedTags.length - 1] || domBuilder.currentElement.tagName || domBuilder.doc.documentElement.tagName || "";
              if (currentTagName !== tagNameMatch[1]) {
                var tagNameLower = tagNameMatch[1].toLowerCase();
                if (!isHTML || currentTagName.toLowerCase() !== tagNameLower) {
                  return errorHandler.fatalError('Opening and ending tag mismatch: "' + currentTagName + '" != "' + tagNameRaw + '"');
                }
              }
              var config = parseStack.pop();
              unclosedTags.pop();
              var localNSMap = config.localNSMap;
              domBuilder.endElement(config.uri, config.localName, currentTagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (hasOwn(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              end++;
              break;
            // end element
            case "?":
              locator && position(tagStart);
              end = parseProcessingInstruction(source, tagStart, domBuilder, errorHandler);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDoctypeCommentOrCData(source, tagStart, domBuilder, errorHandler, isHTML);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler, isHTML);
              var len = el.length;
              if (!el.closed) {
                if (isHTML && conventions.isHTMLVoidElement(el.tagName)) {
                  el.closed = true;
                } else {
                  unclosedTags.push(el.tagName);
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (isHTML && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          } else if (e instanceof DOMException) {
            throw new ParseError(e.name + ": " + e.message, domBuilder.locator, e);
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler, isHTML) {
      function addAttribute(qname, value2, startIndex) {
        if (hasOwn(el.attributeNames, qname)) {
          return errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        if (!isHTML && value2.indexOf("<") >= 0) {
          return errorHandler.fatalError("Unescaped '<' not allowed in attributes values");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(ENTITY_REG, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!isHTML) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                if (!isHTML) {
                  return errorHandler.fatalError(`AttValue: ' or " expected`);
                }
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  if (!isHTML) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = /* @__PURE__ */ Object.create(null);
            _copy(currentNSMap, currentNSMap = /* @__PURE__ */ Object.create(null));
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        if (a.prefix) {
          if (a.prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (a.prefix !== "xmlns") {
            a.uri = currentNSMap[a.prefix];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (hasOwn(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      var isEscapableRaw = isHTMLEscapableRawTextElement(tagName);
      if (isEscapableRaw || isHTMLRawTextElement(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (isEscapableRaw) {
          text = text.replace(ENTITY_REG, entityReplacer);
        }
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
      return elStartEnd + 1;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (hasOwn(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseUtils(source, start) {
      var index = start;
      function char(n) {
        n = n || 0;
        return source.charAt(index + n);
      }
      function skip(n) {
        n = n || 1;
        index += n;
      }
      function skipBlanks() {
        var blanks = 0;
        while (index < source.length) {
          var c = char();
          if (c !== " " && c !== "\n" && c !== "	" && c !== "\r") {
            return blanks;
          }
          blanks++;
          skip();
        }
        return -1;
      }
      function substringFromIndex() {
        return source.substring(index);
      }
      function substringStartsWith(text) {
        return source.substring(index, index + text.length) === text;
      }
      function substringStartsWithCaseInsensitive(text) {
        return source.substring(index, index + text.length).toUpperCase() === text.toUpperCase();
      }
      function getMatch(args) {
        var expr = g.reg("^", args);
        var match = expr.exec(substringFromIndex());
        if (match) {
          skip(match[0].length);
          return match[0];
        }
        return null;
      }
      return {
        char,
        getIndex: function() {
          return index;
        },
        getMatch,
        getSource: function() {
          return source;
        },
        skip,
        skipBlanks,
        substringFromIndex,
        substringStartsWith,
        substringStartsWithCaseInsensitive
      };
    }
    function parseDoctypeInternalSubset(p, errorHandler) {
      function parsePI(p2, errorHandler2) {
        var match = g.PI.exec(p2.substringFromIndex());
        if (!match) {
          return errorHandler2.fatalError("processing instruction is not well-formed at position " + p2.getIndex());
        }
        if (match[1].toLowerCase() === "xml") {
          return errorHandler2.fatalError(
            "xml declaration is only allowed at the start of the document, but found at position " + p2.getIndex()
          );
        }
        p2.skip(match[0].length);
        return match[0];
      }
      var source = p.getSource();
      if (p.char() === "[") {
        p.skip(1);
        var intSubsetStart = p.getIndex();
        while (p.getIndex() < source.length) {
          p.skipBlanks();
          if (p.char() === "]") {
            var internalSubset = source.substring(intSubsetStart, p.getIndex());
            p.skip(1);
            return internalSubset;
          }
          var current = null;
          if (p.char() === "<" && p.char(1) === "!") {
            switch (p.char(2)) {
              case "E":
                if (p.char(3) === "L") {
                  current = p.getMatch(g.elementdecl);
                } else if (p.char(3) === "N") {
                  current = p.getMatch(g.EntityDecl);
                }
                break;
              case "A":
                current = p.getMatch(g.AttlistDecl);
                break;
              case "N":
                current = p.getMatch(g.NotationDecl);
                break;
              case "-":
                current = p.getMatch(g.Comment);
                break;
            }
          } else if (p.char() === "<" && p.char(1) === "?") {
            current = parsePI(p, errorHandler);
          } else if (p.char() === "%") {
            current = p.getMatch(g.PEReference);
          } else {
            return errorHandler.fatalError("Error detected in Markup declaration");
          }
          if (!current) {
            return errorHandler.fatalError("Error in internal subset at position " + p.getIndex());
          }
        }
        return errorHandler.fatalError("doctype internal subset is not well-formed, missing ]");
      }
    }
    function parseDoctypeCommentOrCData(source, start, domBuilder, errorHandler, isHTML) {
      var p = parseUtils(source, start);
      switch (isHTML ? p.char(2).toUpperCase() : p.char(2)) {
        case "-":
          var comment = p.getMatch(g.Comment);
          if (comment) {
            domBuilder.comment(comment, g.COMMENT_START.length, comment.length - g.COMMENT_START.length - g.COMMENT_END.length);
            return p.getIndex();
          } else {
            return errorHandler.fatalError("comment is not well-formed at position " + p.getIndex());
          }
        case "[":
          var cdata = p.getMatch(g.CDSect);
          if (cdata) {
            if (!isHTML && !domBuilder.currentElement) {
              return errorHandler.fatalError("CDATA outside of element");
            }
            domBuilder.startCDATA();
            domBuilder.characters(cdata, g.CDATA_START.length, cdata.length - g.CDATA_START.length - g.CDATA_END.length);
            domBuilder.endCDATA();
            return p.getIndex();
          } else {
            return errorHandler.fatalError("Invalid CDATA starting at position " + start);
          }
        case "D": {
          if (domBuilder.doc && domBuilder.doc.documentElement) {
            return errorHandler.fatalError("Doctype not allowed inside or after documentElement at position " + p.getIndex());
          }
          if (isHTML ? !p.substringStartsWithCaseInsensitive(g.DOCTYPE_DECL_START) : !p.substringStartsWith(g.DOCTYPE_DECL_START)) {
            return errorHandler.fatalError("Expected " + g.DOCTYPE_DECL_START + " at position " + p.getIndex());
          }
          p.skip(g.DOCTYPE_DECL_START.length);
          if (p.skipBlanks() < 1) {
            return errorHandler.fatalError("Expected whitespace after " + g.DOCTYPE_DECL_START + " at position " + p.getIndex());
          }
          var doctype = {
            name: void 0,
            publicId: void 0,
            systemId: void 0,
            internalSubset: void 0
          };
          doctype.name = p.getMatch(g.Name);
          if (!doctype.name)
            return errorHandler.fatalError("doctype name missing or contains unexpected characters at position " + p.getIndex());
          if (isHTML && doctype.name.toLowerCase() !== "html") {
            errorHandler.warning("Unexpected DOCTYPE in HTML document at position " + p.getIndex());
          }
          p.skipBlanks();
          if (p.substringStartsWith(g.PUBLIC) || p.substringStartsWith(g.SYSTEM)) {
            var match = g.ExternalID_match.exec(p.substringFromIndex());
            if (!match) {
              return errorHandler.fatalError("doctype external id is not well-formed at position " + p.getIndex());
            }
            if (match.groups.SystemLiteralOnly !== void 0) {
              doctype.systemId = match.groups.SystemLiteralOnly;
            } else {
              doctype.systemId = match.groups.SystemLiteral;
              doctype.publicId = match.groups.PubidLiteral;
            }
            p.skip(match[0].length);
          } else if (isHTML && p.substringStartsWithCaseInsensitive(g.SYSTEM)) {
            p.skip(g.SYSTEM.length);
            if (p.skipBlanks() < 1) {
              return errorHandler.fatalError("Expected whitespace after " + g.SYSTEM + " at position " + p.getIndex());
            }
            doctype.systemId = p.getMatch(g.ABOUT_LEGACY_COMPAT_SystemLiteral);
            if (!doctype.systemId) {
              return errorHandler.fatalError(
                "Expected " + g.ABOUT_LEGACY_COMPAT + " in single or double quotes after " + g.SYSTEM + " at position " + p.getIndex()
              );
            }
          }
          if (isHTML && doctype.systemId && !g.ABOUT_LEGACY_COMPAT_SystemLiteral.test(doctype.systemId)) {
            errorHandler.warning("Unexpected doctype.systemId in HTML document at position " + p.getIndex());
          }
          if (!isHTML) {
            p.skipBlanks();
            doctype.internalSubset = parseDoctypeInternalSubset(p, errorHandler);
          }
          p.skipBlanks();
          if (p.char() !== ">") {
            return errorHandler.fatalError("doctype not terminated with > at position " + p.getIndex());
          }
          p.skip(1);
          domBuilder.startDTD(doctype.name, doctype.publicId, doctype.systemId, doctype.internalSubset);
          domBuilder.endDTD();
          return p.getIndex();
        }
        default:
          return errorHandler.fatalError('Not well-formed XML starting with "<!" at position ' + start);
      }
    }
    function parseProcessingInstruction(source, start, domBuilder, errorHandler) {
      var match = source.substring(start).match(g.PI);
      if (!match) {
        return errorHandler.fatalError("Invalid processing instruction starting at position " + start);
      }
      if (match[1].toLowerCase() === "xml") {
        if (start > 0) {
          return errorHandler.fatalError(
            "processing instruction at position " + start + " is an xml declaration which is only at the start of the document"
          );
        }
        if (!g.XMLDecl.test(source.substring(start))) {
          return errorHandler.fatalError("xml declaration is not well-formed");
        }
      }
      domBuilder.processingInstruction(match[1], match[2]);
      return start + match[0].length;
    }
    function ElementAttributes() {
      this.attributeNames = /* @__PURE__ */ Object.create(null);
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!g.QName_exact.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!g.QName_exact.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    exports2.XMLReader = XMLReader;
    exports2.parseUtils = parseUtils;
    exports2.parseDoctypeCommentOrCData = parseDoctypeCommentOrCData;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    var dom = require_dom();
    var errors = require_errors();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    var isHTMLMimeType = conventions.isHTMLMimeType;
    var isValidMimeType = conventions.isValidMimeType;
    var MIME_TYPE = conventions.MIME_TYPE;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = errors.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028\u2029]/g, "\n");
    }
    function DOMParser(options) {
      options = options || {};
      if (options.locator === void 0) {
        options.locator = true;
      }
      this.assign = options.assign || conventions.assign;
      this.domHandler = options.domHandler || DOMHandler;
      this.onError = options.onError || options.errorHandler;
      if (options.errorHandler && typeof options.errorHandler !== "function") {
        throw new TypeError("errorHandler object is no longer supported, switch to onError!");
      } else if (options.errorHandler) {
        options.errorHandler("warning", "The `errorHandler` option has been deprecated, use `onError` instead!", this);
      }
      this.normalizeLineEndings = options.normalizeLineEndings || normalizeLineEndings;
      this.locator = !!options.locator;
      this.xmlns = this.assign(/* @__PURE__ */ Object.create(null), options.xmlns);
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      if (!isValidMimeType(mimeType)) {
        throw new TypeError('DOMParser.parseFromString: the provided mimeType "' + mimeType + '" is not valid.');
      }
      var defaultNSMap = this.assign(/* @__PURE__ */ Object.create(null), this.xmlns);
      var entityMap = entities.XML_ENTITIES;
      var defaultNamespace = defaultNSMap[""] || null;
      if (hasDefaultHTMLNamespace(mimeType)) {
        entityMap = entities.HTML_ENTITIES;
        defaultNamespace = NAMESPACE.HTML;
      } else if (mimeType === MIME_TYPE.XML_SVG_IMAGE) {
        defaultNamespace = NAMESPACE.SVG;
      }
      defaultNSMap[""] = defaultNamespace;
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var domBuilder = new this.domHandler({
        mimeType,
        defaultNamespace,
        onError: this.onError
      });
      var locator = this.locator ? {} : void 0;
      if (this.locator) {
        domBuilder.setDocumentLocator(locator);
      }
      var sax2 = new XMLReader();
      sax2.errorHandler = domBuilder;
      sax2.domBuilder = domBuilder;
      var isXml = !conventions.isHTMLMimeType(mimeType);
      if (isXml && typeof source !== "string") {
        sax2.errorHandler.fatalError("source is not a string");
      }
      sax2.parse(this.normalizeLineEndings(String(source)), defaultNSMap, entityMap);
      if (!domBuilder.doc.documentElement) {
        sax2.errorHandler.fatalError("missing root element");
      }
      return domBuilder.doc;
    };
    function DOMHandler(options) {
      var opt = options || {};
      this.mimeType = opt.mimeType || MIME_TYPE.XML_APPLICATION;
      this.defaultNamespace = opt.defaultNamespace || null;
      this.cdata = false;
      this.currentElement = void 0;
      this.doc = void 0;
      this.locator = void 0;
      this.onError = opt.onError;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      /**
       * Either creates an XML or an HTML document and stores it under `this.doc`.
       * If it is an XML document, `this.defaultNamespace` is used to create it,
       * and it will not contain any `childNodes`.
       * If it is an HTML document, it will be created without any `childNodes`.
       *
       * @see http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
       */
      startDocument: function() {
        var impl = new DOMImplementation();
        this.doc = isHTMLMimeType(this.mimeType) ? impl.createHTMLDocument(false) : impl.createDocument(this.defaultNamespace, "");
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        this.currentElement = this.currentElement.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      /**
       * Stores the locator to be able to set the `columnNumber` and `lineNumber`
       * on the created DOM nodes.
       *
       * @param {Locator} locator
       */
      setDocumentLocator: function(locator) {
        if (locator) {
          locator.lineNumber = 0;
        }
        this.locator = locator;
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId, internalSubset) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId, internalSubset);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      reportError: function(level, message) {
        if (typeof this.onError === "function") {
          try {
            this.onError(level, message, this);
          } catch (e) {
            throw new ParseError("Reporting " + level + ' "' + message + '" caused ' + e, this.locator);
          }
        } else {
          console.error("[xmldom " + level + "]	" + message, _locator(this.locator));
        }
      },
      /**
       * @see http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(message) {
        this.reportError("warning", message);
      },
      error: function(message) {
        this.reportError("error", message);
      },
      /**
       * This function reports a fatal error and throws a ParseError.
       *
       * @param {string} message
       * - The message to be used for reporting and throwing the error.
       * @returns {never}
       * This function always throws an error and never returns a value.
       * @throws {ParseError}
       * Always throws a ParseError with the provided message.
       */
      fatalError: function(message) {
        this.reportError("fatalError", message);
        throw new ParseError(message, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(
      /\w+/g,
      function(key) {
        DOMHandler.prototype[key] = function() {
          return null;
        };
      }
    );
    function appendElement(handler, node) {
      if (!handler.currentElement) {
        handler.doc.appendChild(node);
      } else {
        handler.currentElement.appendChild(node);
      }
    }
    function onErrorStopParsing(level) {
      if (level === "error") throw "onErrorStopParsing";
    }
    function onWarningStopParsing() {
      throw "onWarningStopParsing";
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.DOMParser = DOMParser;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.onErrorStopParsing = onErrorStopParsing;
    exports2.onWarningStopParsing = onWarningStopParsing;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    "use strict";
    var conventions = require_conventions();
    exports2.assign = conventions.assign;
    exports2.hasDefaultHTMLNamespace = conventions.hasDefaultHTMLNamespace;
    exports2.isHTMLMimeType = conventions.isHTMLMimeType;
    exports2.isValidMimeType = conventions.isValidMimeType;
    exports2.MIME_TYPE = conventions.MIME_TYPE;
    exports2.NAMESPACE = conventions.NAMESPACE;
    var errors = require_errors();
    exports2.DOMException = errors.DOMException;
    exports2.DOMExceptionName = errors.DOMExceptionName;
    exports2.ExceptionCode = errors.ExceptionCode;
    exports2.ParseError = errors.ParseError;
    var dom = require_dom();
    exports2.Attr = dom.Attr;
    exports2.CDATASection = dom.CDATASection;
    exports2.CharacterData = dom.CharacterData;
    exports2.Comment = dom.Comment;
    exports2.Document = dom.Document;
    exports2.DocumentFragment = dom.DocumentFragment;
    exports2.DocumentType = dom.DocumentType;
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.Element = dom.Element;
    exports2.Entity = dom.Entity;
    exports2.EntityReference = dom.EntityReference;
    exports2.LiveNodeList = dom.LiveNodeList;
    exports2.NamedNodeMap = dom.NamedNodeMap;
    exports2.Node = dom.Node;
    exports2.NodeList = dom.NodeList;
    exports2.Notation = dom.Notation;
    exports2.ProcessingInstruction = dom.ProcessingInstruction;
    exports2.Text = dom.Text;
    exports2.XMLSerializer = dom.XMLSerializer;
    var domParser = require_dom_parser();
    exports2.DOMParser = domParser.DOMParser;
    exports2.normalizeLineEndings = domParser.normalizeLineEndings;
    exports2.onErrorStopParsing = domParser.onErrorStopParsing;
    exports2.onWarningStopParsing = domParser.onWarningStopParsing;
  }
});

// node_modules/pptx-automizer/dist/constants/constants.js
var require_constants = __commonJS({
  "node_modules/pptx-automizer/dist/constants/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentTrack = exports2.hyperlinksTrack = exports2.imagesTrack = exports2.TargetByRelIdMap = void 0;
    exports2.TargetByRelIdMap = {
      chart: {
        relRootTag: "c:chart",
        relAttribute: "r:id",
        prefix: "../charts/chart"
      },
      chartEx: {
        relRootTag: "cx:chart",
        relAttribute: "r:id",
        prefix: "../charts/chartEx"
      },
      image: {
        relRootTag: "a:blip",
        relAttribute: "r:embed",
        prefix: "../media/image"
      },
      "image:svg": {
        relRootTag: "asvg:svgBlip",
        relAttribute: "r:embed",
        prefix: "../media/image"
      },
      hyperlink: {
        relRootTag: "a:hlinkClick",
        relAttribute: "r:id",
        prefix: "",
        findAll: true
      },
      oleObject: {
        relRootTag: "p:oleObj",
        relAttribute: "r:id",
        prefix: "../embeddings/oleObject"
      }
    };
    var imagesTrack = () => [
      {
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
        tag: "a:blip",
        role: "image",
        attribute: "r:embed"
      },
      {
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
        tag: "asvg:svgBlip",
        role: "image",
        attribute: "r:embed"
      }
    ];
    exports2.imagesTrack = imagesTrack;
    var hyperlinksTrack = () => [
      {
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
        tag: "a:hlinkClick",
        role: "hyperlink",
        attribute: "r:id"
      }
    ];
    exports2.hyperlinksTrack = hyperlinksTrack;
    var contentTrack = () => {
      return [
        {
          source: "ppt/presentation.xml",
          relationsKey: "ppt/_rels/presentation.xml.rels",
          tags: [
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster",
              tag: "p:sldMasterId",
              role: "slideMaster"
            },
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide",
              tag: "p:sldId",
              role: "slide"
            }
          ]
        },
        {
          source: "ppt/slides",
          relationsKey: "ppt/slides/_rels",
          isDir: true,
          tags: [
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
              tag: "c:chart",
              role: "chart"
            },
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout",
              role: "slideLayout",
              tag: null
            },
            ...(0, exports2.imagesTrack)(),
            ...(0, exports2.hyperlinksTrack)()
          ]
        },
        {
          source: "ppt/charts",
          relationsKey: "ppt/charts/_rels",
          isDir: true,
          tags: [
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/package",
              tag: "c:externalData",
              role: "externalData"
            }
          ]
        },
        {
          source: "ppt/slideMasters",
          relationsKey: "ppt/slideMasters/_rels",
          isDir: true,
          tags: [
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout",
              tag: "p:sldLayoutId",
              role: "slideLayout"
            },
            ...(0, exports2.imagesTrack)(),
            ...(0, exports2.hyperlinksTrack)()
          ]
        },
        {
          source: "ppt/slideLayouts",
          relationsKey: "ppt/slideLayouts/_rels",
          isDir: true,
          tags: [
            {
              type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster",
              role: "slideMaster",
              tag: null
            },
            ...(0, exports2.imagesTrack)(),
            ...(0, exports2.hyperlinksTrack)()
          ]
        }
      ];
    };
    exports2.contentTrack = contentTrack;
  }
});

// node_modules/pptx-automizer/dist/helper/xml-pretty-print.js
var require_xml_pretty_print = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-pretty-print.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XmlPrettyPrint = void 0;
    var XmlPrettyPrint = class {
      constructor(xmlStr) {
        this.xmlStr = xmlStr;
        this.TAB = "  ";
      }
      dump() {
        console.log(this.prettify());
      }
      prettify() {
        return this.parse(this.xmlStr).join("\n");
      }
      parse(xmlStr) {
        const opener = /<(\w+)[^>]*?>/m;
        const closer = /<\/[^>]*>/m;
        let idx = 0;
        let indent = 0;
        let processing = "";
        const tags = [];
        const output = [];
        while (idx < xmlStr.length) {
          processing += xmlStr[idx];
          const openToken = this.getToken(opener, processing);
          const closeToken = this.getToken(closer, processing);
          if (openToken) {
            if (processing[processing.length - 2] != "/") {
              this.addLine(output, openToken.preContent, indent);
              this.addLine(output, openToken.match, indent);
              tags.push(openToken.tag);
              indent += 1;
              processing = "";
            } else {
              this.addLine(output, openToken.preContent, indent);
              this.addLine(output, openToken.match, indent);
              processing = "";
            }
          } else if (closeToken) {
            this.addLine(output, closeToken.preContent, indent);
            if (tags[tags.length] == closeToken.tag) {
              tags.pop();
              indent -= 1;
            }
            this.addLine(output, closeToken.match, indent);
            processing = "";
          }
          idx += 1;
        }
        if (tags.length) {
          console.log("WARNING: xmlFile may be malformed. Not all opening tags were closed. Following tags were left open:");
          console.log(tags);
        }
        return output;
      }
      getToken(regex, str) {
        if (regex.test(str)) {
          const matches = regex.exec(str);
          const match = matches[0];
          const offset = str.length - match.length;
          const preContent = str.substring(0, offset);
          return {
            match,
            tag: matches[1],
            offset,
            preContent
          };
        }
      }
      addLine(output, content, indent) {
        content = content.replace(/^\s+|\s+$/, "");
        if (content) {
          let tabs = "";
          while (indent--) {
            tabs += this.TAB;
          }
          output.push(tabs + content);
        }
      }
    };
    exports2.XmlPrettyPrint = XmlPrettyPrint;
  }
});

// node_modules/pptx-automizer/dist/helper/general-helper.js
var require_general_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/general-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logDebug = exports2.log = exports2.Logger = exports2.last = exports2.vd = exports2.GeneralHelper = void 0;
    var GeneralHelper = class {
      static arrayify(input) {
        if (Array.isArray(input)) {
          return input;
        } else if (input !== void 0) {
          return [input];
        } else {
          return [];
        }
      }
      static propertyExists(object, property) {
        if (!object || typeof object !== "object")
          return false;
        return !!Object.getOwnPropertyDescriptor(object, property);
      }
    };
    exports2.GeneralHelper = GeneralHelper;
    var vd = (v, keys) => {
      if (keys && typeof v === "object") {
        v = Object.keys(v);
      }
      console.log("--------- [pptx-automizer] ---------");
      console.log(new Error().stack.split("\n")[2].trim());
      console.dir(v, { depth: 10 });
    };
    exports2.vd = vd;
    var last = (arr) => arr[arr.length - 1];
    exports2.last = last;
    exports2.Logger = {
      verbosity: 1,
      target: "console",
      log: (message, verbosity, showStack, target) => {
        if (verbosity > exports2.Logger.verbosity) {
          return;
        }
        target = target || exports2.Logger.target;
        if (target === "console") {
          if (showStack) {
            (0, exports2.vd)(message);
          } else {
            console.log(message);
          }
        } else {
        }
      }
    };
    var log = (message, verbosity) => {
      exports2.Logger.log(message, verbosity);
    };
    exports2.log = log;
    var logDebug = (message, verbosity) => {
      exports2.Logger.log(message, verbosity, true);
    };
    exports2.logDebug = logDebug;
  }
});

// node_modules/pptx-automizer/dist/enums/content-type-map.js
var require_content_type_map = __commonJS({
  "node_modules/pptx-automizer/dist/enums/content-type-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContentTypeMap = void 0;
    var ContentTypeMap;
    (function(ContentTypeMap2) {
      ContentTypeMap2["jpg"] = "image/jpeg";
      ContentTypeMap2["jpeg"] = "image/jpeg";
      ContentTypeMap2["png"] = "image/png";
      ContentTypeMap2["gif"] = "image/gif";
      ContentTypeMap2["svg"] = "image/svg+xml";
      ContentTypeMap2["m4v"] = "video/mp4";
      ContentTypeMap2["mp4"] = "video/mp4";
      ContentTypeMap2["emf"] = "image/x-emf";
      ContentTypeMap2["wdp"] = "image/vnd.ms-photo";
      ContentTypeMap2["xml"] = "application/xml";
      ContentTypeMap2["bin"] = "application/vnd.openxmlformats-officedocument.oleObject";
      ContentTypeMap2["vml"] = "application/vnd.openxmlformats-officedocument.vmlDrawing";
    })(ContentTypeMap = exports2.ContentTypeMap || (exports2.ContentTypeMap = {}));
  }
});

// node_modules/pptx-automizer/dist/helper/xml-helper.js
var require_xml_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XmlHelper = void 0;
    var xmldom_1 = require_lib();
    var constants_1 = require_constants();
    var xml_pretty_print_1 = require_xml_pretty_print();
    var general_helper_1 = require_general_helper();
    var content_tracker_1 = require_content_tracker();
    var content_type_map_1 = require_content_type_map();
    var XmlHelper = class _XmlHelper {
      static modifyXmlInArchive(archive, file, callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
          const fileProxy = yield archive;
          const xml = yield _XmlHelper.getXmlFromArchive(fileProxy, file);
          let i = 0;
          for (const callback of callbacks) {
            yield callback(xml, i++, fileProxy);
          }
          _XmlHelper.writeXmlToArchive(yield archive, file, xml);
        });
      }
      static getXmlFromArchive(archive, file) {
        return __awaiter(this, void 0, void 0, function* () {
          return archive.readXml(file);
        });
      }
      static writeXmlToArchive(archive, file, xml) {
        archive.writeXml(file, xml);
      }
      static appendIf(element) {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield _XmlHelper.getXmlFromArchive(element.archive, element.file);
          return element.clause !== void 0 && !element.clause(xml) ? false : _XmlHelper.append(element);
        });
      }
      static append(element) {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield _XmlHelper.getXmlFromArchive(element.archive, element.file);
          const newElement = xml.createElement(element.tag);
          for (const attribute in element.attributes) {
            const value = element.attributes[attribute];
            const setValue = typeof value === "function" ? value(xml) : value;
            newElement.setAttribute(attribute, setValue);
          }
          content_tracker_1.contentTracker.trackRelation(element.file, element.attributes);
          if (element.assert) {
            element.assert(xml);
          }
          const parent = element.parent(xml);
          parent.appendChild(newElement);
          _XmlHelper.writeXmlToArchive(element.archive, element.file, xml);
          return newElement;
        });
      }
      static removeIf(element) {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield _XmlHelper.getXmlFromArchive(element.archive, element.file);
          const collection = xml.getElementsByTagName(element.tag);
          const toRemove = [];
          _XmlHelper.modifyCollection(collection, (item, index) => {
            if (element.clause(xml, item)) {
              toRemove.push(item);
            }
          });
          toRemove.forEach((item) => {
            _XmlHelper.remove(item);
          });
          _XmlHelper.writeXmlToArchive(element.archive, element.file, xml);
          return toRemove;
        });
      }
      static getNextRelId(rootArchive, file) {
        return __awaiter(this, void 0, void 0, function* () {
          const presentationRelsXml = yield _XmlHelper.getXmlFromArchive(rootArchive, file);
          const increment = (max) => "rId" + max;
          const relationNodes = presentationRelsXml.documentElement.childNodes;
          const rid = _XmlHelper.getMaxId(relationNodes, "Id", true);
          return increment(rid) + "-created";
        });
      }
      static getMaxId(rels, attribute, increment, minId) {
        let max = 0;
        for (const i in rels) {
          const rel = rels[i];
          if (rel.getAttribute !== void 0) {
            const id = Number(rel.getAttribute(attribute).replace("rId", "").replace("-created", ""));
            max = id > max ? id : max;
          }
        }
        switch (typeof increment) {
          case "boolean":
            ++max;
            break;
        }
        if (max < minId) {
          return minId;
        }
        return max;
      }
      static getRelationshipTargetsByPrefix(archive, path2, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
          const prefixes = typeof prefix === "string" ? [prefix] : prefix;
          return _XmlHelper.getRelationshipItems(archive, path2, (element, targets) => {
            prefixes.forEach((prefix2) => {
              const target = _XmlHelper.parseRelationTarget(element, prefix2);
              if (target.prefix) {
                targets.push(target);
              }
            });
          });
        });
      }
      static parseRelationTarget(element, prefix) {
        const type = element.getAttribute("Type");
        const file = element.getAttribute("Target");
        const last = (arr) => arr[arr.length - 1];
        const filename = last(file.split("/"));
        const subtype = last(prefix.split("/"));
        const relType = last(type.split("/"));
        const rId = element.getAttribute("Id");
        const filenameExt = last(filename.split("."));
        const filenameMatch = filename.replace("." + filenameExt, "").match(/^(.+?)(\d+)*$/);
        const filenameBase = filenameMatch && filenameMatch[1] ? filenameMatch[1] : filename;
        const number = filenameMatch && filenameMatch[2] ? Number(filenameMatch[2]) : 0;
        const target = {
          rId,
          type,
          file,
          filename,
          filenameBase,
          number,
          subtype,
          relType,
          element
        };
        if (prefix && _XmlHelper.targetMatchesRelationship(relType, subtype, file, prefix)) {
          return Object.assign(Object.assign({}, target), { prefix });
        }
        if (prefix && prefix.indexOf("../") === 0) {
          return _XmlHelper.parseRelationTarget(element, prefix.replace("../", "/ppt/"));
        }
        return target;
      }
      static targetMatchesRelationship(relType, subtype, file, prefix) {
        if (relType === "package")
          return true;
        if (file.indexOf("/ppt/") === 0) {
          file = file.replace("/ppt/", "../");
        }
        return relType === subtype && file.indexOf(prefix) === 0;
      }
      static getTargetsByRelationshipType(archive, path2, type) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield _XmlHelper.getRelationshipItems(archive, path2, (element, rels) => {
            const target = element.getAttribute("Type");
            if (target === type) {
              rels.push({
                file: element.getAttribute("Target"),
                rId: element.getAttribute("Id"),
                element
              });
            }
          });
        });
      }
      static getRelationshipItems(archive, path2, cb, tag) {
        return __awaiter(this, void 0, void 0, function* () {
          tag = tag || "Relationship";
          const xml = yield _XmlHelper.getXmlFromArchive(archive, path2);
          const relationshipItems = xml.getElementsByTagName(tag);
          const rels = [];
          for (const i in relationshipItems) {
            if (relationshipItems[i].getAttribute) {
              cb(relationshipItems[i], rels);
            }
          }
          return rels;
        });
      }
      static findByAttribute(xml, tagName, attributeName, attributeValue) {
        const elements = xml.getElementsByTagName(tagName);
        for (const i in elements) {
          const element = elements[i];
          if (element.getAttribute !== void 0) {
            if (element.getAttribute(attributeName) === attributeValue) {
              return true;
            }
          }
        }
        return false;
      }
      static replaceAttribute(archive, path2, tagName, attributeName, attributeValue, replaceValue, replaceAttributeName) {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield _XmlHelper.getXmlFromArchive(archive, path2);
          const elements = xml.getElementsByTagName(tagName);
          for (const i in elements) {
            const element = elements[i];
            if (element.getAttribute !== void 0 && element.getAttribute(attributeName) === attributeValue) {
              element.setAttribute(replaceAttributeName || attributeName, replaceValue);
            }
            if (element.getAttribute !== void 0) {
              content_tracker_1.contentTracker.trackRelation(path2, {
                Id: element.getAttribute("Id"),
                Target: element.getAttribute("Target"),
                Type: element.getAttribute("Type")
              });
            }
          }
          _XmlHelper.writeXmlToArchive(archive, path2, xml);
        });
      }
      static getTargetByRelId(archive, relsPath, element, type) {
        return __awaiter(this, void 0, void 0, function* () {
          const params = constants_1.TargetByRelIdMap[type];
          if (params.findAll) {
            const hyperlinks = element.getElementsByTagName(params.relRootTag);
            if (hyperlinks.length > 0) {
              const sourceRid = hyperlinks[0].getAttribute(params.relAttribute);
              const allRels = yield _XmlHelper.getRelationshipItems(archive, relsPath, (element2, rels) => {
                rels.push({
                  rId: element2.getAttribute("Id"),
                  type: element2.getAttribute("Type"),
                  file: element2.getAttribute("Target"),
                  filename: element2.getAttribute("Target"),
                  element: element2,
                  isExternal: element2.getAttribute("TargetMode") === "External"
                });
              });
              const target = allRels.find((rel) => rel.rId === sourceRid);
              return target;
            }
          } else {
            const sourceRid = element.getElementsByTagName(params.relRootTag)[0].getAttribute(params.relAttribute);
            const shapeRels = yield _XmlHelper.getRelationshipTargetsByPrefix(archive, relsPath, params.prefix);
            const target = shapeRels.find((rel) => rel.rId === sourceRid);
            return target;
          }
        });
      }
      // Determine whether a given string is a creationId or a shape name
      // Example creationId: '{EFC74B4C-D832-409B-9CF4-73C1EFF132D8}'
      static isElementCreationId(selector) {
        return selector.indexOf("{") === 0 && selector.split("-").length === 5;
      }
      static findByElementCreationId(archive, path2, creationId) {
        return __awaiter(this, void 0, void 0, function* () {
          const slideXml = yield _XmlHelper.getXmlFromArchive(archive, path2);
          return _XmlHelper.findByCreationId(slideXml, creationId);
        });
      }
      static findByElementName(archive, path2, name) {
        return __awaiter(this, void 0, void 0, function* () {
          const slideXml = yield _XmlHelper.getXmlFromArchive(archive, path2);
          return _XmlHelper.findByName(slideXml, name);
        });
      }
      static findByName(doc, name) {
        const names = doc.getElementsByTagName("p:cNvPr");
        for (const i in names) {
          if (names[i].getAttribute && names[i].getAttribute("name") === name) {
            return names[i].parentNode.parentNode;
          }
        }
        return null;
      }
      static findByCreationId(doc, creationId) {
        const creationIds = doc.getElementsByTagName("a16:creationId");
        for (const i in creationIds) {
          if (creationIds[i].getAttribute && creationIds[i].getAttribute("id") === creationId) {
            return creationIds[i].parentNode.parentNode.parentNode.parentNode.parentNode;
          }
        }
        return null;
      }
      static findFirstByAttributeValue(nodes, attributeName, attributeValue) {
        for (const i in nodes) {
          const node = nodes[i];
          if (node.getAttribute && node.getAttribute(attributeName) === attributeValue) {
            return node;
          }
        }
        return null;
      }
      static findByAttributeValue(nodes, attributeName, attributeValue) {
        const matchingNodes = [];
        for (const i in nodes) {
          const node = nodes[i];
          if (node.getAttribute && node.getAttribute(attributeName) === attributeValue) {
            matchingNodes.push(node);
          }
        }
        return matchingNodes;
      }
      static createContentTypeChild(archive, attributes) {
        return {
          archive,
          file: `[Content_Types].xml`,
          parent: (xml) => xml.getElementsByTagName("Types")[0],
          tag: "Override",
          attributes
        };
      }
      static createRelationshipChild(archive, targetRelFile, attributes) {
        content_tracker_1.contentTracker.trackRelation(targetRelFile, attributes);
        return {
          archive,
          file: targetRelFile,
          parent: (xml) => xml.getElementsByTagName("Relationships")[0],
          tag: "Relationship",
          attributes
        };
      }
      static appendImageExtensionToContentType(targetArchive, extension) {
        const contentType = content_type_map_1.ContentTypeMap[extension] ? content_type_map_1.ContentTypeMap[extension] : "image/" + extension;
        return _XmlHelper.appendIf(Object.assign(Object.assign({}, _XmlHelper.createContentTypeChild(targetArchive, {
          Extension: extension,
          ContentType: contentType
        })), { tag: "Default", clause: (xml) => !_XmlHelper.findByAttribute(xml, "Default", "Extension", extension) }));
      }
      static appendSharedString(sharedStrings, stringValue) {
        const strings = sharedStrings.getElementsByTagName("sst")[0];
        const newLabel = sharedStrings.createTextNode(stringValue);
        const newText = sharedStrings.createElement("t");
        newText.appendChild(newLabel);
        const newString = sharedStrings.createElement("si");
        newString.appendChild(newText);
        strings.appendChild(newString);
        return strings.getElementsByTagName("si").length - 1;
      }
      static insertAfter(newNode, referenceNode) {
        return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
      }
      static sliceCollection(collection, length, from) {
        if (from !== void 0) {
          for (let i = from; i < length; i++) {
            _XmlHelper.remove(collection[i]);
          }
        } else {
          for (let i = collection.length; i > length; i--) {
            _XmlHelper.remove(collection[i - 1]);
          }
        }
      }
      static getClosestParent(tag, element) {
        if (element.parentNode) {
          if (element.parentNode.nodeName === tag) {
            return element.parentNode;
          }
          return _XmlHelper.getClosestParent(tag, element.parentNode);
        }
      }
      static remove(toRemove) {
        if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.parentNode) {
          toRemove.parentNode.removeChild(toRemove);
        }
      }
      static moveChild(childToMove, insertBefore) {
        const parent = childToMove.parentNode;
        parent.insertBefore(childToMove, insertBefore);
      }
      static appendClone(childToClone, parent) {
        const clone = childToClone.cloneNode(true);
        parent.appendChild(clone);
        return clone;
      }
      static sortCollection(collection, order, callback) {
        if (collection.length === 0) {
          return;
        }
        const parent = collection[0].parentNode;
        order.forEach((index, i) => {
          if (!collection[index]) {
            (0, general_helper_1.log)("sortCollection index not found" + index, 1);
            return;
          }
          const item = collection[index];
          if (callback) {
            callback(item, i);
          }
          parent.appendChild(item);
        });
      }
      static modifyCollection(collection, callback) {
        for (let i = 0; i < collection.length; i++) {
          const item = collection[i];
          callback(item, i);
        }
      }
      static modifyCollectionAsync(collection, callback) {
        return __awaiter(this, void 0, void 0, function* () {
          for (let i = 0; i < collection.length; i++) {
            const item = collection[i];
            yield callback(item, i);
          }
        });
      }
      static dump(element) {
        const s = new xmldom_1.XMLSerializer();
        const xmlBuffer = s.serializeToString(element);
        const p = new xml_pretty_print_1.XmlPrettyPrint(xmlBuffer);
        p.dump();
      }
    };
    exports2.XmlHelper = XmlHelper;
  }
});

// node_modules/pptx-automizer/dist/helper/content-tracker.js
var require_content_tracker = __commonJS({
  "node_modules/pptx-automizer/dist/helper/content-tracker.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentTracker = exports2.ContentTracker = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var constants_1 = require_constants();
    var ContentTracker = class {
      constructor() {
        this.files = {
          "ppt/slideMasters": [],
          "ppt/slideLayouts": [],
          "ppt/slides": [],
          "ppt/charts": [],
          "ppt/embeddings": []
        };
        this.relations = {
          // '.': [],
          "ppt/slides/_rels": [],
          "ppt/slideMasters/_rels": [],
          "ppt/slideLayouts/_rels": [],
          "ppt/charts/_rels": [],
          "ppt/_rels": [],
          ppt: []
        };
        this.relationTags = (0, constants_1.contentTrack)();
      }
      reset() {
        ["files", "relations"].forEach((section) => Object.keys(this[section]).forEach((key) => {
          this[section][key] = [];
        }));
        this.relationTags = (0, constants_1.contentTrack)();
      }
      trackFile(file) {
        const info = file_helper_1.FileHelper.getFileInfo(file);
        if (this.files[info.dir]) {
          this.files[info.dir].push(info.base);
        }
      }
      trackRelation(file, attributes) {
        const info = file_helper_1.FileHelper.getFileInfo(file);
        if (this.relations[info.dir]) {
          this.relations[info.dir].push({
            base: info.base,
            attributes
          });
        }
      }
      analyzeContents(archive) {
        return __awaiter(this, void 0, void 0, function* () {
          this.setArchive(archive);
          yield this.analyzeRelationships();
          yield this.trackSlideMasters();
          yield this.trackSlideLayouts();
        });
      }
      setArchive(archive) {
        this.archive = archive;
      }
      /**
       * This will be replaced by future slideMaster handling.
       */
      trackSlideMasters() {
        return __awaiter(this, void 0, void 0, function* () {
          const slideMasters = this.getRelationTag("ppt/presentation.xml").getTrackedRelations("slideMaster");
          yield this.addAndAnalyze(slideMasters, "ppt/slideMasters");
        });
      }
      trackSlideLayouts() {
        return __awaiter(this, void 0, void 0, function* () {
          const usedSlideLayouts = this.getRelationTag("ppt/slideMasters").getTrackedRelations("slideLayout");
          yield this.addAndAnalyze(usedSlideLayouts, "ppt/slideLayouts");
        });
      }
      addAndAnalyze(trackedRelations, section) {
        return __awaiter(this, void 0, void 0, function* () {
          const targets = yield this.getRelatedContents(trackedRelations);
          targets.forEach((target) => {
            this.trackFile(section + "/" + target.filename);
          });
          const relationTagInfo = this.getRelationTag(section);
          yield this.analyzeRelationship(relationTagInfo);
        });
      }
      getRelatedContents(trackedRelations) {
        return __awaiter(this, void 0, void 0, function* () {
          const relatedContents = [];
          for (const trackedRelation of trackedRelations) {
            for (const target of trackedRelation.targets) {
              const trackedRelationInfo = yield target.getRelatedContent();
              relatedContents.push(trackedRelationInfo);
            }
          }
          return relatedContents;
        });
      }
      getRelationTag(source) {
        return exports2.contentTracker.relationTags.find((relationTag) => relationTag.source === source);
      }
      analyzeRelationships() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const relationTagInfo of this.relationTags) {
            yield this.analyzeRelationship(relationTagInfo);
          }
        });
      }
      analyzeRelationship(relationTagInfo) {
        return __awaiter(this, void 0, void 0, function* () {
          relationTagInfo.getTrackedRelations = (role) => {
            return relationTagInfo.tags.filter((tag) => tag.role === role);
          };
          for (const relationTag of relationTagInfo.tags) {
            relationTag.targets = relationTag.targets || [];
            if (relationTagInfo.isDir === true) {
              const files = this.files[relationTagInfo.source] || [];
              if (!files.length) {
              }
              for (const file of files) {
                yield this.pushRelationTagTargets(relationTagInfo.source + "/" + file, file, relationTag, relationTagInfo);
              }
            } else {
              const pathInfo = file_helper_1.FileHelper.getFileInfo(relationTagInfo.source);
              yield this.pushRelationTagTargets(relationTagInfo.source, pathInfo.base, relationTag, relationTagInfo);
            }
          }
        });
      }
      pushRelationTagTargets(file, filename, relationTag, relationTagInfo) {
        return __awaiter(this, void 0, void 0, function* () {
          const attribute = relationTag.attribute || "r:id";
          const addTargets = yield xml_helper_1.XmlHelper.getRelationshipItems(this.archive, file, (element, rels) => {
            rels.push({
              file,
              filename,
              rId: element.getAttribute(attribute),
              type: relationTag.type
            });
          }, relationTag.tag);
          this.addCreatedRelationsFunctions(addTargets, exports2.contentTracker.relations[relationTagInfo.relationsKey], relationTagInfo);
          relationTag.targets = [...relationTag.targets, ...addTargets];
        });
      }
      addCreatedRelationsFunctions(addTargets, createdRelations, relationTagInfo) {
        addTargets.forEach((addTarget) => {
          addTarget.getCreatedContent = this.getCreatedContent(createdRelations, addTarget);
          addTarget.getRelatedContent = this.addRelatedContent(relationTagInfo, addTarget);
        });
      }
      getCreatedContent(createdRelations, addTarget) {
        return () => {
          return createdRelations.find((relation) => {
            var _a;
            return relation.base === addTarget.filename + ".rels" && ((_a = relation.attributes) === null || _a === void 0 ? void 0 : _a.Id) === addTarget.rId;
          });
        };
      }
      addRelatedContent(relationTagInfo, addTarget) {
        return () => __awaiter(this, void 0, void 0, function* () {
          if (addTarget.relatedContent)
            return addTarget.relatedContent;
          const relationsFile = relationTagInfo.isDir === true ? relationTagInfo.relationsKey + "/" + addTarget.filename + ".rels" : relationTagInfo.relationsKey;
          const relationTarget = yield xml_helper_1.XmlHelper.getRelationshipItems(this.archive, relationsFile, (element, rels) => {
            const rId = element.getAttribute("Id");
            if (rId === addTarget.rId) {
              const target = element.getAttribute("Target");
              const targetMode = element.getAttribute("TargetMode");
              const fileInfo = file_helper_1.FileHelper.getFileInfo(target);
              if (targetMode !== "External") {
                rels.push({
                  file: target,
                  filename: fileInfo.base,
                  rId,
                  type: element.getAttribute("Type")
                });
              }
            }
          });
          addTarget.relatedContent = relationTarget.find((relationTarget2) => relationTarget2.rId === addTarget.rId);
          return addTarget.relatedContent;
        });
      }
      collect(section, role, collection) {
        return __awaiter(this, void 0, void 0, function* () {
          collection = collection || [];
          const trackedRelationTag = this.getRelationTag(section);
          const trackedRelations = trackedRelationTag.getTrackedRelations(role);
          const relatedTargets = yield this.getRelatedContents(trackedRelations);
          relatedTargets.forEach((relatedTarget) => collection.push(relatedTarget.filename));
          return collection;
        });
      }
      filterRelations(section, target) {
        const relations = this.relations[section];
        return relations.filter((rel) => rel.attributes.Target === target);
      }
    };
    exports2.ContentTracker = ContentTracker;
    exports2.contentTracker = new ContentTracker();
  }
});

// node_modules/pptx-automizer/dist/helper/archive/archive.js
var require_archive = __commonJS({
  "node_modules/pptx-automizer/dist/helper/archive/archive.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xmldom_1 = require_lib();
    var Archive = class {
      constructor(filename) {
        this.buffer = [];
        this.options = {
          type: "nodebuffer"
        };
        this.filename = filename;
      }
      parseXml(xmlString) {
        const dom = new xmldom_1.DOMParser();
        return dom.parseFromString(xmlString, "application/xml");
      }
      serializeXml(XmlDocument) {
        const s = new xmldom_1.XMLSerializer();
        return s.serializeToString(XmlDocument);
      }
      writeBuffer(archiveType) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const buffered of this.buffer) {
            const serialized = this.serializeXml(buffered.content);
            yield archiveType.write(buffered.relativePath, serialized);
          }
        });
      }
      toBuffer(relativePath, content) {
        const existing = this.fromBuffer(relativePath);
        if (!existing) {
          this.buffer.push({
            relativePath,
            name: relativePath,
            content
          });
        }
      }
      setOptions(params) {
        if (params.compression > 0) {
          this.options.compression = "DEFLATE";
          this.options.compressionOptions = {
            level: params.compression
          };
        }
      }
      fromBuffer(relativePath) {
        return this.buffer.find((file) => file.relativePath === relativePath);
      }
    };
    exports2.default = Archive;
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ended) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "node_modules/jszip/lib/support.js"(exports2) {
    "use strict";
    exports2.base64 = true;
    exports2.array = true;
    exports2.string = true;
    exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports2.nodebuffer = typeof Buffer !== "undefined";
    exports2.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports2.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports2.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports2.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports2.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports2.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports2.nodestream = false;
    }
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/jszip/lib/base64.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports2.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports2.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "node_modules/jszip/lib/nodejsUtils.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size) {
        if (Buffer.alloc) {
          return Buffer.alloc(size);
        } else {
          var buf = new Buffer(size);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  }
});

// node_modules/immediate/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/immediate/lib/index.js"(exports2, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/lie/lib/index.js"(exports2, module2) {
    "use strict";
    var immediate = require_lib2();
    function INTERNAL() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject2);
      function resolve2(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject2(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result = tryCatch(getThen, value);
      if (result.status === "error") {
        return handlers.reject(self2, result.value);
      }
      var thenable = result.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result = tryCatch(tryToUnwrap);
      if (result.status === "error") {
        onError(result.value);
      }
    }
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise2.reject = reject;
    function reject(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "node_modules/jszip/lib/external.js"(exports2, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib3();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/setimmediate/setImmediate.js"(exports2) {
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
  }
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "node_modules/jszip/lib/utils.js"(exports2) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result = null;
      if (support.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports2.newBlob = function(part, type) {
      exports2.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type = exports2.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports2.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports2.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports2.checkSupport(outputType);
      var inputType = exports2.getTypeOf(input);
      var result = transform[inputType][outputType](input);
      return result;
    };
    exports2.resolve = function(path2) {
      var parts = path2.split("/");
      var result = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports2.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports2.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports2.MAX_VALUE_16BITS = 65535;
    exports2.MAX_VALUE_32BITS = -1;
    exports2.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports2.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports2.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports2.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports2.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports2.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "node_modules/jszip/lib/stream/GenericWorker.js"(exports2, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk) {
        this.emit("data", chunk);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk) {
        this.push(chunk);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/jszip/lib/utf8.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports2.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports2.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports2.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports2.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports2.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports2.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports2.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "node_modules/jszip/lib/stream/ConvertWorker.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: utils.transformTo(this.destType, chunk.data),
        meta: chunk.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "node_modules/jszip/lib/stream/StreamHelper.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject(err);
        }).on("end", function() {
          try {
            var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve(result);
          } catch (e) {
            reject(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk) {
            fn.call(self2, chunk.data, chunk.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/jszip/lib/defaults.js"(exports2) {
    "use strict";
    exports2.base64 = false;
    exports2.binary = false;
    exports2.dir = false;
    exports2.createFolders = true;
    exports2.date = null;
    exports2.compression = null;
    exports2.compressionOptions = null;
    exports2.comment = null;
    exports2.unixPermissions = null;
    exports2.dosPermissions = null;
  }
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "node_modules/jszip/lib/stream/DataWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/jszip/lib/crc32.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "node_modules/jszip/lib/stream/Crc32Probe.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk) {
      this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
      this.push(chunk);
    };
    module2.exports = Crc32Probe;
  }
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "node_modules/jszip/lib/stream/DataLengthProbe.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk) {
      if (chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk);
    };
    module2.exports = DataLengthProbe;
  }
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/jszip/lib/compressedObject.js"(exports2, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/jszip/lib/zipObject.js"(exports2, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result = result.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result = new GenericWorker("error");
          result.error(e);
        }
        return new StreamHelper(result, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result = this._decompressWorker();
          if (!this._dataBinary) {
            result = result.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants2();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants2();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "node_modules/jszip/lib/flate.js"(exports2) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports2.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk) {
      this.meta = chunk.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports2.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports2.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "node_modules/jszip/lib/compressions.js"(exports2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports2.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports2.DEFLATE = require_flate();
  }
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "node_modules/jszip/lib/signature.js"(exports2) {
    "use strict";
    exports2.LOCAL_FILE_HEADER = "PK";
    exports2.CENTRAL_FILE_HEADER = "PK";
    exports2.CENTRAL_DIRECTORY_END = "PK";
    exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports2.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "node_modules/jszip/lib/generate/ZipFileWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result = unixPermissions;
      if (!unixPermissions) {
        result = isDir ? 16893 : 33204;
      }
      return (result & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk) {
      var currentFilePercent = chunk.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk);
      } else {
        this.bytesWritten += chunk.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "node_modules/jszip/lib/generate/index.js"(exports2) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports2.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk) {
        self2.push({
          data: chunk,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "node_modules/jszip/lib/object.js"(exports2, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object;
    };
    var parentFolder = function(path2) {
      if (path2.slice(-1) === "/") {
        path2 = path2.substring(0, path2.length - 1);
      }
      var lastSlash = path2.lastIndexOf("/");
      return lastSlash > 0 ? path2.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path2) {
      if (path2.slice(-1) !== "/") {
        path2 += "/";
      }
      return path2;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result.push(entry);
          }
        });
        return result;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "node_modules/jszip/lib/reader/DataReader.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size) {
        var result = 0, i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
          result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size) {
        return utils.transformTo("string", this.readData(size));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/ArrayReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return [];
      }
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = ArrayReader;
  }
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "node_modules/jszip/lib/reader/StringReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = StringReader;
  }
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports2, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size) {
      this.checkOffset(size);
      if (size === 0) {
        return new Uint8Array(0);
      }
      var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "node_modules/jszip/lib/reader/NodeBufferReader.js"(exports2, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size) {
      this.checkOffset(size);
      var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
      this.index += size;
      return result;
    };
    module2.exports = NodeBufferReader;
  }
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "node_modules/jszip/lib/reader/readerFor.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/jszip/lib/zipEntry.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/jszip/lib/zipEntries.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "node_modules/jszip/lib/load.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      });
    };
  }
});

// node_modules/jszip/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/jszip/lib/index.js"(exports2, module2) {
    "use strict";
    function JSZip() {
      if (!(this instanceof JSZip)) {
        return new JSZip();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip.prototype = require_object();
    JSZip.prototype.loadAsync = require_load();
    JSZip.support = require_support();
    JSZip.defaults = require_defaults();
    JSZip.version = "3.10.1";
    JSZip.loadAsync = function(content, options) {
      return new JSZip().loadAsync(content, options);
    };
    JSZip.external = require_external();
    module2.exports = JSZip;
  }
});

// node_modules/pptx-automizer/dist/helper/archive/archive-jszip.js
var require_archive_jszip = __commonJS({
  "node_modules/pptx-automizer/dist/helper/archive/archive-jszip.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var archive_1 = __importDefault(require_archive());
    var fs_1 = __importDefault(require("fs"));
    var jszip_1 = __importDefault(require_lib4());
    var path_1 = __importDefault(require("path"));
    var ArchiveJszip = class _ArchiveJszip extends archive_1.default {
      constructor(filename) {
        super(filename);
      }
      initialize() {
        return __awaiter(this, void 0, void 0, function* () {
          if (typeof this.filename !== "object") {
            this.file = yield fs_1.default.promises.readFile(this.filename);
          } else {
            this.file = this.filename;
          }
          const zip = new jszip_1.default();
          this.archive = yield zip.loadAsync(this.file);
          return this;
        });
      }
      fileExists(file) {
        if (this.archive === void 0 || this.archive.files[file] === void 0) {
          return false;
        }
        return true;
      }
      folder(dir) {
        return __awaiter(this, void 0, void 0, function* () {
          const files = [];
          this.archive.folder(dir).forEach((relativePath, file) => {
            if (!relativePath.includes("/")) {
              files.push({
                name: file.name,
                relativePath
              });
            }
          });
          return files;
        });
      }
      read(file, type) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.archive) {
            yield this.initialize();
          }
          if (!this.archive.files[file]) {
            if (typeof this.filename === "string") {
              throw new Error("Could not find file " + file + "@" + path_1.default.basename(this.filename));
            } else {
              throw new Error("Could not find file " + file);
            }
          }
          return this.archive.files[file].async(type || "string");
        });
      }
      write(file, data) {
        return __awaiter(this, void 0, void 0, function* () {
          this.archive.file(file, data);
          return this;
        });
      }
      remove(file) {
        return __awaiter(this, void 0, void 0, function* () {
          this.archive.remove(file);
        });
      }
      extract(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const contents = yield this.read(file, "nodebuffer");
          const zip = new jszip_1.default();
          const newArchive = new _ArchiveJszip(file);
          newArchive.archive = yield zip.loadAsync(contents);
          return newArchive;
        });
      }
      output(location, params) {
        return __awaiter(this, void 0, void 0, function* () {
          const content = yield this.getContent(params);
          yield fs_1.default.promises.writeFile(location, content).catch((err) => {
            console.error(err);
            throw new Error(`Could not write output file: ${location}`);
          });
        });
      }
      stream(params, options) {
        return __awaiter(this, void 0, void 0, function* () {
          this.setOptions(params);
          yield this.writeBuffer(this);
          const mergedOptions = Object.assign(Object.assign({}, this.options), options);
          return this.archive.generateNodeStream(mergedOptions);
        });
      }
      getFinalArchive() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.writeBuffer(this);
          return this.archive;
        });
      }
      getContent(params) {
        return __awaiter(this, void 0, void 0, function* () {
          this.setOptions(params);
          yield this.writeBuffer(this);
          return yield this.archive.generateAsync(this.options);
        });
      }
      readXml(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const isBuffered = this.fromBuffer(file);
          if (!isBuffered) {
            const xmlString = yield this.read(file, "string");
            const XmlDocument = this.parseXml(xmlString);
            this.toBuffer(file, XmlDocument);
            return XmlDocument;
          } else {
            return isBuffered.content;
          }
        });
      }
      writeXml(file, XmlDocument) {
        this.toBuffer(file, XmlDocument);
      }
    };
    exports2.default = ArchiveJszip;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable) onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable) callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable) callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled) return;
        if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream)) stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs2;
    try {
      fs2 = require("fs");
    } catch (e) {
    }
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient) return false;
      if (!fs2) return false;
      return (stream instanceof (fs2.ReadStream || noop) || stream instanceof (fs2.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop);
        if (isRequest(stream)) return stream.abort();
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream.getBufferedValue();
          }
          reject(error);
        };
        stream = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
    module2.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports2) {
    var fs2 = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs2.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      if (self2.autoClose) {
        fs2.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed) return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed) return cb();
        var buffer = new Buffer(toRead);
        fs2.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed) return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed) return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed) return cb();
        fs2.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed) return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs2 = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path2, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null) options = {};
      if (options.autoClose == null) options.autoClose = true;
      if (options.lazyEntries == null) options.lazyEntries = false;
      if (options.decodeStrings == null) options.decodeStrings = true;
      if (options.validateEntrySizes == null) options.validateEntrySizes = true;
      if (options.strictFileNames == null) options.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs2.open(path2, "r", function(err, fd) {
        if (err) return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2) fs2.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null) options = {};
      if (options.autoClose == null) options.autoClose = false;
      if (options.lazyEntries == null) options.lazyEntries = false;
      if (options.decodeStrings == null) options.decodeStrings = true;
      if (options.validateEntrySizes == null) options.validateEntrySizes = true;
      if (options.strictFileNames == null) options.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs2.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null) options = {};
      options.autoClose = false;
      if (options.lazyEntries == null) options.lazyEntries = false;
      if (options.decodeStrings == null) options.decodeStrings = true;
      if (options.validateEntrySizes == null) options.validateEntrySizes = true;
      if (options.strictFileNames == null) options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null) options = {};
      if (options.autoClose == null) options.autoClose = true;
      if (options.lazyEntries == null) options.lazyEntries = false;
      if (options.decodeStrings == null) options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null) options.validateEntrySizes = true;
      if (options.strictFileNames == null) options.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256) continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2) return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3) return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries) self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose) self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError) return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose) self2.close();
          if (self2.emittedError) return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError) return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err) return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError) return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2) return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError) return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length) return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries) self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false) throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0) throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0) throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen) return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err) return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed) inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed) endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err) return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet) return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err) throw err;
    }
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/extract-zip/index.js"(exports2, module2) {
    var debug = require_src()("extract-zip");
    var { createWriteStream, promises: fs2 } = require("fs");
    var getStream = require_get_stream();
    var path2 = require("path");
    var { promisify } = require("util");
    var stream = require("stream");
    var yauzl = require_yauzl();
    var openZip = promisify(yauzl.open);
    var pipeline = promisify(stream.pipeline);
    var Extractor = class {
      constructor(zipPath, opts) {
        this.zipPath = zipPath;
        this.opts = opts;
      }
      async extract() {
        debug("opening", this.zipPath, "with opts", this.opts);
        this.zipfile = await openZip(this.zipPath, { lazyEntries: true });
        this.canceled = false;
        return new Promise((resolve, reject) => {
          this.zipfile.on("error", (err) => {
            this.canceled = true;
            reject(err);
          });
          this.zipfile.readEntry();
          this.zipfile.on("close", () => {
            if (!this.canceled) {
              debug("zip extraction complete");
              resolve();
            }
          });
          this.zipfile.on("entry", async (entry) => {
            if (this.canceled) {
              debug("skipping entry", entry.fileName, { cancelled: this.canceled });
              return;
            }
            debug("zipfile entry", entry.fileName);
            if (entry.fileName.startsWith("__MACOSX/")) {
              this.zipfile.readEntry();
              return;
            }
            const destDir = path2.dirname(path2.join(this.opts.dir, entry.fileName));
            try {
              await fs2.mkdir(destDir, { recursive: true });
              const canonicalDestDir = await fs2.realpath(destDir);
              const relativeDestDir = path2.relative(this.opts.dir, canonicalDestDir);
              if (relativeDestDir.split(path2.sep).includes("..")) {
                throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
              }
              await this.extractEntry(entry);
              debug("finished processing", entry.fileName);
              this.zipfile.readEntry();
            } catch (err) {
              this.canceled = true;
              this.zipfile.close();
              reject(err);
            }
          });
        });
      }
      async extractEntry(entry) {
        if (this.canceled) {
          debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
          return;
        }
        if (this.opts.onEntry) {
          this.opts.onEntry(entry, this.zipfile);
        }
        const dest = path2.join(this.opts.dir, entry.fileName);
        const mode = entry.externalFileAttributes >> 16 & 65535;
        const IFMT = 61440;
        const IFDIR = 16384;
        const IFLNK = 40960;
        const symlink = (mode & IFMT) === IFLNK;
        let isDir = (mode & IFMT) === IFDIR;
        if (!isDir && entry.fileName.endsWith("/")) {
          isDir = true;
        }
        const madeBy = entry.versionMadeBy >> 8;
        if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;
        debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
        const procMode = this.getExtractedMode(mode, isDir) & 511;
        const destDir = isDir ? dest : path2.dirname(dest);
        const mkdirOptions = { recursive: true };
        if (isDir) {
          mkdirOptions.mode = procMode;
        }
        debug("mkdir", { dir: destDir, ...mkdirOptions });
        await fs2.mkdir(destDir, mkdirOptions);
        if (isDir) return;
        debug("opening read stream", dest);
        const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
        if (symlink) {
          const link = await getStream(readStream);
          debug("creating symlink", link, dest);
          await fs2.symlink(link, dest);
        } else {
          await pipeline(readStream, createWriteStream(dest, { mode: procMode }));
        }
      }
      getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        if (mode === 0) {
          if (isDir) {
            if (this.opts.defaultDirMode) {
              mode = parseInt(this.opts.defaultDirMode, 10);
            }
            if (!mode) {
              mode = 493;
            }
          } else {
            if (this.opts.defaultFileMode) {
              mode = parseInt(this.opts.defaultFileMode, 10);
            }
            if (!mode) {
              mode = 420;
            }
          }
        }
        return mode;
      }
    };
    module2.exports = async function(zipPath, opts) {
      debug("creating target directory", opts.dir);
      if (!path2.isAbsolute(opts.dir)) {
        throw new Error("Target directory is expected to be absolute");
      }
      await fs2.mkdir(opts.dir, { recursive: true });
      opts.dir = await fs2.realpath(opts.dir);
      return new Extractor(zipPath, opts).extract();
    };
  }
});

// node_modules/pptx-automizer/dist/helper/jszip-helper.js
var require_jszip_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/jszip-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compressFolder = void 0;
    var fs_1 = __importStar(require("fs"));
    var path_1 = __importDefault(require("path"));
    var jszip_1 = __importDefault(require_lib4());
    var getFilePathsRecursively = (dir) => __awaiter(void 0, void 0, void 0, function* () {
      const list = yield fs_1.promises.readdir(dir);
      const statPromises = list.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        const fullPath = path_1.default.resolve(dir, file);
        const stat = yield fs_1.promises.stat(fullPath);
        if (stat && stat.isDirectory()) {
          return getFilePathsRecursively(fullPath);
        }
        return fullPath;
      }));
      return (yield Promise.all(statPromises)).flat(Infinity);
    });
    var createZipFromFolder = (dir) => __awaiter(void 0, void 0, void 0, function* () {
      const absRoot = path_1.default.resolve(dir);
      const filePaths = yield getFilePathsRecursively(dir);
      return filePaths.reduce((z, filePath) => {
        const relative = filePath.replace(absRoot, "");
        const zipFolder = path_1.default.dirname(relative).split(path_1.default.sep).reduce((zf, dirName) => zf.folder(dirName), z);
        zipFolder.file(path_1.default.basename(filePath), fs_1.default.createReadStream(filePath));
        return z;
      }, new jszip_1.default());
    });
    var compressFolder = (srcDir, destFile, options) => __awaiter(void 0, void 0, void 0, function* () {
      const start = Date.now();
      try {
        const zip = yield createZipFromFolder(srcDir);
        zip.generateNodeStream(Object.assign({ streamFiles: true }, options)).pipe(fs_1.default.createWriteStream(destFile)).on("error", (err) => console.error("Error writing file", err.stack)).on("finish", () => console.log("Zip written successfully:", Date.now() - start, "ms"));
      } catch (ex) {
        console.error("Error creating zip", ex);
      }
    });
    exports2.compressFolder = compressFolder;
  }
});

// node_modules/pptx-automizer/dist/helper/archive/archive-fs.js
var require_archive_fs = __commonJS({
  "node_modules/pptx-automizer/dist/helper/archive/archive-fs.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var archive_1 = __importDefault(require_archive());
    var fs_1 = require("fs");
    var jszip_1 = __importDefault(require_lib4());
    var archive_jszip_1 = __importDefault(require_archive_jszip());
    var file_helper_1 = require_file_helper();
    var extract_zip_1 = __importDefault(require_extract_zip());
    var jszip_helper_1 = require_jszip_helper();
    var ArchiveFs = class extends archive_1.default {
      constructor(filename, params) {
        super(filename);
        this.dir = void 0;
        this.filename = filename;
        this.params = params;
      }
      initialize() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setPaths();
          yield this.assertDirs();
          yield this.extractFile(this.filename);
          if (!this.params.name) {
            yield this.prepareWorkDir(this.filename);
            this.isRoot = true;
          }
          this.archive = true;
          return this;
        });
      }
      setPaths() {
        this.dir = this.params.baseDir + "/";
        this.templatesDir = this.dir + "templates/";
        this.outputDir = this.dir + "output/";
        this.templateDir = void 0;
        this.workDir = this.outputDir + this.params.workDir + "/";
      }
      assertDirs() {
        return __awaiter(this, void 0, void 0, function* () {
          (0, file_helper_1.makeDirIfNotExists)(this.dir);
          (0, file_helper_1.makeDirIfNotExists)(this.templatesDir);
          (0, file_helper_1.makeDirIfNotExists)(this.outputDir);
          (0, file_helper_1.makeDirIfNotExists)(this.workDir);
        });
      }
      extractFile(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const targetDir = this.getTemplateDir(file);
          if ((0, file_helper_1.exists)(targetDir)) {
            return;
          }
          yield (0, extract_zip_1.default)(file, { dir: targetDir }).catch((err) => {
            throw err;
          });
        });
      }
      getTemplateDir(file) {
        const info = file_helper_1.FileHelper.getFileInfo(file);
        this.templateDir = this.templatesDir + info.base + "/";
        return this.templateDir;
      }
      prepareWorkDir(templateDir) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.cleanupWorkDir();
          const fromTemplate = this.getTemplateDir(templateDir);
          yield (0, file_helper_1.copyDir)(fromTemplate, this.workDir);
        });
      }
      fileExists(file) {
        return (0, file_helper_1.exists)(this.getPath(file));
      }
      folder(dir) {
        return __awaiter(this, void 0, void 0, function* () {
          const path2 = this.getPath(dir);
          const files = [];
          if (!(0, file_helper_1.exists)(path2)) {
            return files;
          }
          let entries = yield fs_1.promises.readdir(path2, { withFileTypes: true });
          for (let entry of entries) {
            if (!entry.isDirectory()) {
              files.push({
                name: dir + "/" + entry.name,
                relativePath: entry.name
              });
            }
          }
          return files;
        });
      }
      read(file) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.archive) {
            yield this.initialize();
          }
          const path2 = this.getPath(file);
          return yield fs_1.promises.readFile(path2);
        });
      }
      getPath(file) {
        if (this.isRoot) {
          return this.workDir + file;
        }
        return this.templateDir + file;
      }
      write(file, data) {
        return __awaiter(this, void 0, void 0, function* () {
          const filename = this.workDir + file;
          (0, file_helper_1.ensureDirectoryExistence)(filename);
          yield fs_1.promises.writeFile(filename, data);
          return this;
        });
      }
      remove(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const path2 = this.getPath(file);
          if ((0, file_helper_1.exists)(path2)) {
            yield fs_1.promises.unlink(path2);
          }
        });
      }
      output(location, params) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.writeBuffer(this);
          this.setOptions(params);
          if ((0, file_helper_1.exists)(location)) {
            yield fs_1.promises.rm(location);
          }
          yield (0, jszip_helper_1.compressFolder)(this.workDir, location, this.options);
          if (this.params.cleanupWorkDir === true) {
            yield this.cleanupWorkDir();
          }
        });
      }
      cleanupWorkDir() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!(0, file_helper_1.exists)(this.workDir)) {
            return;
          }
          yield fs_1.promises.rm(this.workDir, { recursive: true, force: true });
        });
      }
      readXml(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const isBuffered = this.fromBuffer(file);
          if (!isBuffered) {
            const buffer = yield this.read(file);
            if (!buffer) {
              throw "no buffer: " + file;
            }
            const xmlString = buffer.toString();
            const XmlDocument = this.parseXml(xmlString);
            this.toBuffer(file, XmlDocument);
            return XmlDocument;
          } else {
            return isBuffered.content;
          }
        });
      }
      writeXml(file, XmlDocument) {
        this.toBuffer(file, XmlDocument);
      }
      /**
       * Used for worksheets only
       **/
      extract(file) {
        return __awaiter(this, void 0, void 0, function* () {
          const contents = yield this.read(file);
          const zip = new jszip_1.default();
          const newArchive = new archive_jszip_1.default(file);
          newArchive.archive = yield zip.loadAsync(contents);
          return newArchive;
        });
      }
    };
    exports2.default = ArchiveFs;
  }
});

// node_modules/pptx-automizer/dist/helper/file-helper.js
var require_file_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/file-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureDirectoryExistence = exports2.copyDir = exports2.makeDir = exports2.makeDirIfNotExists = exports2.exists = exports2.FileHelper = void 0;
    var fs_1 = __importDefault(require("fs"));
    var fs_2 = require("fs");
    var path_1 = __importDefault(require("path"));
    var content_tracker_1 = require_content_tracker();
    var archive_jszip_1 = __importDefault(require_archive_jszip());
    var archive_fs_1 = __importDefault(require_archive_fs());
    var FileHelper = class _FileHelper {
      static importArchive(file, params) {
        if (typeof file !== "object") {
          if (!fs_1.default.existsSync(file)) {
            throw new Error("File not found: " + file);
          }
          switch (params.mode) {
            case "jszip":
              return new archive_jszip_1.default(file);
            case "fs":
              return new archive_fs_1.default(file, params);
          }
        } else {
          return new archive_jszip_1.default(file);
        }
      }
      static removeFromDirectory(archive, dir, cb) {
        return __awaiter(this, void 0, void 0, function* () {
          const removed = [];
          const files = yield archive.folder(dir);
          for (const file of files) {
            if (cb(file)) {
              yield archive.remove(file.name);
              removed.push(file.name);
            }
          }
          return removed;
        });
      }
      static getFileExtension(filename) {
        return path_1.default.extname(filename).replace(".", "");
      }
      static getFileInfo(filename) {
        return {
          base: path_1.default.basename(filename),
          dir: path_1.default.dirname(filename),
          isDir: filename[filename.length - 1] === "/",
          extension: path_1.default.extname(filename).replace(".", "")
        };
      }
      static check(archive, file) {
        _FileHelper.isArchive(archive);
        return _FileHelper.fileExistsInArchive(archive, file);
      }
      static isArchive(archive) {
        if (archive === void 0) {
          throw new Error("Archive is invalid or empty.");
        }
      }
      static fileExistsInArchive(archive, file) {
        return archive.fileExists(file);
      }
      static zipCopyWithRelations(parentClass, type, sourceNumber, targetNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          const typePlural = type + "s";
          yield _FileHelper.zipCopyByIndex(parentClass, `ppt/${typePlural}/${type}`, sourceNumber, targetNumber);
          yield _FileHelper.zipCopyByIndex(parentClass, `ppt/${typePlural}/_rels/${type}`, sourceNumber, targetNumber, ".xml.rels");
        });
      }
      static zipCopyByIndex(parentClass, prefix, sourceId, targetId, suffix) {
        return __awaiter(this, void 0, void 0, function* () {
          suffix = suffix || ".xml";
          return _FileHelper.zipCopy(parentClass.sourceArchive, `${prefix}${sourceId}${suffix}`, parentClass.targetArchive, `${prefix}${targetId}${suffix}`);
        });
      }
      /**
       * Copies a file from one archive to another. The new file can have a different name to the origin.
       * @param {IArchive} sourceArchive - Source archive
       * @param {string} sourceFile - file path and name inside source archive
       * @param {IArchive} targetArchive - Target archive
       * @param {string} targetFile - file path and name inside target archive
       * @return {IArchive} targetArchive as an instance of IArchive
       */
      static zipCopy(sourceArchive, sourceFile, targetArchive, targetFile) {
        return __awaiter(this, void 0, void 0, function* () {
          _FileHelper.check(sourceArchive, sourceFile);
          content_tracker_1.contentTracker.trackFile(targetFile);
          const content = yield sourceArchive.read(sourceFile, "nodebuffer").catch((e) => {
            throw e;
          });
          return targetArchive.write(targetFile || sourceFile, content);
        });
      }
    };
    exports2.FileHelper = FileHelper;
    var exists = (dir) => {
      return fs_1.default.existsSync(dir);
    };
    exports2.exists = exists;
    var makeDirIfNotExists = (dir) => {
      if (!(0, exports2.exists)(dir)) {
        (0, exports2.makeDir)(dir);
      }
    };
    exports2.makeDirIfNotExists = makeDirIfNotExists;
    var makeDir = (dir) => {
      try {
        if (!fs_1.default.existsSync(dir)) {
          fs_1.default.mkdirSync(dir);
        }
      } catch (err) {
        throw err;
      }
    };
    exports2.makeDir = makeDir;
    var copyDir = (src, dest) => __awaiter(void 0, void 0, void 0, function* () {
      yield fs_2.promises.mkdir(dest, { recursive: true });
      let entries = yield fs_2.promises.readdir(src, { withFileTypes: true });
      for (let entry of entries) {
        let srcPath = path_1.default.join(src, entry.name);
        let destPath = path_1.default.join(dest, entry.name);
        entry.isDirectory() ? yield (0, exports2.copyDir)(srcPath, destPath) : yield fs_2.promises.copyFile(srcPath, destPath);
      }
    });
    exports2.copyDir = copyDir;
    var ensureDirectoryExistence = (filePath) => {
      const dirname = path_1.default.dirname(filePath);
      if (fs_1.default.existsSync(dirname)) {
        return true;
      }
      (0, exports2.ensureDirectoryExistence)(dirname);
      fs_1.default.mkdirSync(dirname);
    };
    exports2.ensureDirectoryExistence = ensureDirectoryExistence;
  }
});

// node_modules/pptx-automizer/dist/helper/xml-relationship-helper.js
var require_xml_relationship_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-relationship-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XmlRelationshipHelper = void 0;
    var xml_helper_1 = require_xml_helper();
    var general_helper_1 = require_general_helper();
    var file_helper_1 = require_file_helper();
    var crypto_1 = require("crypto");
    var XmlRelationshipHelper = class _XmlRelationshipHelper {
      constructor(xml, tag) {
        this.xmlTargets = [];
        this.targets = [];
        if (xml) {
          this.setXml(xml);
        }
        this.tag = tag || "Relationship";
        return this;
      }
      initialize(archive, file, path2, prefix) {
        return __awaiter(this, void 0, void 0, function* () {
          this.archive = archive;
          this.file = file;
          this.path = path2 + "/";
          const fileProxy = yield this.archive;
          this.xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(fileProxy, this.path + this.file);
          yield this.readTargets();
          if (prefix) {
            return this.getTargetsByPrefix(prefix);
          }
          return this;
        });
      }
      setXml(xml) {
        this.xml = xml;
        return this;
      }
      getTargetsByPrefix(prefix) {
        const prefixes = typeof prefix === "string" ? [prefix] : prefix;
        const targets = [];
        this.xmlTargets.forEach((xmlTarget) => {
          prefixes.forEach((prefix2) => {
            const target = _XmlRelationshipHelper.parseRelationTarget(xmlTarget, prefix2, true);
            if (target === null || target === void 0 ? void 0 : target.prefix) {
              targets.push(target);
            }
          });
        });
        return targets;
      }
      getTargetsByType(type) {
        const targets = [];
        this.xmlTargets.forEach((xmlTarget) => {
          const target = _XmlRelationshipHelper.parseRelationTarget(xmlTarget);
          if ((target === null || target === void 0 ? void 0 : target.type) === type) {
            targets.push(target);
          }
        });
        return targets;
      }
      getTargetByRelId(findRid) {
        const matchedTarget = this.xmlTargets.find((xmlTarget) => xmlTarget.getAttribute("Id") === findRid);
        if (matchedTarget) {
          return _XmlRelationshipHelper.parseRelationTarget(matchedTarget);
        }
      }
      readTargets() {
        if (this.xmlTargets.length) {
          return this;
        }
        const relationshipItems = this.xml.getElementsByTagName(this.tag);
        for (const i in relationshipItems) {
          if (relationshipItems[i] && relationshipItems[i].getAttribute !== void 0) {
            this.xmlTargets.push(relationshipItems[i]);
          }
        }
        return this;
      }
      /**
       * This will copy all unhandled related contents into
       * the target archive.
       *
       * Pptx messages on opening a corrupted file are most likely
       * caused by broken relations and this is going to prevent
       * files from being missed.
       *
       * @param sourceArchive
       * @param check
       * @param assert
       */
      assertRelatedContent(sourceArchive, check, assert) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const xmlTarget of this.xmlTargets) {
            const targetFile = xmlTarget.getAttribute("Target");
            const targetMode = xmlTarget.getAttribute("TargetMode");
            const targetPath = targetFile.replace("../", "ppt/");
            if (targetMode !== "External" && this.archive.fileExists(targetPath) === false) {
              if (assert) {
                const target = _XmlRelationshipHelper.parseRelationTarget(xmlTarget);
                const buf = (0, crypto_1.randomBytes)(5).toString("hex");
                const targetSuffix = "-" + buf + "." + target.filenameExt;
                yield file_helper_1.FileHelper.zipCopy(sourceArchive, targetPath, this.archive, targetPath + targetSuffix);
                xmlTarget.setAttribute("Target", targetFile + targetSuffix);
                yield xml_helper_1.XmlHelper.appendImageExtensionToContentType(this.archive, target.filenameExt);
              }
            }
          }
        });
      }
      static parseRelationTarget(element, prefix, matchByPrefix) {
        if (!element || element.getAttribute === void 0) {
          return;
        }
        const type = element.getAttribute("Type");
        const file = element.getAttribute("Target");
        const rId = element.getAttribute("Id");
        const filename = (0, general_helper_1.last)(file.split("/"));
        const relType = (0, general_helper_1.last)(type.split("/"));
        const filenameExt = (0, general_helper_1.last)(filename.split("."));
        const filenameMatch = filename.replace("." + filenameExt, "").match(/^(.+?)(\d+)*$/);
        const number = filenameMatch && filenameMatch[2] ? Number(filenameMatch[2]) : 0;
        const filenameBase = filenameMatch && filenameMatch[1] ? filenameMatch[1] : filename;
        const target = {
          rId,
          type,
          file,
          filename,
          relType,
          element,
          filenameExt,
          filenameMatch,
          number,
          filenameBase,
          getTargetValue: () => target.element.getAttribute("Target"),
          updateTargetValue: (newTarget) => {
            target.element.setAttribute("Target", newTarget);
          },
          updateId: (newId) => {
            target.element.setAttribute("Id", newId);
          }
        };
        if (prefix) {
          const subtype = (0, general_helper_1.last)(prefix.split("/"));
          if (matchByPrefix && !_XmlRelationshipHelper.targetMatchesRelationship(relType, subtype, file, prefix)) {
            return;
          }
          return this.extendTarget(prefix, subtype, target);
        }
        return target;
      }
      static extendTarget(prefix, subtype, target) {
        return Object.assign(Object.assign({}, target), {
          prefix,
          subtype,
          updateTargetIndex: (newIndex) => {
            target.element.setAttribute("Target", `${prefix}${newIndex}.xml`);
          }
        });
      }
      static targetMatchesRelationship(relType, subtype, target, prefix) {
        if (relType === "package")
          return true;
        return relType === subtype && target.indexOf(prefix) === 0;
      }
      static getSlideLayoutNumber(sourceArchive, slideId) {
        return __awaiter(this, void 0, void 0, function* () {
          const slideToLayouts = yield new _XmlRelationshipHelper().initialize(sourceArchive, `slide${slideId}.xml.rels`, `ppt/slides/_rels`, "../slideLayouts/slideLayout");
          return slideToLayouts[0].number;
        });
      }
      static getSlideMasterNumber(sourceArchive, slideLayoutId) {
        return __awaiter(this, void 0, void 0, function* () {
          const layoutToMaster = yield new _XmlRelationshipHelper().initialize(sourceArchive, `slideLayout${slideLayoutId}.xml.rels`, `ppt/slideLayouts/_rels`, "../slideMasters/slideMaster");
          return layoutToMaster[0].number;
        });
      }
    };
    exports2.XmlRelationshipHelper = XmlRelationshipHelper;
  }
});

// node_modules/pptx-automizer/dist/classes/shape.js
var require_shape = __commonJS({
  "node_modules/pptx-automizer/dist/classes/shape.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Shape = void 0;
    var xml_helper_1 = require_xml_helper();
    var general_helper_1 = require_general_helper();
    var content_type_map_1 = require_content_type_map();
    var Shape = class {
      constructor(shape, targetType) {
        this.shape = shape;
        this.mode = shape.mode;
        this.name = shape.name;
        this.targetType = targetType;
        this.sourceArchive = shape.sourceArchive;
        this.sourceSlideNumber = shape.sourceSlideNumber;
        this.sourceSlideFile = `ppt/slides/slide${this.sourceSlideNumber}.xml`;
        this.sourceElement = shape.sourceElement;
        this.hasCreationId = shape.hasCreationId;
        this.callbacks = general_helper_1.GeneralHelper.arrayify(shape.callback);
        this.contentTypeMap = content_type_map_1.ContentTypeMap;
        if (shape.target) {
          this.sourceNumber = shape.target.number;
          this.sourceRid = shape.target.rId;
          this.subtype = shape.target.subtype;
          this.target = shape.target;
        }
      }
      setTarget(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          const targetType = this.targetType;
          this.targetTemplate = targetTemplate;
          this.targetArchive = yield this.targetTemplate.archive;
          this.targetSlideNumber = targetSlideNumber;
          this.targetSlideFile = `ppt/${targetType}s/${targetType}${this.targetSlideNumber}.xml`;
          this.targetSlideRelFile = `ppt/${targetType}s/_rels/${targetType}${this.targetSlideNumber}.xml.rels`;
        });
      }
      setTargetElement() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.sourceElement) {
            console.log(this.shape);
            throw "No source element for shape " + this.name;
          }
          this.targetElement = this.sourceElement.cloneNode(true);
        });
      }
      appendToSlideTree() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetSlideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetSlideFile);
          targetSlideXml.getElementsByTagName("p:spTree")[0].appendChild(this.targetElement);
          if (this.relRootTag === "a:hlinkClick") {
            yield this.processHyperlinks(targetSlideXml);
          }
          xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, this.targetSlideFile, targetSlideXml);
        });
      }
      // Process hyperlinks in the element
      processHyperlinks(targetSlideXml) {
        return __awaiter(this, void 0, void 0, function* () {
          const runs = this.targetElement.getElementsByTagName("a:r");
          for (let i = 0; i < runs.length; i++) {
            const run = runs[i];
            const rPr = run.getElementsByTagName("a:rPr")[0];
            if (rPr) {
              const hlinkClicks = rPr.getElementsByTagName("a:hlinkClick");
              for (let j = 0; j < hlinkClicks.length; j++) {
                const hlinkClick = hlinkClicks[j];
                const sourceRid = hlinkClick.getAttribute("r:id");
                if (sourceRid) {
                  hlinkClick.setAttribute("r:id", this.createdRid);
                  hlinkClick.setAttribute("xmlns:r", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
                }
              }
            }
          }
        });
      }
      replaceIntoSlideTree() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.modifySlideTree(true);
        });
      }
      removeFromSlideTree() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.modifySlideTree(false);
        });
      }
      modifySlideTree(insertBefore) {
        return __awaiter(this, void 0, void 0, function* () {
          const archive = this.targetArchive;
          const slideFile = this.targetSlideFile;
          const targetSlideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slideFile);
          const findMethod = this.hasCreationId ? "findByCreationId" : "findByName";
          const sourceElementOnTargetSlide = yield xml_helper_1.XmlHelper[findMethod](targetSlideXml, this.name);
          if (!(sourceElementOnTargetSlide === null || sourceElementOnTargetSlide === void 0 ? void 0 : sourceElementOnTargetSlide.parentNode)) {
            console.error(`Can't modify slide tree for ${this.name}`);
            return;
          }
          if (insertBefore === true) {
            sourceElementOnTargetSlide.parentNode.insertBefore(this.targetElement, sourceElementOnTargetSlide);
          }
          sourceElementOnTargetSlide.parentNode.removeChild(sourceElementOnTargetSlide);
          if (this.relRootTag === "a:hlinkClick") {
            yield this.processHyperlinks(targetSlideXml);
          }
          xml_helper_1.XmlHelper.writeXmlToArchive(archive, slideFile, targetSlideXml);
        });
      }
      updateElementsRelId() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetSlideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetSlideFile);
          const targetElements = yield this.getElementsByRid(targetSlideXml, this.sourceRid);
          targetElements.forEach((targetElement) => {
            this.relParent(targetElement).getElementsByTagName(this.relRootTag)[0].setAttribute(this.relAttribute, this.createdRid);
          });
          xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, this.targetSlideFile, targetSlideXml);
        });
      }
      /*
       * This will find all elements with a matching rId on a
       * <p:cSld>, including related images at <p:bg> and <p:spTree>.
       */
      getElementsByRid(slideXml, rId) {
        return __awaiter(this, void 0, void 0, function* () {
          const sourceList = slideXml.getElementsByTagName("p:cSld")[0].getElementsByTagName(this.relRootTag);
          const sourceElements = xml_helper_1.XmlHelper.findByAttributeValue(sourceList, this.relAttribute, rId);
          return sourceElements;
        });
      }
      updateTargetElementRelId() {
        return __awaiter(this, void 0, void 0, function* () {
          this.targetElement.getElementsByTagName(this.relRootTag)[0].setAttribute(this.relAttribute, this.createdRid);
        });
      }
      applyCallbacks(callbacks, element, relation) {
        callbacks.forEach((callback) => {
          if (typeof callback === "function") {
            try {
              callback(element, relation);
            } catch (e) {
              console.warn(e);
            }
          }
        });
      }
      applyChartCallbacks(callbacks, element, chart, workbook) {
        callbacks.forEach((callback) => {
          if (typeof callback === "function") {
            try {
              callback(element, chart, workbook);
            } catch (e) {
              console.warn(e);
            }
          }
        });
      }
      appendImageExtensionToContentType(extension) {
        return xml_helper_1.XmlHelper.appendImageExtensionToContentType(this.targetArchive, extension);
      }
    };
    exports2.Shape = Shape;
  }
});

// node_modules/pptx-automizer/dist/shapes/chart.js
var require_chart = __commonJS({
  "node_modules/pptx-automizer/dist/shapes/chart.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Chart = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var shape_1 = require_shape();
    var path_1 = __importDefault(require("path"));
    var content_tracker_1 = require_content_tracker();
    var Chart = class extends shape_1.Shape {
      constructor(shape, targetType) {
        super(shape, targetType);
        this.relRootTag = this.subtype === "chart" ? "c:chart" : "cx:chart";
        this.relAttribute = "r:id";
        this.relParent = this.subtype === "chart" ? (element) => element.parentNode.parentNode.parentNode : (element) => element.parentNode.parentNode.parentNode.parentNode.parentNode;
        this.wbEmbeddingsPath = `../embeddings/`;
        this.wbExtension = ".xlsx";
        this.relTypeChartColorStyle = "http://schemas.microsoft.com/office/2011/relationships/chartColorStyle";
        this.relTypeChartStyle = "http://schemas.microsoft.com/office/2011/relationships/chartStyle";
        this.relTypeChartImage = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
        this.relTypeChartThemeOverride = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/themeOverride";
        this.styleRelationFiles = {};
      }
      modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.clone();
          yield this.replaceIntoSlideTree();
          return this;
        });
      }
      append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.clone();
          yield this.appendToSlideTree();
          return this;
        });
      }
      remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.removeFromSlideTree();
          return this;
        });
      }
      modifyOnAddedSlide(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.updateElementsRelId();
          return this;
        });
      }
      prepare(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTarget(targetTemplate, targetSlideNumber);
          this.targetNumber = this.targetTemplate.incrementCounter("charts");
          this.wbRelsPath = `ppt/charts/_rels/${this.subtype}${this.sourceNumber}.xml.rels`;
          yield this.copyFiles();
          yield this.copyChartStyleFiles();
          yield this.appendTypes();
          yield this.appendToSlideRels();
        });
      }
      clone() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTargetElement();
          yield this.modifyChartData();
          yield this.updateTargetElementRelId();
        });
      }
      modifyChartData() {
        return __awaiter(this, void 0, void 0, function* () {
          const chartXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, `ppt/charts/${this.subtype}${this.targetNumber}.xml`);
          const workbook = yield this.readWorkbook();
          this.applyChartCallbacks(this.callbacks, this.targetElement, chartXml, workbook);
          xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, `ppt/charts/${this.subtype}${this.targetNumber}.xml`, chartXml);
          yield this.writeWorkbook(workbook);
        });
      }
      readWorkbook() {
        return __awaiter(this, void 0, void 0, function* () {
          const workbookFilename = `ppt/embeddings/${this.worksheetFilePrefix}${this.targetWorksheet}${this.wbExtension}`;
          const archive = yield this.targetArchive.extract(workbookFilename);
          const sheet = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, "xl/worksheets/sheet1.xml");
          const table = file_helper_1.FileHelper.fileExistsInArchive(archive, "xl/tables/table1.xml") ? yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, "xl/tables/table1.xml") : void 0;
          const sharedStrings = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, "xl/sharedStrings.xml");
          return {
            archive,
            sheet,
            sharedStrings,
            table
          };
        });
      }
      writeWorkbook(workbook) {
        return __awaiter(this, void 0, void 0, function* () {
          xml_helper_1.XmlHelper.writeXmlToArchive(workbook.archive, "xl/worksheets/sheet1.xml", workbook.sheet);
          if (workbook.table) {
            xml_helper_1.XmlHelper.writeXmlToArchive(workbook.archive, "xl/tables/table1.xml", workbook.table);
          }
          xml_helper_1.XmlHelper.writeXmlToArchive(workbook.archive, "xl/sharedStrings.xml", workbook.sharedStrings);
          const worksheet = yield workbook.archive.getContent({});
          yield this.targetArchive.write(`ppt/embeddings/${this.worksheetFilePrefix}${this.targetWorksheet}${this.wbExtension}`, worksheet);
        });
      }
      copyFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.copyChartFiles();
          this.worksheetFilePrefix = yield this.getWorksheetFilePrefix(this.wbRelsPath);
          const worksheets = yield xml_helper_1.XmlHelper.getRelationshipTargetsByPrefix(this.sourceArchive, this.wbRelsPath, `${this.wbEmbeddingsPath}${this.worksheetFilePrefix}`);
          const worksheet = worksheets[0];
          this.sourceWorksheet = worksheet.number === 0 ? "" : worksheet.number;
          this.targetWorksheet = "-created-" + this.targetNumber;
          yield this.copyWorksheetFile();
          yield this.editTargetWorksheetRel();
        });
      }
      getWorksheetFilePrefix(targetRelFile) {
        return __awaiter(this, void 0, void 0, function* () {
          const relationTargets = yield xml_helper_1.XmlHelper.getRelationshipTargetsByPrefix(this.sourceArchive, targetRelFile, this.wbEmbeddingsPath);
          if (!relationTargets[0]) {
            throw new Error(`Could not find a related worksheet pointing to ${this.wbEmbeddingsPath}@${targetRelFile}`);
          }
          return relationTargets[0].filenameBase;
        });
      }
      appendTypes() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.appendChartExtensionToContentType();
          yield this.appendChartToContentType();
          yield this.appendColorToContentType();
          yield this.appendStyleToContentType();
          yield this.appendThemeOverrideToContentType();
        });
      }
      copyChartFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/charts/${this.subtype}${this.sourceNumber}.xml`, this.targetArchive, `ppt/charts/${this.subtype}${this.targetNumber}.xml`);
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/charts/_rels/${this.subtype}${this.sourceNumber}.xml.rels`, this.targetArchive, `ppt/charts/_rels/${this.subtype}${this.targetNumber}.xml.rels`);
        });
      }
      copyChartStyleFiles() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.getChartStyles();
          if ((_a = this.styleRelationFiles.relTypeChartStyle) === null || _a === void 0 ? void 0 : _a.length) {
            yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/charts/${this.styleRelationFiles.relTypeChartStyle[0]}`, this.targetArchive, `ppt/charts/style${this.targetNumber}.xml`);
          }
          if ((_b = this.styleRelationFiles.relTypeChartColorStyle) === null || _b === void 0 ? void 0 : _b.length) {
            yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/charts/${this.styleRelationFiles.relTypeChartColorStyle[0]}`, this.targetArchive, `ppt/charts/colors${this.targetNumber}.xml`);
          }
          if (this.styleRelationFiles.relTypeChartImage) {
            for (const relTypeChartImage of this.styleRelationFiles.relTypeChartImage) {
              const imageInfo = this.getTargetChartImageUri(relTypeChartImage);
              yield this.appendImageExtensionToContentType(imageInfo.extension);
              yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, imageInfo.source, this.targetArchive, imageInfo.target);
            }
          }
          if ((_c = this.styleRelationFiles.relTypeChartThemeOverride) === null || _c === void 0 ? void 0 : _c.length) {
            const sourceFile = this.styleRelationFiles.relTypeChartThemeOverride[0].replace("../theme/", "");
            yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/theme/${sourceFile}`, this.targetArchive, `ppt/theme/themeOverride${this.targetNumber}.xml`);
          }
        });
      }
      getChartStyles() {
        return __awaiter(this, void 0, void 0, function* () {
          const styleTypes = [
            "relTypeChartStyle",
            "relTypeChartColorStyle",
            "relTypeChartImage",
            "relTypeChartThemeOverride"
          ];
          for (const i in styleTypes) {
            const styleType = styleTypes[i];
            const styleRelation = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(this.sourceArchive, this.wbRelsPath, this[styleType]);
            this.styleRelationFiles[styleType] = this.styleRelationFiles[styleType] || [];
            if (styleRelation.length) {
              styleRelation.forEach((styleRelation2) => {
                this.styleRelationFiles[styleType].push(styleRelation2.file);
              });
            }
          }
        });
      }
      appendToSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
          this.createdRid = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, this.targetSlideRelFile);
          const type = this.subtype === "chart" ? "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart" : "http://schemas.microsoft.com/office/2014/relationships/chartEx";
          const attributes = {
            Id: this.createdRid,
            Type: type,
            Target: `../charts/${this.subtype}${this.targetNumber}.xml`
          };
          return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createRelationshipChild(this.targetArchive, this.targetSlideRelFile, attributes));
        });
      }
      editTargetWorksheetRel() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = `ppt/charts/_rels/${this.subtype}${this.targetNumber}.xml.rels`;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relations = relXml.getElementsByTagName("Relationship");
          Object.keys(relations).map((key) => relations[key]).filter((element) => element.getAttribute).forEach((element) => {
            const type = element.getAttribute("Type");
            switch (type) {
              case "http://schemas.openxmlformats.org/officeDocument/2006/relationships/package":
                this.updateTargetWorksheetRelation(targetRelFile, element, "Target", `${this.wbEmbeddingsPath}${this.worksheetFilePrefix}${this.targetWorksheet}${this.wbExtension}`);
                break;
              case this.relTypeChartColorStyle:
                this.updateTargetWorksheetRelation(targetRelFile, element, "Target", `colors${this.targetNumber}.xml`);
                break;
              case this.relTypeChartStyle:
                this.updateTargetWorksheetRelation(targetRelFile, element, "Target", `style${this.targetNumber}.xml`);
                break;
              case this.relTypeChartImage:
                const target = element.getAttribute("Target");
                const imageInfo = this.getTargetChartImageUri(target);
                this.updateTargetWorksheetRelation(targetRelFile, element, "Target", imageInfo.rel);
                break;
              case this.relTypeChartThemeOverride:
                this.updateTargetWorksheetRelation(targetRelFile, element, "Target", `../theme/themeOverride${this.targetNumber}.xml`);
                break;
            }
            content_tracker_1.contentTracker.trackRelation(targetRelFile, {
              Id: element.getAttribute("Id"),
              Target: element.getAttribute("Target"),
              Type: element.getAttribute("Type")
            });
          });
          xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
      }
      updateTargetWorksheetRelation(targetRelFile, element, attribute, value) {
        element.setAttribute(attribute, value);
      }
      getTargetChartImageUri(origin) {
        const file = origin.replace("../media/", "");
        const extension = path_1.default.extname(file).replace(".", "");
        return {
          source: `ppt/media/${file}`,
          target: `ppt/media/${file}-chart-${this.targetNumber}.${extension}`,
          rel: `../media/${file}-chart-${this.targetNumber}.${extension}`,
          extension
        };
      }
      copyWorksheetFile() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetFile = `ppt/embeddings/${this.worksheetFilePrefix}${this.targetWorksheet}${this.wbExtension}`;
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/embeddings/${this.worksheetFilePrefix}${this.sourceWorksheet}${this.wbExtension}`, this.targetArchive, targetFile);
        });
      }
      appendChartExtensionToContentType() {
        return xml_helper_1.XmlHelper.appendIf(Object.assign(Object.assign({}, xml_helper_1.XmlHelper.createContentTypeChild(this.targetArchive, {
          Extension: `xlsx`,
          ContentType: `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
        })), { tag: "Default", clause: (xml) => !xml_helper_1.XmlHelper.findByAttribute(xml, "Default", "Extension", "xlsx") }));
      }
      appendChartToContentType() {
        const contentType = this.subtype === "chart" ? "application/vnd.openxmlformats-officedocument.drawingml.chart+xml" : "application/vnd.ms-office.chartex+xml";
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(this.targetArchive, {
          PartName: `/ppt/charts/${this.subtype}${this.targetNumber}.xml`,
          ContentType: contentType
        }));
      }
      appendColorToContentType() {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(this.targetArchive, {
          PartName: `/ppt/charts/colors${this.targetNumber}.xml`,
          ContentType: `application/vnd.ms-office.chartcolorstyle+xml`
        }));
      }
      appendStyleToContentType() {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(this.targetArchive, {
          PartName: `/ppt/charts/style${this.targetNumber}.xml`,
          ContentType: `application/vnd.ms-office.chartstyle+xml`
        }));
      }
      appendThemeOverrideToContentType() {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(this.targetArchive, {
          PartName: `/ppt/theme/themeOverride${this.targetNumber}.xml`,
          ContentType: `application/vnd.openxmlformats-officedocument.themeOverride+xml`
        }));
      }
      static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield xml_helper_1.XmlHelper.getRelationshipTargetsByPrefix(archive, relsPath, [
            "../charts/chart",
            "../charts/chartEx"
          ]);
        });
      }
    };
    exports2.Chart = Chart;
  }
});

// node_modules/pptx-automizer/dist/enums/element-type.js
var require_element_type = __commonJS({
  "node_modules/pptx-automizer/dist/enums/element-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ElementSubtype = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Chart"] = "Chart";
      ElementType2["Image"] = "Image";
      ElementType2["Shape"] = "Generic";
      ElementType2["OLEObject"] = "OLEObject";
      ElementType2["Hyperlink"] = "Hyperlink";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    var ElementSubtype;
    (function(ElementSubtype2) {
      ElementSubtype2["chart"] = "chart";
      ElementSubtype2["chartEx"] = "chartEx";
      ElementSubtype2["oleObject"] = "oleObject";
      ElementSubtype2["hyperlink"] = "hyperlink";
    })(ElementSubtype = exports2.ElementSubtype || (exports2.ElementSubtype = {}));
  }
});

// node_modules/pptx-automizer/dist/shapes/image.js
var require_image = __commonJS({
  "node_modules/pptx-automizer/dist/shapes/image.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Image = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var shape_1 = require_shape();
    var element_type_1 = require_element_type();
    var Image2 = class _Image extends shape_1.Shape {
      constructor(shape, targetType) {
        super(shape, targetType);
        this.sourceFile = shape.target.file.replace("../media/", "");
        this.extension = file_helper_1.FileHelper.getFileExtension(this.sourceFile);
        this.relAttribute = "r:embed";
        switch (this.extension) {
          case "svg":
            this.relRootTag = "asvg:svgBlip";
            this.relParent = (element) => element.parentNode;
            break;
          default:
            this.relRootTag = "a:blip";
            this.relParent = (element) => element.parentNode.parentNode;
            break;
        }
      }
      /*
       * It is necessary to update existing rIds for all
       * unmodified images on an added slide at first.
       */
      modifyOnAddedSlide(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.updateElementsRelId();
          return this;
        });
      }
      modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.setTargetElement();
          yield this.updateTargetElementRelId();
          this.applyImageCallbacks();
          yield this.replaceIntoSlideTree();
          return this;
        });
      }
      modifySvgRelation(targetTemplate, targetSlideNumber, targetElement) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          this.targetElement = targetElement;
          yield this.updateTargetElementRelId();
          return this;
        });
      }
      append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.setTargetElement();
          yield this.updateTargetElementRelId();
          yield this.appendToSlideTree();
          this.applyImageCallbacks();
          if (this.hasSvgBlipRelation()) {
            const relsPath = `ppt/slides/_rels/slide${this.sourceSlideNumber}.xml.rels`;
            const target = yield xml_helper_1.XmlHelper.getTargetByRelId(this.sourceArchive, relsPath, this.targetElement, "image:svg");
            yield new _Image({
              mode: "append",
              target,
              sourceArchive: this.sourceArchive,
              sourceSlideNumber: this.sourceSlideNumber,
              type: element_type_1.ElementType.Image
            }, this.targetType).modifySvgRelation(targetTemplate, targetSlideNumber, this.targetElement);
          }
          return this;
        });
      }
      /*
       * Apply all ShapeModificationCallbacks to target element.
       * Third argument this.createdRelation is necessery to directly
       * manipulate relation Target and change the image.
       */
      applyImageCallbacks() {
        this.applyCallbacks(this.callbacks, this.targetElement, this.createdRelation);
      }
      remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.removeFromSlideTree();
          return this;
        });
      }
      prepare(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTarget(targetTemplate, targetSlideNumber);
          this.targetNumber = this.targetTemplate.incrementCounter("images");
          this.targetFile = "image" + this.targetNumber + "." + this.extension;
          yield this.copyFiles();
          yield this.appendTypes();
          yield this.appendToSlideRels();
        });
      }
      copyFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/media/${this.sourceFile}`, this.targetArchive, `ppt/media/${this.targetFile}`);
        });
      }
      appendTypes() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.appendImageExtensionToContentType(this.extension);
        });
      }
      /**
       * ToDo: This will always append a new relation, and never replace an
       * existing relation. At the end of creation process, unused relations will
       * remain existing in the .xml.rels file. PowerPoint will not complain, but
       * integrity checks will not be valid by this.
       */
      appendToSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = `ppt/${this.targetType}s/_rels/${this.targetType}${this.targetSlideNumber}.xml.rels`;
          this.createdRid = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, targetRelFile);
          const attributes = {
            Id: this.createdRid,
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
            Target: `../media/image${this.targetNumber}.${this.extension}`
          };
          this.createdRelation = yield xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createRelationshipChild(this.targetArchive, targetRelFile, attributes));
        });
      }
      hasSvgBlipRelation() {
        return this.targetElement.getElementsByTagName("asvg:svgBlip").length > 0;
      }
      static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(archive, relsPath, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image");
        });
      }
    };
    exports2.Image = Image2;
  }
});

// node_modules/pptx-automizer/dist/shapes/generic.js
var require_generic = __commonJS({
  "node_modules/pptx-automizer/dist/shapes/generic.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GenericShape = void 0;
    var shape_1 = require_shape();
    var GenericShape = class extends shape_1.Shape {
      constructor(shape, targetType) {
        super(shape, targetType);
      }
      modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.replaceIntoSlideTree();
          return this;
        });
      }
      append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.appendToSlideTree();
          return this;
        });
      }
      remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.removeFromSlideTree();
          return this;
        });
      }
      prepare(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTarget(targetTemplate, targetSlideNumber);
          yield this.setTargetElement();
          this.applyCallbacks(this.callbacks, this.targetElement);
        });
      }
    };
    exports2.GenericShape = GenericShape;
  }
});

// node_modules/pptx-automizer/dist/helper/xml-slide-helper.js
var require_xml_slide_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-slide-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XmlSlideHelper = exports2.mapUriType = exports2.nsMain = void 0;
    var xml_helper_1 = require_xml_helper();
    exports2.nsMain = "http://schemas.openxmlformats.org/presentationml/2006/main";
    exports2.mapUriType = {
      "http://schemas.openxmlformats.org/drawingml/2006/table": "table",
      "http://schemas.openxmlformats.org/drawingml/2006/chart": "chart",
      "http://schemas.microsoft.com/office/drawing/2014/chartex": "chartEx",
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject": "oleObject",
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink": "hyperlink"
    };
    var XmlSlideHelper = class _XmlSlideHelper {
      /**
       * Constructor for the XmlSlideHelper class.
       * @param {XmlDocument} slideXml - The slide XML document to be used by the helper.
       * @param hasShapes
       */
      constructor(slideXml, hasShapes) {
        this.getAndExtractDimensions = (path2) => __awaiter(this, void 0, void 0, function* () {
          try {
            const xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.hasShapes.sourceTemplate.archive, path2);
            if (!xml)
              return null;
            const sldSz = xml.getElementsByTagName("p:sldSz")[0];
            if (sldSz) {
              const width = _XmlSlideHelper.parseCoordinate(sldSz, "cx");
              const height = _XmlSlideHelper.parseCoordinate(sldSz, "cy");
              return { width, height };
            }
            return null;
          } catch (error) {
            console.warn(`Error while fetching XML from path ${path2}: ${error}`);
            return null;
          }
        });
        if (!slideXml) {
          throw Error("Slide XML is not defined");
        }
        this.slideXml = slideXml;
        this.hasShapes = hasShapes;
      }
      getSlideCreationId() {
        const creationIdItem = this.slideXml.getElementsByTagName("p14:creationId").item(0);
        if (!creationIdItem) {
          return;
        }
        const creationIdSlide = creationIdItem.getAttribute("val");
        if (!creationIdSlide) {
          return;
        }
        return Number(creationIdSlide);
      }
      /**
       * Get an array of ElementInfo objects for all named elements on a slide.
       * @param selector
       */
      getElement(selector) {
        return __awaiter(this, void 0, void 0, function* () {
          const shapeNode = xml_helper_1.XmlHelper.isElementCreationId(selector) ? xml_helper_1.XmlHelper.findByCreationId(this.slideXml, selector) : xml_helper_1.XmlHelper.findByName(this.slideXml, selector);
          return _XmlSlideHelper.getElementInfo(shapeNode);
        });
      }
      /**
       * Get an array of ElementInfo objects for all named elements on a slide.
       * @param filterTags Use an array of strings to filter the output array
       */
      getAllElements(filterTags) {
        const elementInfo = [];
        try {
          const shapeNodes = this.getNamedElements(filterTags);
          shapeNodes.forEach((shapeNode) => {
            elementInfo.push(_XmlSlideHelper.getElementInfo(shapeNode));
          });
        } catch (error) {
          console.error(error);
          throw new Error(`Failed to retrieve elements: ${error.message}`);
        }
        return elementInfo;
      }
      /**
       * Get all text element IDs from the slide.
       * @return {string[]} An array of text element IDs.
       */
      getAllTextElementIds(useCreationIds) {
        const elementIds = [];
        try {
          elementIds.push(...this.getAllElements(["sp"]).filter((element) => element.hasTextBody).map((element) => useCreationIds ? element.id : element.name));
        } catch (error) {
          console.error(error);
          throw new Error(`Failed to retrieve text element IDs: ${error.message}`);
        }
        return elementIds;
      }
      static getElementInfo(slideElement) {
        return {
          name: _XmlSlideHelper.getElementName(slideElement),
          id: _XmlSlideHelper.getElementCreationId(slideElement),
          type: _XmlSlideHelper.getElementType(slideElement),
          position: _XmlSlideHelper.parseShapeCoordinates(slideElement),
          hasTextBody: !!_XmlSlideHelper.getTextBody(slideElement),
          getXmlElement: () => slideElement,
          getText: () => _XmlSlideHelper.parseTextFragments(slideElement),
          getTableInfo: () => _XmlSlideHelper.readTableInfo(slideElement),
          getAltText: () => _XmlSlideHelper.getImageAltText(slideElement)
        };
      }
      /**
       * Retrieves a list of all named elements on a slide. Automation requires at least a name.
       * @param filterTags Use an array of strings to filter the output array
       */
      getNamedElements(filterTags) {
        const skipTags = ["spTree"];
        const nvPrs = this.slideXml.getElementsByTagNameNS(exports2.nsMain, "cNvPr");
        const namedElements = [];
        xml_helper_1.XmlHelper.modifyCollection(nvPrs, (nvPr) => {
          const parentNode = nvPr.parentNode.parentNode;
          const parentTag = parentNode.localName;
          if (!skipTags.includes(parentTag) && (!(filterTags === null || filterTags === void 0 ? void 0 : filterTags.length) || filterTags.includes(parentTag))) {
            namedElements.push(parentNode);
          }
        });
        return namedElements;
      }
      static getTextBody(shapeNode) {
        return shapeNode.getElementsByTagNameNS(exports2.nsMain, "txBody").item(0);
      }
      static parseTextFragments(shapeNode) {
        const txBody = _XmlSlideHelper.getTextBody(shapeNode);
        const textFragments = [];
        const texts = txBody.getElementsByTagName("a:t");
        for (let t = 0; t < texts.length; t++) {
          textFragments.push(texts.item(t).textContent);
        }
        return textFragments;
      }
      static getNonVisibleProperties(shapeNode) {
        return shapeNode.getElementsByTagNameNS(exports2.nsMain, "cNvPr").item(0);
      }
      static getImageAltText(slideElement) {
        const cNvPr = _XmlSlideHelper.getNonVisibleProperties(slideElement);
        if (cNvPr) {
          return cNvPr.getAttribute("descr");
        }
      }
      static getElementName(slideElement) {
        const cNvPr = _XmlSlideHelper.getNonVisibleProperties(slideElement);
        if (cNvPr) {
          return cNvPr.getAttribute("name");
        }
      }
      static getElementCreationId(slideElement) {
        const cNvPr = _XmlSlideHelper.getNonVisibleProperties(slideElement);
        if (cNvPr) {
          const creationIdElement = cNvPr.getElementsByTagName("a16:creationId").item(0);
          if (creationIdElement) {
            return creationIdElement.getAttribute("id");
          }
        }
      }
      /**
       * Parses local tag name to specify element type in case it is a 'graphicFrame'.
       * @param slideElementParent
       */
      static getElementType(slideElementParent) {
        let type = slideElementParent.localName;
        switch (type) {
          case "graphicFrame":
            const graphicData = slideElementParent.getElementsByTagName("a:graphicData")[0];
            const uri = graphicData.getAttribute("uri");
            type = exports2.mapUriType[uri] ? exports2.mapUriType[uri] : type;
            break;
          case "oleObj":
            type = "OLEObject";
            break;
        }
        const hasHyperlink = slideElementParent.getElementsByTagName("a:hlinkClick");
        if (hasHyperlink.length > 0) {
          type = "Hyperlink";
        }
        return type;
      }
      static parseShapeCoordinates(slideElementParent) {
        const xFrmsA = slideElementParent.getElementsByTagName("a:xfrm");
        const xFrmsP = slideElementParent.getElementsByTagName("p:xfrm");
        const xFrms = xFrmsP.item(0) ? xFrmsP : xFrmsA;
        const position = {
          x: 0,
          y: 0,
          cx: 0,
          cy: 0
        };
        if (!xFrms.item(0)) {
          return position;
        }
        const xFrm = xFrms.item(0);
        const Off = xFrm.getElementsByTagName("a:off").item(0);
        const Ext = xFrm.getElementsByTagName("a:ext").item(0);
        position.x = _XmlSlideHelper.parseCoordinate(Off, "x");
        position.y = _XmlSlideHelper.parseCoordinate(Off, "y");
        position.cx = _XmlSlideHelper.parseCoordinate(Ext, "cx");
        position.cy = _XmlSlideHelper.parseCoordinate(Ext, "cy");
        return position;
      }
      /**
       * Asynchronously retrieves the dimensions of a slide.
       * Tries to find the dimensions from the slide XML, then from the layout, master, and presentation XMLs in order.
       *
       * @returns {Promise<{ width: number, height: number }>} The dimensions of the slide.
       * @throws Error if unable to determine dimensions.
       */
      getDimensions() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const dimensions = yield this.getAndExtractDimensions("ppt/presentation.xml");
            if (dimensions)
              return dimensions;
          } catch (error) {
            console.error(`Error while fetching slide dimensions: ${error}`);
            throw error;
          }
        });
      }
    };
    exports2.XmlSlideHelper = XmlSlideHelper;
    XmlSlideHelper.parseCoordinate = (element, attributeName) => {
      return parseInt(element.getAttribute(attributeName), 10);
    };
    XmlSlideHelper.readTableInfo = (element) => {
      const info = [];
      const rows = element.getElementsByTagName("a:tr");
      if (!rows) {
        console.error("Can't find a table row.");
        return info;
      }
      for (let r = 0; r < rows.length; r++) {
        const row = rows.item(r);
        const columns = row.getElementsByTagName("a:tc");
        for (let c = 0; c < columns.length; c++) {
          const cell = columns.item(c);
          const gridSpan = cell.getAttribute("gridSpan");
          const hMerge = cell.getAttribute("hMerge");
          const texts = cell.getElementsByTagName("a:t");
          const text = [];
          for (let t = 0; t < texts.length; t++) {
            text.push(texts.item(t).textContent);
          }
          info.push({
            row: r,
            column: c,
            rowXml: row,
            columnXml: cell,
            text,
            textContent: text.join(""),
            gridSpan: Number(gridSpan),
            hMerge: Number(hMerge)
          });
        }
      }
      return info;
    };
  }
});

// node_modules/pptx-automizer/dist/shapes/ole.js
var require_ole = __commonJS({
  "node_modules/pptx-automizer/dist/shapes/ole.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OLEObject = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var shape_1 = require_shape();
    var path_1 = __importDefault(require("path"));
    var OLEObject = class _OLEObject extends shape_1.Shape {
      constructor(shape, targetType, sourceArchive) {
        var _a;
        super(shape, targetType);
        this.sourceArchive = sourceArchive;
        this.oleObjectPath = `ppt/embeddings/${this.sourceRid}${this.getFileExtension((_a = shape.target) === null || _a === void 0 ? void 0 : _a.file)}`;
        this.relRootTag = "p:oleObj";
        this.relAttribute = "r:id";
      }
      getFileExtension(file) {
        if (!file)
          return ".bin";
        const ext = path_1.default.extname(file).toLowerCase();
        return [".bin", ".xls", ".xlsx", ".doc", ".docx", ".ppt", ".pptx"].includes(ext) ? ext : ".bin";
      }
      // NOTE: modify() and append() won't be implemented.
      // TODO: remove is not currently properly implemented,
      //  suggest we delete the file from the archive as well as removing the relationship.
      remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.removeFromSlideTree();
          yield this.removeOleObjectFile();
          yield this.removeFromContentTypes();
          yield this.removeFromSlideRels();
          return this;
        });
      }
      prepare(targetTemplate, targetSlideNumber, oleObjects) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTarget(targetTemplate, targetSlideNumber);
          const allOleObjects = oleObjects || (yield _OLEObject.getAllOnSlide(this.sourceArchive, this.targetSlideRelFile));
          const oleObject = allOleObjects.find((obj) => obj.rId === this.sourceRid);
          if (!oleObject) {
            throw new Error(`OLE object with rId ${this.sourceRid} not found.`);
          }
          const sourceFilePath = `ppt/embeddings/${oleObject.file.split("/").pop()}`;
          this.createdRid = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, this.targetSlideRelFile);
          yield this.copyOleObjectFile(sourceFilePath);
          yield this.appendToContentTypes();
          yield this.updateSlideRels();
          yield this.updateSlideXml();
        });
      }
      copyOleObjectFile(sourceFilePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const fileExtension = this.getFileExtension(sourceFilePath);
          const targetFileName = `ppt/embeddings/oleObject${this.createdRid}${fileExtension}`;
          try {
            yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, sourceFilePath, this.targetArchive, targetFileName);
          } catch (error) {
            console.error("Error copying OLE object file:", error);
            throw error;
          }
        });
      }
      appendToContentTypes() {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesPath = "[Content_Types].xml";
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, contentTypesPath);
          const types = contentTypesXml.getElementsByTagName("Types")[0];
          const fileExtension = this.getFileExtension(this.oleObjectPath);
          const partName = `/ppt/embeddings/oleObject${this.createdRid}${fileExtension}`;
          const existingOverride = Array.from(types.getElementsByTagName("Override")).find((override) => override.getAttribute("PartName") === partName);
          if (!existingOverride) {
            const newOverride = contentTypesXml.createElement("Override");
            newOverride.setAttribute("PartName", partName);
            newOverride.setAttribute("ContentType", this.getContentType(fileExtension));
            types.appendChild(newOverride);
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, contentTypesPath, contentTypesXml);
          }
        });
      }
      updateSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = `ppt/${this.targetType}s/_rels/${this.targetType}${this.targetSlideNumber}.xml.rels`;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relationships = relXml.getElementsByTagName("Relationship");
          const fileExtension = this.getFileExtension(this.oleObjectPath);
          const newTarget = `../embeddings/oleObject${this.createdRid}${fileExtension}`;
          let relationshipUpdated = false;
          for (let i = 0; i < relationships.length; i++) {
            if (relationships[i].getAttribute("Id") === this.sourceRid) {
              relationships[i].setAttribute("Id", this.createdRid);
              relationships[i].setAttribute("Target", newTarget);
              relationshipUpdated = true;
              break;
            }
          }
          if (!relationshipUpdated) {
            const newRel = relXml.createElement("Relationship");
            newRel.setAttribute("Id", this.createdRid);
            newRel.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject");
            newRel.setAttribute("Target", newTarget);
            relXml.documentElement.appendChild(newRel);
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
      }
      updateSlideXml() {
        return __awaiter(this, void 0, void 0, function* () {
          const slideXmlPath = `ppt/slides/slide${this.targetSlideNumber}.xml`;
          const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, slideXmlPath);
          const oleObjs = Array.from(slideXml.getElementsByTagName("p:oleObj"));
          oleObjs.forEach((oleObj) => {
            if (oleObj.getAttribute("r:id") === this.sourceRid) {
              oleObj.setAttribute("r:id", this.createdRid);
              const oleObjPr = oleObj.getElementsByTagName("p:oleObjPr")[0];
              if (oleObjPr) {
                const links = Array.from(oleObjPr.getElementsByTagName("a:link"));
                links.forEach((link) => {
                  link.setAttribute("r:id", this.createdRid);
                });
              }
            }
          });
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, slideXmlPath, slideXml);
        });
      }
      getContentType(fileExtension) {
        const contentTypes = {
          ".bin": "application/vnd.openxmlformats-officedocument.oleObject",
          ".xls": "application/vnd.ms-excel",
          ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          ".doc": "application/msword",
          ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
          ".ppt": "application/vnd.ms-powerpoint",
          ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation"
        };
        return contentTypes[fileExtension.toLowerCase()] || "application/vnd.openxmlformats-officedocument.oleObject";
      }
      removeOleObjectFile() {
        return __awaiter(this, void 0, void 0, function* () {
          const fileExtension = this.getFileExtension(this.oleObjectPath);
          const fileName = `ppt/embeddings/oleObject${this.createdRid}${fileExtension}`;
          yield this.targetArchive.remove(fileName);
        });
      }
      removeFromContentTypes() {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesPath = "[Content_Types].xml";
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, contentTypesPath);
          const types = contentTypesXml.getElementsByTagName("Types")[0];
          const fileExtension = this.getFileExtension(this.oleObjectPath);
          const partName = `/ppt/embeddings/oleObject${this.createdRid}${fileExtension}`;
          const overrideToRemove = Array.from(types.getElementsByTagName("Override")).find((override) => override.getAttribute("PartName") === partName);
          if (overrideToRemove) {
            types.removeChild(overrideToRemove);
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, contentTypesPath, contentTypesXml);
          }
        });
      }
      removeFromSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = `ppt/${this.targetType}s/_rels/${this.targetType}${this.targetSlideNumber}.xml.rels`;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relationships = relXml.getElementsByTagName("Relationship");
          for (let i = 0; i < relationships.length; i++) {
            if (relationships[i].getAttribute("Id") === this.createdRid) {
              relationships[i].parentNode.removeChild(relationships[i]);
              break;
            }
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
      }
      static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          const oleObjectType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject";
          return xml_helper_1.XmlHelper.getRelationshipItems(archive, relsPath, (element, rels) => {
            const type = element.getAttribute("Type");
            if (type === oleObjectType) {
              rels.push({
                rId: element.getAttribute("Id"),
                type: element.getAttribute("Type"),
                file: element.getAttribute("Target"),
                element
              });
            }
          });
        });
      }
      modifyOnAddedSlide(targetTemplate, targetSlideNumber, oleObjects) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber, oleObjects);
        });
      }
    };
    exports2.OLEObject = OLEObject;
  }
});

// node_modules/pptx-automizer/dist/shapes/hyperlink.js
var require_hyperlink = __commonJS({
  "node_modules/pptx-automizer/dist/shapes/hyperlink.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Hyperlink = void 0;
    var xml_helper_1 = require_xml_helper();
    var shape_1 = require_shape();
    var content_tracker_1 = require_content_tracker();
    var Hyperlink = class extends shape_1.Shape {
      constructor(shape, targetType, sourceArchive, hyperlinkType = "external", hyperlinkTarget = "") {
        super(shape, targetType);
        this.sourceArchive = sourceArchive;
        this.hyperlinkType = hyperlinkType;
        this.hyperlinkTarget = hyperlinkTarget;
        this.relRootTag = "a:hlinkClick";
        this.relAttribute = "r:id";
      }
      modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.editTargetHyperlinkRel();
          yield this.updateHyperlinkInSlide();
          return this;
        });
      }
      append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.setTargetElement();
          yield this.appendToSlideTree();
          yield this.editTargetHyperlinkRel();
          yield this.updateHyperlinkInSlide();
          return this;
        });
      }
      remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber);
          yield this.removeFromSlideRels();
          return this;
        });
      }
      prepare(targetTemplate, targetSlideNumber, hyperlinks) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.setTarget(targetTemplate, targetSlideNumber);
          if (!this.createdRid) {
            this.createdRid = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, this.targetSlideRelFile);
          }
        });
      }
      editTargetHyperlinkRel() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = this.targetSlideRelFile;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relationships = relXml.getElementsByTagName("Relationship");
          let relationshipExists = false;
          for (let i = 0; i < relationships.length; i++) {
            if (relationships[i].getAttribute("Id") === this.createdRid) {
              this.updateHyperlinkRelation(relationships[i]);
              relationshipExists = true;
              break;
            }
          }
          if (!relationshipExists) {
            const newRel = relXml.createElement("Relationship");
            newRel.setAttribute("Id", this.createdRid);
            newRel.setAttribute("Type", this.getRelationshipType());
            newRel.setAttribute("Target", this.getRelationshipTarget());
            if (this.hyperlinkType === "external") {
              newRel.setAttribute("TargetMode", "External");
            }
            relXml.documentElement.appendChild(newRel);
            content_tracker_1.contentTracker.trackRelation(targetRelFile, {
              Id: this.createdRid,
              Target: this.getRelationshipTarget(),
              Type: this.getRelationshipType()
            });
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
      }
      // Add a method to update the hyperlink in the slide XML
      updateHyperlinkInSlide() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.targetElement) {
            return;
          }
          const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetSlideFile);
          const runs = this.targetElement.getElementsByTagName("a:r");
          for (let i = 0; i < runs.length; i++) {
            const run = runs[i];
            const rPr = run.getElementsByTagName("a:rPr")[0];
            if (rPr) {
              const hlinkClicks = rPr.getElementsByTagName("a:hlinkClick");
              for (let j = 0; j < hlinkClicks.length; j++) {
                const hlinkClick = hlinkClicks[j];
                hlinkClick.setAttribute("r:id", this.createdRid);
                hlinkClick.setAttribute("xmlns:r", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
              }
            }
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, this.targetSlideFile, slideXml);
        });
      }
      updateHyperlinkRelation(element) {
        element.setAttribute("Type", this.getRelationshipType());
        element.setAttribute("Target", this.getRelationshipTarget());
        if (this.hyperlinkType === "external") {
          element.setAttribute("TargetMode", "External");
        } else if (element.hasAttribute("TargetMode")) {
          element.removeAttribute("TargetMode");
        }
        content_tracker_1.contentTracker.trackRelation(this.targetSlideRelFile, {
          Id: element.getAttribute("Id") || "",
          Target: this.getRelationshipTarget(),
          Type: this.getRelationshipType()
        });
      }
      getRelationshipType() {
        return "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
      }
      getRelationshipTarget() {
        if (this.hyperlinkType === "internal") {
          return this.hyperlinkTarget || `slide${this.targetSlideNumber}.xml`;
        } else {
          return this.hyperlinkTarget || "https://example.com";
        }
      }
      removeFromSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
          const targetRelFile = this.targetSlideRelFile;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relationships = relXml.getElementsByTagName("Relationship");
          for (let i = 0; i < relationships.length; i++) {
            if (relationships[i].getAttribute("Id") === this.createdRid) {
              relXml.documentElement.removeChild(relationships[i]);
              break;
            }
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
      }
      static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          const hyperlinkType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
          return xml_helper_1.XmlHelper.getRelationshipItems(archive, relsPath, (element, rels) => {
            const type = element.getAttribute("Type");
            if (type === hyperlinkType) {
              rels.push({
                rId: element.getAttribute("Id"),
                type: element.getAttribute("Type"),
                file: element.getAttribute("Target"),
                filename: element.getAttribute("Target"),
                element,
                isExternal: element.getAttribute("TargetMode") === "External"
              });
            }
          });
        });
      }
      modifyOnAddedSlide(targetTemplate, targetSlideNumber, hyperlinks) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.prepare(targetTemplate, targetSlideNumber, hyperlinks);
          if (this.target && this.target.file) {
            this.hyperlinkTarget = this.target.file;
            this.hyperlinkType = this.target.isExternal ? "external" : "internal";
          }
          const targetRelFile = this.targetSlideRelFile;
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
          const relationships = relXml.getElementsByTagName("Relationship");
          let relationshipUpdated = false;
          for (let i = 0; i < relationships.length; i++) {
            const relationship = relationships[i];
            if (relationship.getAttribute("Id") === this.sourceRid) {
              relationship.setAttribute("Id", this.createdRid);
              relationship.setAttribute("Target", this.getRelationshipTarget());
              relationship.setAttribute("Type", this.getRelationshipType());
              if (this.hyperlinkType === "external") {
                relationship.setAttribute("TargetMode", "External");
              } else if (relationship.hasAttribute("TargetMode")) {
                relationship.removeAttribute("TargetMode");
              }
              relationshipUpdated = true;
              break;
            }
          }
          if (!relationshipUpdated) {
            const newRel = relXml.createElement("Relationship");
            newRel.setAttribute("Id", this.createdRid);
            newRel.setAttribute("Type", this.getRelationshipType());
            newRel.setAttribute("Target", this.getRelationshipTarget());
            if (this.hyperlinkType === "external") {
              newRel.setAttribute("TargetMode", "External");
            }
            relXml.documentElement.appendChild(newRel);
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
          content_tracker_1.contentTracker.trackRelation(targetRelFile, {
            Id: this.createdRid,
            Target: this.getRelationshipTarget(),
            Type: this.getRelationshipType()
          });
          yield this.updateHyperlinkInSlide();
        });
      }
      // Helper method to create a hyperlink in a shape
      static addHyperlinkToShape(archive, slidePath, slideRelsPath, shapeId, hyperlinkTarget, isExternal = true) {
        return __awaiter(this, void 0, void 0, function* () {
          const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slidePath);
          const shape = xml_helper_1.XmlHelper.isElementCreationId(shapeId) ? xml_helper_1.XmlHelper.findByCreationId(slideXml, shapeId) : xml_helper_1.XmlHelper.findByName(slideXml, shapeId);
          if (!shape) {
            throw new Error(`Shape with ID/name "${shapeId}" not found`);
          }
          const relId = yield xml_helper_1.XmlHelper.getNextRelId(archive, slideRelsPath);
          const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slideRelsPath);
          const newRel = relXml.createElement("Relationship");
          newRel.setAttribute("Id", relId);
          newRel.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink");
          newRel.setAttribute("Target", hyperlinkTarget);
          if (isExternal) {
            newRel.setAttribute("TargetMode", "External");
          }
          relXml.documentElement.appendChild(newRel);
          yield xml_helper_1.XmlHelper.writeXmlToArchive(archive, slideRelsPath, relXml);
          const txBody = shape.getElementsByTagName("p:txBody")[0];
          if (txBody) {
            const paragraphs = txBody.getElementsByTagName("a:p");
            for (let i = 0; i < paragraphs.length; i++) {
              const paragraph = paragraphs[i];
              const runs = paragraph.getElementsByTagName("a:r");
              if (runs.length > 0) {
                const run = runs[0];
                const rPr = run.getElementsByTagName("a:rPr")[0];
                if (rPr) {
                  let hlinkClick = rPr.getElementsByTagName("a:hlinkClick")[0];
                  if (!hlinkClick) {
                    hlinkClick = slideXml.createElement("a:hlinkClick");
                    rPr.appendChild(hlinkClick);
                  }
                  hlinkClick.setAttribute("r:id", relId);
                  hlinkClick.setAttribute("xmlns:r", "http://schemas.openxmlformats.org/officeDocument/2006/relationships");
                }
              }
            }
          }
          yield xml_helper_1.XmlHelper.writeXmlToArchive(archive, slidePath, slideXml);
          return relId;
        });
      }
    };
    exports2.Hyperlink = Hyperlink;
  }
});

// node_modules/pptx-automizer/dist/classes/has-shapes.js
var require_has_shapes = __commonJS({
  "node_modules/pptx-automizer/dist/classes/has-shapes.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xml_relationship_helper_1 = require_xml_relationship_helper();
    var xml_helper_1 = require_xml_helper();
    var file_helper_1 = require_file_helper();
    var chart_1 = require_chart();
    var image_1 = require_image();
    var element_type_1 = require_element_type();
    var generic_1 = require_generic();
    var xml_slide_helper_1 = require_xml_slide_helper();
    var ole_1 = require_ole();
    var hyperlink_1 = require_hyperlink();
    var HasShapes = class {
      constructor(params) {
        this.unsupportedTags = [
          "p:custDataLst"
          // 'p:oleObj',
          // 'mc:AlternateContent',
          //'a14:imgProps',
        ];
        this.unsupportedRelationTypes = [
          //  'http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject',
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
          "http://schemas.openxmlformats.org/officeDocument/2006/relationships/tags"
        ];
        this.cleanupPlaceholders = false;
        this.sourceTemplate = params.template;
        this.modifications = [];
        this.relModifications = [];
        this.importElements = [];
        this.generateElements = [];
        this.status = params.presentation.status;
        this.content = params.presentation.content;
        this.cleanupPlaceholders = params.presentation.params.cleanupPlaceholders;
      }
      /**
       * Asynchronously retrieves all text element IDs from the slide.
       * @returns {Promise<string[]>} A promise that resolves to an array of text element IDs.
       */
      getAllTextElementIds() {
        return __awaiter(this, void 0, void 0, function* () {
          const xmlSlideHelper = yield this.getSlideHelper();
          return xmlSlideHelper.getAllTextElementIds(this.sourceTemplate.useCreationIds || false);
        });
      }
      /**
       * Asynchronously retrieves all elements from the slide.
       * @params filterTags Use an array of strings to filter parent tags (e.g. 'sp')
       * @returns {Promise<ElementInfo[]>} A promise that resolves to an array of ElementInfo objects.
       */
      getAllElements(filterTags) {
        return __awaiter(this, void 0, void 0, function* () {
          const xmlSlideHelper = yield this.getSlideHelper();
          return xmlSlideHelper.getAllElements(filterTags);
        });
      }
      /**
       * Asynchronously retrieves one element from the slide.
       * @params selector Use shape name or creationId to find the shape
       * @returns {Promise<ElementInfo>} A promise that resolves an ElementInfo object.
       */
      getElement(selector) {
        return __awaiter(this, void 0, void 0, function* () {
          const xmlSlideHelper = yield this.getSlideHelper();
          return xmlSlideHelper.getElement(selector);
        });
      }
      /**
       * Asynchronously retrieves the dimensions of the slide.
       * This function utilizes the XmlSlideHelper to get the slide dimensions.
       *
       * @returns {Promise<{width: number, height: number}>} A promise that resolves to an object containing the width and height of the slide.
       */
      getDimensions() {
        return __awaiter(this, void 0, void 0, function* () {
          const xmlSlideHelper = yield this.getSlideHelper();
          return xmlSlideHelper.getDimensions();
        });
      }
      /**
       * Asynchronously retrieves an instance of XmlSlideHelper for slide.
       * @returns {Promise<XmlSlideHelper>} An instance of XmlSlideHelper.
       */
      getSlideHelper() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.sourceTemplate.archive, this.sourcePath);
            return new xml_slide_helper_1.XmlSlideHelper(slideXml, this);
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      /**
       * Push modifications list
       * @internal
       * @param callback
       */
      modify(callback) {
        this.modifications.push(callback);
      }
      /**
       * Push relations modifications list
       * @internal
       * @param callback
       */
      modifyRelations(callback) {
        this.relModifications.push(callback);
      }
      /**
       * Select and modify a single element on an added slide.
       * @param {string} selector - Element's name on the slide.
       * Should be a unique string defined on the "Selection"-pane within ppt.
       * @param {ShapeModificationCallback | ShapeModificationCallback[]} callback - One or more callback functions to apply.
       * Depending on the shape type (e.g. chart or table), different arguments will be passed to the callback.
       */
      modifyElement(selector, callback) {
        const presName = this.sourceTemplate.name;
        const slideNumber = this.sourceNumber;
        this.addElementToModificationsList(presName, slideNumber, selector, "modify", callback);
        return this;
      }
      generate(generate, objectName) {
        this.generateElements.push({
          objectName,
          callback: generate
        });
        return this;
      }
      getGeneratedElements() {
        return this.generateElements;
      }
      /**
       * Select, insert and (optionally) modify a single element to a slide.
       * @param {string} presName - Filename or alias name of the template presentation.
       * Must have been importet with Automizer.load().
       * @param {number} slideNumber - Slide number within the specified template to search for the required element.
       * @param {FindElementSelector} selector - a string or object to find the target element
       * @param {ShapeModificationCallback | ShapeModificationCallback[]} callback - One or more callback functions to apply.
       * Depending on the shape type (e.g. chart or table), different arguments will be passed to the callback.
       */
      addElement(presName, slideNumber, selector, callback) {
        this.addElementToModificationsList(presName, slideNumber, selector, "append", callback);
        return this;
      }
      /**
       * Remove a single element from slide.
       * @param {string} selector - Element's name on the slide.
       */
      removeElement(selector) {
        const presName = this.sourceTemplate.name;
        const slideNumber = this.sourceNumber;
        this.addElementToModificationsList(presName, slideNumber, selector, "remove", void 0);
        return this;
      }
      /**
       * Adds element to modifications list
       * @internal
       * @param presName
       * @param slideNumber
       * @param selector
       * @param mode
       * @param [callback]
       * @returns element to modifications list
       */
      addElementToModificationsList(presName, slideNumber, selector, mode, callback) {
        this.importElements.push({
          presName,
          slideNumber,
          selector,
          mode,
          callback
        });
      }
      /**
       * ToDo: Implement creationIds as well for slideMasters
       *
       * Try to convert a given slide's creationId to corresponding slide number.
       * Used if automizer is run with useCreationIds: true
       * @internal
       * @param PresTemplate
       * @slideNumber SourceSlideIdentifier
       * @returns number
       */
      getSlideNumber(template, slideIdentifier) {
        if (template.useCreationIds === true && template.creationIds !== void 0) {
          const matchCreationId = template.creationIds.find((slideInfo) => slideInfo.id === Number(slideIdentifier));
          if (matchCreationId) {
            return matchCreationId.number;
          }
          throw "Could not find slide number for creationId: " + slideIdentifier + "@" + template.name;
        }
        return slideIdentifier;
      }
      /**
       * Imported selected elements
       * @internal
       */
      importedSelectedElements() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const element of this.importElements) {
            const info = yield this.getElementInfo(element);
            switch (info === null || info === void 0 ? void 0 : info.type) {
              case element_type_1.ElementType.Chart:
                yield new chart_1.Chart(info, this.targetType)[info.mode](this.targetTemplate, this.targetNumber, this.targetType);
                break;
              case element_type_1.ElementType.Image:
                yield new image_1.Image(info, this.targetType)[info.mode](this.targetTemplate, this.targetNumber, this.targetType);
                break;
              case element_type_1.ElementType.Shape:
                yield new generic_1.GenericShape(info, this.targetType)[info.mode](this.targetTemplate, this.targetNumber, this.targetType);
                break;
              case element_type_1.ElementType.OLEObject:
                yield new ole_1.OLEObject(info, this.targetType, this.sourceArchive)[info.mode](this.targetTemplate, this.targetNumber, this.targetType);
                break;
              case element_type_1.ElementType.Hyperlink:
                if (info.target) {
                  yield new hyperlink_1.Hyperlink(info, this.targetType, this.sourceArchive, info.target.isExternal ? "external" : "internal", info.target.file)[info.mode](this.targetTemplate, this.targetNumber);
                }
                break;
              default:
                break;
            }
          }
        });
      }
      /**
       * Gets element info
       * @internal
       * @param importElement
       * @returns element info
       */
      getElementInfo(importElement) {
        return __awaiter(this, void 0, void 0, function* () {
          const template = this.root.getTemplate(importElement.presName);
          const slideNumber = importElement.mode === "append" ? this.getSlideNumber(template, importElement.slideNumber) : importElement.slideNumber;
          let currentMode = "slideToSlide";
          if (this.targetType === "slideMaster") {
            if (importElement.mode === "append") {
              currentMode = "slideToMaster";
            } else {
              currentMode = "onMaster";
            }
          }
          const sourcePath = currentMode === "onMaster" ? `ppt/slideMasters/slideMaster${slideNumber}.xml` : `ppt/slides/slide${slideNumber}.xml`;
          const sourceRelPath = currentMode === "onMaster" ? `ppt/slideMasters/_rels/slideMaster${slideNumber}.xml.rels` : `ppt/slides/_rels/slide${slideNumber}.xml.rels`;
          const sourceArchive = yield template.archive;
          const useCreationIds = template.useCreationIds === true && template.creationIds !== void 0;
          const { sourceElement, selector, mode } = yield this.findElementOnSlide(importElement.selector, sourceArchive, sourcePath, useCreationIds);
          if (!sourceElement) {
            console.error(`Can't find element on slide ${slideNumber} in ${importElement.presName}: `);
            console.log(importElement);
            return;
          }
          const appendElementParams = yield this.analyzeElement(sourceElement, sourceArchive, sourceRelPath);
          return {
            mode: importElement.mode,
            name: selector,
            hasCreationId: mode === "findByElementCreationId",
            sourceArchive,
            sourceSlideNumber: slideNumber,
            sourceElement,
            callback: importElement.callback,
            target: appendElementParams.target,
            type: appendElementParams.type
          };
        });
      }
      /**
       * @param selector
       * @param sourceArchive
       * @param sourcePath
       * @param useCreationIds
       */
      findElementOnSlide(selector, sourceArchive, sourcePath, useCreationIds) {
        return __awaiter(this, void 0, void 0, function* () {
          const strategies = [];
          if (typeof selector === "string") {
            if (useCreationIds) {
              strategies.push({
                mode: "findByElementCreationId",
                selector
              });
            }
            strategies.push({
              mode: "findByElementName",
              selector
            });
          } else if (selector.name) {
            strategies.push({
              mode: "findByElementCreationId",
              selector: selector.creationId
            });
            strategies.push({
              mode: "findByElementName",
              selector: selector.name
            });
          }
          for (const findElement of strategies) {
            const mode = findElement.mode;
            const sourceElement = yield xml_helper_1.XmlHelper[mode](sourceArchive, sourcePath, findElement.selector);
            if (sourceElement) {
              return { sourceElement, selector: findElement.selector, mode };
            }
          }
          return { sourceElement: void 0, selector: JSON.stringify(selector) };
        });
      }
      checkIntegrity(info, assert) {
        return __awaiter(this, void 0, void 0, function* () {
          if (info || assert) {
            const masterRels = yield new xml_relationship_helper_1.XmlRelationshipHelper().initialize(this.targetArchive, `${this.targetType}${this.targetNumber}.xml.rels`, `ppt/${this.targetType}s/_rels`);
            yield masterRels.assertRelatedContent(this.sourceArchive, info, assert);
          }
        });
      }
      /**
       * Adds slide to presentation
       * @internal
       * @returns slide to presentation
       */
      addToPresentation() {
        return __awaiter(this, void 0, void 0, function* () {
          const relId = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, "ppt/_rels/presentation.xml.rels");
          yield this.appendToSlideRel(this.targetArchive, relId, this.targetNumber);
          if (this.targetType === "slide") {
            yield this.appendToSlideList(this.targetArchive, relId);
          } else if (this.targetType === "slideMaster") {
            yield this.appendToSlideMasterList(this.targetArchive, relId);
          } else if (this.targetType === "slideLayout") {
          }
          yield this.appendToContentType(this.targetArchive, this.targetNumber);
        });
      }
      /**
       * Appends to slide rel
       * @internal
       * @param rootArchive
       * @param relId
       * @param slideCount
       * @returns to slide rel
       */
      appendToSlideRel(rootArchive, relId, slideCount) {
        return xml_helper_1.XmlHelper.append({
          archive: rootArchive,
          file: `ppt/_rels/presentation.xml.rels`,
          parent: (xml) => xml.getElementsByTagName("Relationships")[0],
          tag: "Relationship",
          attributes: {
            Id: relId,
            Type: `http://schemas.openxmlformats.org/officeDocument/2006/relationships/${this.targetType}`,
            Target: `${this.targetType}s/${this.targetType}${slideCount}.xml`
          }
        });
      }
      /**
       * Appends a new slide to slide list in presentation.xml.
       * If rootArchive has no slides, a new node will be created.
       * "id"-attribute of 'p:sldId'-element must be greater than 255.
       * @internal
       * @param rootArchive
       * @param relId
       * @returns to slide list
       */
      appendToSlideList(rootArchive, relId) {
        return xml_helper_1.XmlHelper.append({
          archive: rootArchive,
          file: `ppt/presentation.xml`,
          assert: (xml) => __awaiter(this, void 0, void 0, function* () {
            if (xml.getElementsByTagName("p:sldIdLst").length === 0) {
              xml_helper_1.XmlHelper.insertAfter(xml.createElement("p:sldIdLst"), xml.getElementsByTagName("p:sldMasterIdLst")[0]);
            }
          }),
          parent: (xml) => xml.getElementsByTagName("p:sldIdLst")[0],
          tag: "p:sldId",
          attributes: {
            "r:id": relId
          }
        });
      }
      /**
       * Appends a new slide to slide list in presentation.xml.
       * If rootArchive has no slides, a new node will be created.
       * "id"-attribute of 'p:sldId'-element must be greater than 255.
       * @internal
       * @param rootArchive
       * @param relId
       * @returns to slide list
       */
      appendToSlideMasterList(rootArchive, relId) {
        return xml_helper_1.XmlHelper.append({
          archive: rootArchive,
          file: `ppt/presentation.xml`,
          parent: (xml) => xml.getElementsByTagName("p:sldMasterIdLst")[0],
          tag: "p:sldMasterId",
          attributes: {
            "r:id": relId
          }
        });
      }
      /**
       * Appends slide to content type
       * @internal
       * @param rootArchive
       * @param slideCount
       * @returns slide to content type
       */
      appendToContentType(rootArchive, count) {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(rootArchive, {
          PartName: `/ppt/${this.targetType}s/${this.targetType}${count}.xml`,
          ContentType: `application/vnd.openxmlformats-officedocument.presentationml.${this.targetType}+xml`
        }));
      }
      /**
       * slideNote numbers differ from slide numbers if presentation
       * contains slides without notes. We need to find out
       * the proper enumeration of slideNote xml files.
       * @internal
       * @returns slide note file number
       */
      getSlideNoteSourceNumber() {
        return __awaiter(this, void 0, void 0, function* () {
          const targets = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(this.sourceArchive, `ppt/slides/_rels/slide${this.sourceNumber}.xml.rels`, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide");
          if (targets.length) {
            const targetNumber = targets[0].file.replace("../notesSlides/notesSlide", "").replace(".xml", "");
            return Number(targetNumber);
          }
        });
      }
      /**
       * Copys slide note files
       * @internal
       * @returns slide note files
       */
      copySlideNoteFiles(sourceNotesNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/notesSlides/notesSlide${sourceNotesNumber}.xml`, this.targetArchive, `ppt/notesSlides/notesSlide${this.targetNumber}.xml`);
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/notesSlides/_rels/notesSlide${sourceNotesNumber}.xml.rels`, this.targetArchive, `ppt/notesSlides/_rels/notesSlide${this.targetNumber}.xml.rels`);
        });
      }
      /**
       * Updates slide note file
       * @internal
       * @returns slide note file
       */
      updateSlideNoteFile(sourceNotesNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          yield xml_helper_1.XmlHelper.replaceAttribute(this.targetArchive, `ppt/notesSlides/_rels/notesSlide${this.targetNumber}.xml.rels`, "Relationship", "Target", `../slides/slide${this.sourceNumber}.xml`, `../slides/slide${this.targetNumber}.xml`);
          yield xml_helper_1.XmlHelper.replaceAttribute(this.targetArchive, `ppt/slides/_rels/slide${this.targetNumber}.xml.rels`, "Relationship", "Target", `../notesSlides/notesSlide${sourceNotesNumber}.xml`, `../notesSlides/notesSlide${this.targetNumber}.xml`);
        });
      }
      /**
       * Appends notes to content type
       * @internal
       * @param rootArchive
       * @param slideCount
       * @returns notes to content type
       */
      appendNotesToContentType(rootArchive, slideCount) {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(rootArchive, {
          PartName: `/ppt/notesSlides/notesSlide${slideCount}.xml`,
          ContentType: `application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml`
        }));
      }
      /**
       * Copys related content
       * @internal
       * @returns related content
       */
      copyRelatedContent() {
        return __awaiter(this, void 0, void 0, function* () {
          const charts = yield chart_1.Chart.getAllOnSlide(this.sourceArchive, this.relsPath);
          for (const chart of charts) {
            yield new chart_1.Chart({
              mode: "append",
              target: chart,
              sourceArchive: this.sourceArchive,
              sourceSlideNumber: this.sourceNumber
            }, this.targetType).modifyOnAddedSlide(this.targetTemplate, this.targetNumber);
          }
          const images = yield image_1.Image.getAllOnSlide(this.sourceArchive, this.relsPath);
          for (const image of images) {
            yield new image_1.Image({
              mode: "append",
              target: image,
              sourceArchive: this.sourceArchive,
              sourceSlideNumber: this.sourceNumber
            }, this.targetType).modifyOnAddedSlide(this.targetTemplate, this.targetNumber);
          }
          const oleObjects = yield ole_1.OLEObject.getAllOnSlide(this.sourceArchive, this.relsPath);
          for (const oleObject of oleObjects) {
            yield new ole_1.OLEObject({
              mode: "append",
              target: oleObject,
              sourceArchive: this.sourceArchive,
              sourceSlideNumber: this.sourceNumber
            }, this.targetType, this.sourceArchive).modifyOnAddedSlide(this.targetTemplate, this.targetNumber, oleObjects);
          }
          const hyperlinks = yield hyperlink_1.Hyperlink.getAllOnSlide(this.sourceArchive, this.relsPath);
          for (const hyperlink of hyperlinks) {
            const hyperlinkInstance = new hyperlink_1.Hyperlink({
              mode: "append",
              target: hyperlink,
              sourceArchive: this.sourceArchive,
              sourceSlideNumber: this.sourceNumber
            }, this.targetType, this.sourceArchive, hyperlink.isExternal ? "external" : "internal", hyperlink.file);
            hyperlinkInstance.target = hyperlink;
            yield hyperlinkInstance.modifyOnAddedSlide(this.targetTemplate, this.targetNumber, hyperlinks);
          }
        });
      }
      /**
       * Analyzes element
       * @internal
       * @param sourceElement
       * @param sourceArchive
       * @param slideNumber
       * @returns element
       */
      analyzeElement(sourceElement, sourceArchive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          const isChart = sourceElement.getElementsByTagName("c:chart");
          if (isChart.length) {
            const target = yield xml_helper_1.XmlHelper.getTargetByRelId(sourceArchive, relsPath, sourceElement, "chart");
            return {
              type: element_type_1.ElementType.Chart,
              target
            };
          }
          const isChartEx = sourceElement.getElementsByTagName("cx:chart");
          if (isChartEx.length) {
            const target = yield xml_helper_1.XmlHelper.getTargetByRelId(sourceArchive, relsPath, sourceElement, "chartEx");
            return {
              type: element_type_1.ElementType.Chart,
              target
            };
          }
          const isImage = sourceElement.getElementsByTagName("p:nvPicPr");
          if (isImage.length) {
            return {
              type: element_type_1.ElementType.Image,
              target: yield xml_helper_1.XmlHelper.getTargetByRelId(sourceArchive, relsPath, sourceElement, "image")
            };
          }
          const isOLEObject = sourceElement.getElementsByTagName("p:oleObj");
          if (isOLEObject.length) {
            const target = yield xml_helper_1.XmlHelper.getTargetByRelId(sourceArchive, relsPath, sourceElement, "oleObject");
            return {
              type: element_type_1.ElementType.OLEObject,
              target
            };
          }
          const hasHyperlink = this.findHyperlinkInElement(sourceElement);
          if (hasHyperlink) {
            try {
              const target = yield xml_helper_1.XmlHelper.getTargetByRelId(sourceArchive, relsPath, sourceElement, "hyperlink");
              return {
                type: element_type_1.ElementType.Hyperlink,
                target,
                element: sourceElement
              };
            } catch (error) {
              console.warn("Error finding hyperlink target:", error);
            }
          }
          return {
            type: element_type_1.ElementType.Shape
          };
        });
      }
      // Helper method to find hyperlinks in an element
      findHyperlinkInElement(element) {
        const directHyperlinks = element.getElementsByTagName("a:hlinkClick");
        if (directHyperlinks.length > 0) {
          return true;
        }
        const textRuns = element.getElementsByTagName("a:r");
        for (let i = 0; i < textRuns.length; i++) {
          const run = textRuns[i];
          const rPr = run.getElementsByTagName("a:rPr")[0];
          if (rPr && rPr.getElementsByTagName("a:hlinkClick").length > 0) {
            return true;
          }
        }
        return false;
      }
      /**
       * Applys modifications
       * @internal
       * @returns modifications
       */
      applyModifications() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const modification of this.modifications) {
            const xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetPath);
            modification(xml);
            xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, this.targetPath, xml);
          }
        });
      }
      /**
       * Apply modifications to slide relations
       * @internal
       * @returns modifications
       */
      applyRelModifications() {
        return __awaiter(this, void 0, void 0, function* () {
          yield xml_helper_1.XmlHelper.modifyXmlInArchive(this.targetArchive, `ppt/${this.targetType}s/_rels/${this.targetType}${this.targetNumber}.xml.rels`, this.relModifications);
        });
      }
      /**
       * Removes all unsupported tags from slide xml.
       * E.g. added relations & tags by Thinkcell cannot
       * be processed by pptx-automizer at the moment.
       * @internal
       */
      cleanSlide(targetPath, sourcePlaceholderTypes) {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetPath);
          if (this.cleanupPlaceholders && sourcePlaceholderTypes) {
            this.removeDuplicatePlaceholders(xml, sourcePlaceholderTypes);
            this.normalizePlaceholderShapes(xml, sourcePlaceholderTypes);
          }
          this.unsupportedTags.forEach((tag) => {
            const drop = xml.getElementsByTagName(tag);
            const length = drop.length;
            if (length && length > 0) {
              xml_helper_1.XmlHelper.sliceCollection(drop, 0);
            }
          });
          xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetPath, xml);
        });
      }
      /**
       * If you insert a placeholder shape on a target slide with an empty
       * placeholder of the same type, we need to remove the existing
       * placeholder.
       *
       * @param xml
       * @param sourcePlaceholderTypes
       */
      removeDuplicatePlaceholders(xml, sourcePlaceholderTypes) {
        const placeholders = xml.getElementsByTagName("p:ph");
        const usedTypes = {};
        xml_helper_1.XmlHelper.modifyCollection(placeholders, (placeholder) => {
          const type = placeholder.getAttribute("type");
          usedTypes[type] = usedTypes[type] || 0;
          usedTypes[type]++;
        });
        for (const usedType in usedTypes) {
          const count = usedTypes[usedType];
          if (count > 1) {
            const removePlaceholders = sourcePlaceholderTypes.filter((sourcePlaceholder) => sourcePlaceholder.type === usedType);
            removePlaceholders.forEach((removePlaceholder) => {
              const parentShapeTag = "p:sp";
              const parentShape = xml_helper_1.XmlHelper.getClosestParent(parentShapeTag, removePlaceholder.xml);
              if (parentShape) {
                xml_helper_1.XmlHelper.remove(parentShape);
              }
            });
          }
        }
      }
      /**
       * If a placeholder shape was inserted on a slide without a corresponding
       * placeholder, powerPoint will usually smash the shape's formatting.
       * This function removes the placeholder tag.
       * @param xml
       * @param sourcePlaceholderTypes
       */
      normalizePlaceholderShapes(xml, sourcePlaceholderTypes) {
        const placeholders = xml.getElementsByTagName("p:ph");
        xml_helper_1.XmlHelper.modifyCollection(placeholders, (placeholder) => {
          const usedType = placeholder.getAttribute("type");
          const existingPlaceholder = sourcePlaceholderTypes.find((sourcePlaceholder) => sourcePlaceholder.type === usedType);
          if (!existingPlaceholder) {
            xml_helper_1.XmlHelper.remove(placeholder);
          }
        });
      }
      /**
       * Removes all unsupported relations from _rels xml.
       * @internal
       */
      cleanRelations(targetRelsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          yield xml_helper_1.XmlHelper.removeIf({
            archive: this.targetArchive,
            file: targetRelsPath,
            tag: "Relationship",
            clause: (xml, item) => {
              return this.unsupportedRelationTypes.includes(item.getAttribute("Type"));
            }
          });
        });
      }
      parsePlaceholders() {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetPath);
          const placeholderTypes = [];
          const placeholders = xml.getElementsByTagName("p:ph");
          xml_helper_1.XmlHelper.modifyCollection(placeholders, (placeholder) => {
            placeholderTypes.push({
              type: placeholder.getAttribute("type"),
              id: placeholder.getAttribute("id"),
              xml: placeholder
            });
          });
          return placeholderTypes;
        });
      }
    };
    exports2.default = HasShapes;
  }
});

// node_modules/pptx-automizer/dist/classes/layout.js
var require_layout = __commonJS({
  "node_modules/pptx-automizer/dist/classes/layout.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Layout = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var xml_relationship_helper_1 = require_xml_relationship_helper();
    var has_shapes_1 = __importDefault(require_has_shapes());
    var general_helper_1 = require_general_helper();
    var Layout = class extends has_shapes_1.default {
      constructor(params) {
        super(params);
        this.targetType = "slideLayout";
        this.sourceNumber = Number(params.sourceIdentifier);
        this.targetMaster = params.targetMaster;
        this.sourcePath = `ppt/slideLayouts/slideLayout${this.sourceNumber}.xml`;
        this.relsPath = `ppt/slideLayouts/_rels/slideLayout${this.sourceNumber}.xml.rels`;
      }
      /**
       * Appends slideLayout
       * @internal
       * @param targetTemplate
       * @returns append
       */
      append(targetTemplate) {
        return __awaiter(this, void 0, void 0, function* () {
          this.targetTemplate = targetTemplate;
          this.targetArchive = yield targetTemplate.archive;
          this.targetNumber = targetTemplate.incrementCounter("layouts");
          this.targetPath = `ppt/slideLayouts/slideLayout${this.targetNumber}.xml`;
          this.targetRelsPath = `ppt/slideLayouts/_rels/slideLayout${this.targetNumber}.xml.rels`;
          this.sourceArchive = yield this.sourceTemplate.archive;
          (0, general_helper_1.log)("Importing slideLayout " + this.targetNumber, 2);
          yield this.copySlideLayoutFiles();
          yield this.copyRelatedContent();
          yield this.addToPresentation();
          yield this.updateRelation();
          yield this.cleanSlide(this.targetPath);
          yield this.cleanRelations(this.targetRelsPath);
          yield this.checkIntegrity(true, true);
        });
      }
      /**
       * Copys slide layout files
       * @internal
       */
      copySlideLayoutFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slideLayouts/slideLayout${this.sourceNumber}.xml`, this.targetArchive, `ppt/slideLayouts/slideLayout${this.targetNumber}.xml`);
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slideLayouts/_rels/slideLayout${this.sourceNumber}.xml.rels`, this.targetArchive, `ppt/slideLayouts/_rels/slideLayout${this.targetNumber}.xml.rels`);
        });
      }
      updateRelation() {
        return __awaiter(this, void 0, void 0, function* () {
          const layoutToMaster = yield new xml_relationship_helper_1.XmlRelationshipHelper().initialize(this.targetArchive, `slideLayout${this.targetNumber}.xml.rels`, `ppt/slideLayouts/_rels`, "../slideMasters/slideMaster");
          layoutToMaster[0].updateTargetIndex(this.targetMaster);
        });
      }
      getName() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const slideLayoutXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.sourceArchive, `ppt/slideLayouts/slideLayout${this.sourceNumber}.xml`);
          const layout = (_a = slideLayoutXml.getElementsByTagName("p:cSld")) === null || _a === void 0 ? void 0 : _a.item(0);
          if (layout) {
            const name = layout.getAttribute("name");
            return name;
          }
        });
      }
    };
    exports2.Layout = Layout;
  }
});

// node_modules/pptx-automizer/dist/classes/master.js
var require_master = __commonJS({
  "node_modules/pptx-automizer/dist/classes/master.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Master = void 0;
    var file_helper_1 = require_file_helper();
    var xml_helper_1 = require_xml_helper();
    var xml_relationship_helper_1 = require_xml_relationship_helper();
    var has_shapes_1 = __importDefault(require_has_shapes());
    var layout_1 = require_layout();
    var general_helper_1 = require_general_helper();
    var Master = class _Master extends has_shapes_1.default {
      constructor(params) {
        super(params);
        this.targetType = "slideMaster";
        this.sourceNumber = Number(params.sourceIdentifier);
        this.key = _Master.getKey(this.sourceNumber, params.template.name);
        this.sourcePath = `ppt/slideMasters/slideMaster${this.sourceNumber}.xml`;
        this.relsPath = `ppt/slideMasters/_rels/slideMaster${this.sourceNumber}.xml.rels`;
      }
      static getKey(slideLayoutNumber, templateName) {
        return slideLayoutNumber + "@" + templateName;
      }
      /**
       * Appends slide
       * @internal
       * @param targetTemplate
       * @returns append
       */
      append(targetTemplate) {
        return __awaiter(this, void 0, void 0, function* () {
          this.targetTemplate = targetTemplate;
          this.targetArchive = yield targetTemplate.archive;
          this.targetNumber = targetTemplate.incrementCounter("masters");
          this.targetPath = `ppt/slideMasters/slideMaster${this.targetNumber}.xml`;
          this.targetRelsPath = `ppt/slideMasters/_rels/slideMaster${this.targetNumber}.xml.rels`;
          this.sourceArchive = yield this.sourceTemplate.archive;
          (0, general_helper_1.log)("Importing slideMaster " + this.targetNumber, 2);
          yield this.copySlideMasterFiles();
          yield this.copyRelatedLayouts();
          yield this.copyRelatedContent();
          yield this.addToPresentation();
          yield this.copyThemeFiles();
          if (this.importElements.length) {
            yield this.importedSelectedElements();
          }
          yield this.applyModifications();
          yield this.applyRelModifications();
          const info = this.targetTemplate.automizer.params.showIntegrityInfo;
          const assert = this.targetTemplate.automizer.params.showIntegrityInfo;
          yield this.checkIntegrity(info, assert);
          yield this.cleanSlide(this.targetPath);
        });
      }
      copyRelatedLayouts() {
        return __awaiter(this, void 0, void 0, function* () {
          const targets = yield new xml_relationship_helper_1.XmlRelationshipHelper().initialize(this.targetArchive, `slideMaster${this.targetNumber}.xml.rels`, `ppt/slideMasters/_rels`, "../slideLayouts/slideLayout");
          for (const target of targets) {
            const layout = new layout_1.Layout({
              presentation: this.targetTemplate.automizer,
              template: this.sourceTemplate,
              sourceIdentifier: target.number,
              targetMaster: this.targetNumber
            });
            yield this.targetTemplate.appendLayout(layout);
            const layoutName = yield layout.getName();
            this.targetTemplate.mapContents("slideLayout", this.sourceTemplate.name, target.number, layout.targetNumber, layoutName);
            target.updateTargetIndex(layout.targetNumber);
          }
          return targets;
        });
      }
      copyThemeFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          const targets = yield xml_helper_1.XmlHelper.getRelationshipTargetsByPrefix(this.targetArchive, `ppt/slideMasters/_rels/slideMaster${this.targetNumber}.xml.rels`, "../theme/theme");
          if (!targets.length) {
            return;
          }
          const themeTarget = targets[0];
          const themeSourceId = themeTarget.number;
          const themeTargetId = this.targetTemplate.incrementCounter("themes");
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/theme/theme${themeSourceId}.xml`, this.targetArchive, `ppt/theme/theme${themeTargetId}.xml`);
          yield this.appendThemeToContentType(this.targetArchive, themeTargetId);
          yield xml_helper_1.XmlHelper.replaceAttribute(this.targetArchive, `ppt/slideMasters/_rels/slideMaster${this.targetNumber}.xml.rels`, "Relationship", "Id", themeTarget.rId, `../theme/theme${themeTargetId}.xml`, "Target");
        });
      }
      /**
       * Copy slide master files
       * @internal
       */
      copySlideMasterFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slideMasters/slideMaster${this.sourceNumber}.xml`, this.targetArchive, `ppt/slideMasters/slideMaster${this.targetNumber}.xml`);
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slideMasters/_rels/slideMaster${this.sourceNumber}.xml.rels`, this.targetArchive, `ppt/slideMasters/_rels/slideMaster${this.targetNumber}.xml.rels`);
        });
      }
      appendThemeToContentType(rootArchive, themeCount) {
        return xml_helper_1.XmlHelper.append(xml_helper_1.XmlHelper.createContentTypeChild(rootArchive, {
          PartName: `/ppt/theme/theme${themeCount}.xml`,
          ContentType: `application/vnd.openxmlformats-officedocument.theme+xml`
        }));
      }
    };
    exports2.Master = Master;
  }
});

// node_modules/pptx-automizer/dist/classes/slide.js
var require_slide = __commonJS({
  "node_modules/pptx-automizer/dist/classes/slide.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Slide = void 0;
    var file_helper_1 = require_file_helper();
    var general_helper_1 = require_general_helper();
    var xml_relationship_helper_1 = require_xml_relationship_helper();
    var has_shapes_1 = __importDefault(require_has_shapes());
    var master_1 = require_master();
    var Slide = class extends has_shapes_1.default {
      constructor(params) {
        super(params);
        this.targetType = "slide";
        this.sourceNumber = this.getSlideNumber(params.template, params.slideIdentifier);
        this.sourcePath = `ppt/slides/slide${this.sourceNumber}.xml`;
        this.relsPath = `ppt/slides/_rels/slide${this.sourceNumber}.xml.rels`;
      }
      /**
       * Appends slide
       * @internal
       * @param targetTemplate
       * @returns append
       */
      append(targetTemplate) {
        return __awaiter(this, void 0, void 0, function* () {
          this.targetTemplate = targetTemplate;
          this.targetArchive = yield targetTemplate.archive;
          this.targetNumber = targetTemplate.incrementCounter("slides");
          this.targetPath = `ppt/slides/slide${this.targetNumber}.xml`;
          this.targetRelsPath = `ppt/slides/_rels/slide${this.targetNumber}.xml.rels`;
          this.sourceArchive = yield this.sourceTemplate.archive;
          this.status.info = "Appending slide " + this.targetNumber;
          yield this.copySlideFiles();
          yield this.copyRelatedContent();
          yield this.addToPresentation();
          const sourceNotesNumber = yield this.getSlideNoteSourceNumber();
          if (sourceNotesNumber) {
            yield this.copySlideNoteFiles(sourceNotesNumber);
            yield this.updateSlideNoteFile(sourceNotesNumber);
            yield this.appendNotesToContentType(this.targetArchive, this.targetNumber);
          }
          const placeholderTypes = yield this.parsePlaceholders();
          if (this.importElements.length) {
            yield this.importedSelectedElements();
          }
          yield this.applyModifications();
          yield this.applyRelModifications();
          const info = this.targetTemplate.automizer.params.showIntegrityInfo;
          const assert = this.targetTemplate.automizer.params.showIntegrityInfo;
          yield this.checkIntegrity(info, assert);
          yield this.cleanSlide(this.targetPath, placeholderTypes);
          this.status.increment();
        });
      }
      /**
       * Use another slide layout.
       * @param targetLayoutId
       */
      useSlideLayout(layoutId) {
        this.relModifications.push((slideRelXml) => __awaiter(this, void 0, void 0, function* () {
          let targetLayoutId;
          if (typeof layoutId === "string") {
            targetLayoutId = yield this.useNamedSlideLayout(layoutId);
            if (!targetLayoutId) {
              layoutId = null;
            }
          }
          if (!layoutId || typeof layoutId === "number") {
            targetLayoutId = yield this.useIndexedSlideLayout(layoutId);
          }
          const slideLayouts = new xml_relationship_helper_1.XmlRelationshipHelper(slideRelXml).readTargets().getTargetsByPrefix("../slideLayouts/slideLayout");
          if (slideLayouts.length) {
            slideLayouts[0].updateTargetIndex(targetLayoutId);
          }
        }));
        return this;
      }
      /**
       * Find another slide layout by name.
       * @param targetLayoutName
       */
      useNamedSlideLayout(targetLayoutName) {
        return __awaiter(this, void 0, void 0, function* () {
          const templateName = this.sourceTemplate.name;
          const sourceLayoutId = yield xml_relationship_helper_1.XmlRelationshipHelper.getSlideLayoutNumber(this.sourceArchive, this.sourceNumber);
          yield this.autoImportSourceSlideMaster(templateName, sourceLayoutId);
          const alreadyImported = this.targetTemplate.getNamedMappedContent("slideLayout", targetLayoutName);
          if (!alreadyImported) {
            console.error('Could not find "' + targetLayoutName + '"@' + templateName + "@sourceLayoutId:" + sourceLayoutId);
          }
          return alreadyImported === null || alreadyImported === void 0 ? void 0 : alreadyImported.targetId;
        });
      }
      /**
       * Use another slide layout by index or detect original index.
       * @param targetLayoutIndex
       */
      useIndexedSlideLayout(targetLayoutIndex) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!targetLayoutIndex) {
            const sourceLayoutId = yield xml_relationship_helper_1.XmlRelationshipHelper.getSlideLayoutNumber(this.sourceArchive, this.sourceNumber);
            const templateName = this.sourceTemplate.name;
            const alreadyImported = this.targetTemplate.getMappedContent("slideLayout", templateName, sourceLayoutId);
            if (alreadyImported) {
              return alreadyImported.targetId;
            } else {
              return yield this.autoImportSourceSlideMaster(templateName, sourceLayoutId);
            }
          }
          return targetLayoutIndex;
        });
      }
      autoImportSourceSlideMaster(templateName, sourceLayoutId) {
        return __awaiter(this, void 0, void 0, function* () {
          const sourceMasterId = yield xml_relationship_helper_1.XmlRelationshipHelper.getSlideMasterNumber(this.sourceArchive, sourceLayoutId);
          const key = master_1.Master.getKey(sourceMasterId, templateName);
          if (!this.targetTemplate.masters.find((master) => master.key === key)) {
            yield this.targetTemplate.automizer.addMaster(templateName, sourceMasterId);
            const previouslyAddedMaster = (0, general_helper_1.last)(this.targetTemplate.masters);
            yield this.targetTemplate.appendMasterSlide(previouslyAddedMaster).catch((e) => {
              throw e;
            });
          }
          const alreadyImported = this.targetTemplate.getMappedContent("slideLayout", templateName, sourceLayoutId);
          return alreadyImported === null || alreadyImported === void 0 ? void 0 : alreadyImported.targetId;
        });
      }
      /**
       * Copys slide files
       * @internal
       */
      copySlideFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slides/slide${this.sourceNumber}.xml`, this.targetArchive, `ppt/slides/slide${this.targetNumber}.xml`);
          yield file_helper_1.FileHelper.zipCopy(this.sourceArchive, `ppt/slides/_rels/slide${this.sourceNumber}.xml.rels`, this.targetArchive, `ppt/slides/_rels/slide${this.targetNumber}.xml.rels`);
        });
      }
    };
    exports2.Slide = Slide;
  }
});

// node_modules/pptx-automizer/dist/helper/count-helper.js
var require_count_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/count-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CountHelper = void 0;
    var xml_helper_1 = require_xml_helper();
    var CountHelper = class _CountHelper {
      constructor(name, template) {
        this.name = name;
        this.template = template;
      }
      static increment(name, counters) {
        return _CountHelper.getCounterByName(name, counters)._increment();
      }
      static count(name, counters) {
        return _CountHelper.getCounterByName(name, counters).get();
      }
      static reset(counters) {
        counters.forEach((counter) => counter.count = void 0);
      }
      static getCounterByName(name, counters) {
        const counter = counters.find((c) => c.name === name);
        if (counter === void 0) {
          throw new Error(`Counter ${name} not found.`);
        }
        return counter;
      }
      _increment() {
        this.count++;
        return this.count;
      }
      set() {
        return __awaiter(this, void 0, void 0, function* () {
          this.count = yield this.calculateCount(yield this.template.archive);
        });
      }
      get() {
        return this.count;
      }
      calculateCount(presentation) {
        switch (this.name) {
          case "slides":
            return _CountHelper.countSlides(presentation);
          case "masters":
            return _CountHelper.countMasters(presentation);
          case "layouts":
            return _CountHelper.countLayouts(presentation);
          case "themes":
            return _CountHelper.countThemes(presentation);
          case "charts":
            return _CountHelper.countCharts(presentation);
          case "images":
            return _CountHelper.countImages(presentation);
          case "oleObjects":
            return _CountHelper.countOleObjects(presentation);
        }
        throw new Error(`No way to count ${this.name}.`);
      }
      static countSlides(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const presentationXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "ppt/presentation.xml");
          return presentationXml.getElementsByTagName("p:sldId").length;
        });
      }
      static countMasters(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const presentationXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "ppt/presentation.xml");
          return presentationXml.getElementsByTagName("p:sldMasterId").length;
        });
      }
      static countLayouts(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "[Content_Types].xml");
          const overrides = contentTypesXml.getElementsByTagName("Override");
          return Object.keys(overrides).map((key) => overrides[key]).filter((o) => o.getAttribute && o.getAttribute("ContentType") === `application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml`).length;
        });
      }
      static countThemes(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "[Content_Types].xml");
          const overrides = contentTypesXml.getElementsByTagName("Override");
          return Object.keys(overrides).map((key) => overrides[key]).filter((o) => o.getAttribute && o.getAttribute("ContentType") === `application/vnd.openxmlformats-officedocument.theme+xml`).length;
        });
      }
      static countCharts(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "[Content_Types].xml");
          const overrides = contentTypesXml.getElementsByTagName("Override");
          return Object.keys(overrides).map((key) => overrides[key]).filter((o) => o.getAttribute && o.getAttribute("ContentType") === `application/vnd.openxmlformats-officedocument.drawingml.chart+xml`).length;
        });
      }
      static countOleObjects(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const contentTypesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(presentation, "[Content_Types].xml");
          const overrides = contentTypesXml.getElementsByTagName("Override");
          return Object.keys(overrides).map((key) => overrides[key]).filter((o) => o.getAttribute && o.getAttribute("ContentType") === `application/vnd.openxmlformats-officedocument.oleObject`).length;
        });
      }
      static countImages(presentation) {
        return __awaiter(this, void 0, void 0, function* () {
          const mediaFiles = yield presentation.folder("ppt/media");
          const count = mediaFiles.filter((file) => file.relativePath.indexOf("image") === 0).length;
          return count;
        });
      }
    };
    exports2.CountHelper = CountHelper;
  }
});

// node_modules/pptx-automizer/dist/helper/xml-template-helper.js
var require_xml_template_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-template-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XmlTemplateHelper = void 0;
    var xml_helper_1 = require_xml_helper();
    var xml_relationship_helper_1 = require_xml_relationship_helper();
    var xml_slide_helper_1 = require_xml_slide_helper();
    var XmlTemplateHelper = class {
      constructor(archive) {
        this.relType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide";
        this.relTypeNotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide";
        this.archive = archive;
        this.path = "ppt/_rels/presentation.xml.rels";
        this.defaultSlideName = "untitled";
      }
      getCreationIds() {
        return __awaiter(this, void 0, void 0, function* () {
          const archive = this.archive;
          const relationships = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(archive, this.path, this.relType);
          const creationIds = [];
          for (const slideRel of relationships) {
            try {
              const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, "ppt/" + slideRel.file);
              if (!slideXml) {
                console.warn(`slideXml is undefined for file ${slideRel.file}`);
                continue;
              }
              const slideHelper = new xml_slide_helper_1.XmlSlideHelper(slideXml);
              const creationIdSlide = slideHelper.getSlideCreationId();
              if (!creationIdSlide) {
                console.warn(`No creationId found in ${slideRel.file}`);
              }
              const slideInfo = yield this.getSlideInfo(slideXml, archive, slideRel.file);
              creationIds.push({
                id: creationIdSlide,
                number: this.parseSlideRelFile(slideRel.file),
                elements: slideHelper.getAllElements(),
                info: slideInfo
              });
            } catch (err) {
              console.error(`An error occurred while processing ${slideRel.file}:`, err);
            }
          }
          return creationIds.sort((slideA, slideB) => slideA.number < slideB.number ? -1 : 1);
        });
      }
      parseSlideRelFile(slideRelFile) {
        return Number(slideRelFile.replace("slides/slide", "").replace(".xml", ""));
      }
      getSlideInfo(slideXml, archive, slideRelFile) {
        return __awaiter(this, void 0, void 0, function* () {
          let name;
          const slideNoteRels = yield this.getSlideNoteRels(archive, slideRelFile);
          if (slideNoteRels.length > 0) {
            name = yield this.getSlideNameFromNotes(archive, slideNoteRels);
          }
          if (!name) {
            name = this.getNameFromSlideInfo(slideXml);
          }
          name = !name ? this.defaultSlideName : name;
          return {
            name
          };
        });
      }
      getNameFromSlideInfo(slideXml) {
        const slideTitle = slideXml.getElementsByTagName("p:ph");
        if (slideTitle.length && slideTitle[0].getAttribute("type") === "title") {
          const titleElement = slideTitle[0].parentNode.parentNode.parentNode;
          const nameFragments = this.parseTitleElement(titleElement);
          if (nameFragments.length) {
            return nameFragments.join(" ");
          }
        }
      }
      getSlideNoteRels(archive, slideRelFile) {
        return __awaiter(this, void 0, void 0, function* () {
          const relFileName = slideRelFile.replace("slides", "");
          const slideRels = yield xml_helper_1.XmlHelper.getTargetsByRelationshipType(archive, `ppt/slides/_rels${relFileName}.rels`, this.relTypeNotes);
          return slideRels;
        });
      }
      getSlideNameFromNotes(archive, slideNoteRels) {
        return __awaiter(this, void 0, void 0, function* () {
          const notesFile = slideNoteRels[0].file.replace("../", "");
          const notesXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, "ppt/" + notesFile);
          const titleElements = notesXml.getElementsByTagName("a:p");
          if (titleElements.length > 0) {
            const nameFragments = this.parseTitleElement(titleElements[0]);
            if (nameFragments.length) {
              return nameFragments.join("");
            }
          }
        });
      }
      parseTitleElement(titleElement) {
        var _a;
        const nameFragments = [];
        const titleText = titleElement.getElementsByTagName("a:t");
        if (titleText.length) {
          for (const titleTextNode in titleText) {
            if ((_a = titleText[titleTextNode].firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) {
              nameFragments.push(titleText[titleTextNode].firstChild.nodeValue);
            }
          }
        }
        return nameFragments;
      }
      /**
       * Returns the slide numbers of a given template as a sorted array of integers.
       * @returns {Promise<number[]>} - A promise that resolves to a sorted array of slide numbers in the template.
       */
      getAllSlideNumbers() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const archive = this.archive;
            const xmlRelationshipHelper = new xml_relationship_helper_1.XmlRelationshipHelper();
            const allSlides = yield xmlRelationshipHelper.initialize(archive, "presentation.xml.rels", "ppt/_rels", "slides/slide");
            const slideNumbers = allSlides.map((slide) => slide.number);
            slideNumbers.sort((a, b) => a - b);
            return slideNumbers;
          } catch (error) {
            throw new Error(`Error getting slide numbers: ${error.message}`);
          }
        });
      }
    };
    exports2.XmlTemplateHelper = XmlTemplateHelper;
  }
});

// node_modules/pptxgenjs/dist/pptxgen.cjs.js
var require_pptxgen_cjs = __commonJS({
  "node_modules/pptxgenjs/dist/pptxgen.cjs.js"(exports2, module2) {
    "use strict";
    var JSZip = require_lib4();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var JSZip__default = /* @__PURE__ */ _interopDefaultLegacy(JSZip);
    var __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    var EMU = 914400;
    var ONEPT = 12700;
    var CRLF = "\r\n";
    var LAYOUT_IDX_SERIES_BASE = 2147483649;
    var REGEX_HEX_COLOR = /^[0-9a-fA-F]{6}$/;
    var LINEH_MODIFIER = 1.67;
    var DEF_BULLET_MARGIN = 27;
    var DEF_CELL_BORDER = { type: "solid", color: "666666", pt: 1 };
    var DEF_CELL_MARGIN_IN = [0.05, 0.1, 0.05, 0.1];
    var DEF_CHART_BORDER = { type: "solid", color: "363636", pt: 1 };
    var DEF_CHART_GRIDLINE = { color: "888888", style: "solid", size: 1, cap: "flat" };
    var DEF_FONT_COLOR = "000000";
    var DEF_FONT_SIZE = 12;
    var DEF_FONT_TITLE_SIZE = 18;
    var DEF_PRES_LAYOUT = "LAYOUT_16x9";
    var DEF_PRES_LAYOUT_NAME = "DEFAULT";
    var DEF_SHAPE_LINE_COLOR = "333333";
    var DEF_SHAPE_SHADOW = { type: "outer", blur: 3, offset: 23e3 / 12700, angle: 90, color: "000000", opacity: 0.35, rotateWithShape: true };
    var DEF_SLIDE_MARGIN_IN = [0.5, 0.5, 0.5, 0.5];
    var DEF_TEXT_SHADOW = { type: "outer", blur: 8, offset: 4, angle: 270, color: "000000", opacity: 0.75 };
    var DEF_TEXT_GLOW = { size: 8, color: "FFFFFF", opacity: 0.75 };
    var AXIS_ID_VALUE_PRIMARY = "2094734552";
    var AXIS_ID_VALUE_SECONDARY = "2094734553";
    var AXIS_ID_CATEGORY_PRIMARY = "2094734554";
    var AXIS_ID_CATEGORY_SECONDARY = "2094734555";
    var AXIS_ID_SERIES_PRIMARY = "2094734556";
    var LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    var BARCHART_COLORS = [
      "C0504D",
      "4F81BD",
      "9BBB59",
      "8064A2",
      "4BACC6",
      "F79646",
      "628FC6",
      "C86360",
      "C0504D",
      "4F81BD",
      "9BBB59",
      "8064A2",
      "4BACC6",
      "F79646",
      "628FC6",
      "C86360"
    ];
    var PIECHART_COLORS = [
      "5DA5DA",
      "FAA43A",
      "60BD68",
      "F17CB0",
      "B2912F",
      "B276B2",
      "DECF3F",
      "F15854",
      "A7A7A7",
      "5DA5DA",
      "FAA43A",
      "60BD68",
      "F17CB0",
      "B2912F",
      "B276B2",
      "DECF3F",
      "F15854",
      "A7A7A7"
    ];
    var TEXT_HALIGN;
    (function(TEXT_HALIGN2) {
      TEXT_HALIGN2["left"] = "left";
      TEXT_HALIGN2["center"] = "center";
      TEXT_HALIGN2["right"] = "right";
      TEXT_HALIGN2["justify"] = "justify";
    })(TEXT_HALIGN || (TEXT_HALIGN = {}));
    var TEXT_VALIGN;
    (function(TEXT_VALIGN2) {
      TEXT_VALIGN2["b"] = "b";
      TEXT_VALIGN2["ctr"] = "ctr";
      TEXT_VALIGN2["t"] = "t";
    })(TEXT_VALIGN || (TEXT_VALIGN = {}));
    var SLDNUMFLDID = "{F7021451-1387-4CA6-816F-3879F97B5CBC}";
    var OutputType;
    (function(OutputType2) {
      OutputType2["arraybuffer"] = "arraybuffer";
      OutputType2["base64"] = "base64";
      OutputType2["binarystring"] = "binarystring";
      OutputType2["blob"] = "blob";
      OutputType2["nodebuffer"] = "nodebuffer";
      OutputType2["uint8array"] = "uint8array";
    })(OutputType || (OutputType = {}));
    var ChartType;
    (function(ChartType2) {
      ChartType2["area"] = "area";
      ChartType2["bar"] = "bar";
      ChartType2["bar3d"] = "bar3D";
      ChartType2["bubble"] = "bubble";
      ChartType2["bubble3d"] = "bubble3D";
      ChartType2["doughnut"] = "doughnut";
      ChartType2["line"] = "line";
      ChartType2["pie"] = "pie";
      ChartType2["radar"] = "radar";
      ChartType2["scatter"] = "scatter";
    })(ChartType || (ChartType = {}));
    var ShapeType;
    (function(ShapeType2) {
      ShapeType2["accentBorderCallout1"] = "accentBorderCallout1";
      ShapeType2["accentBorderCallout2"] = "accentBorderCallout2";
      ShapeType2["accentBorderCallout3"] = "accentBorderCallout3";
      ShapeType2["accentCallout1"] = "accentCallout1";
      ShapeType2["accentCallout2"] = "accentCallout2";
      ShapeType2["accentCallout3"] = "accentCallout3";
      ShapeType2["actionButtonBackPrevious"] = "actionButtonBackPrevious";
      ShapeType2["actionButtonBeginning"] = "actionButtonBeginning";
      ShapeType2["actionButtonBlank"] = "actionButtonBlank";
      ShapeType2["actionButtonDocument"] = "actionButtonDocument";
      ShapeType2["actionButtonEnd"] = "actionButtonEnd";
      ShapeType2["actionButtonForwardNext"] = "actionButtonForwardNext";
      ShapeType2["actionButtonHelp"] = "actionButtonHelp";
      ShapeType2["actionButtonHome"] = "actionButtonHome";
      ShapeType2["actionButtonInformation"] = "actionButtonInformation";
      ShapeType2["actionButtonMovie"] = "actionButtonMovie";
      ShapeType2["actionButtonReturn"] = "actionButtonReturn";
      ShapeType2["actionButtonSound"] = "actionButtonSound";
      ShapeType2["arc"] = "arc";
      ShapeType2["bentArrow"] = "bentArrow";
      ShapeType2["bentUpArrow"] = "bentUpArrow";
      ShapeType2["bevel"] = "bevel";
      ShapeType2["blockArc"] = "blockArc";
      ShapeType2["borderCallout1"] = "borderCallout1";
      ShapeType2["borderCallout2"] = "borderCallout2";
      ShapeType2["borderCallout3"] = "borderCallout3";
      ShapeType2["bracePair"] = "bracePair";
      ShapeType2["bracketPair"] = "bracketPair";
      ShapeType2["callout1"] = "callout1";
      ShapeType2["callout2"] = "callout2";
      ShapeType2["callout3"] = "callout3";
      ShapeType2["can"] = "can";
      ShapeType2["chartPlus"] = "chartPlus";
      ShapeType2["chartStar"] = "chartStar";
      ShapeType2["chartX"] = "chartX";
      ShapeType2["chevron"] = "chevron";
      ShapeType2["chord"] = "chord";
      ShapeType2["circularArrow"] = "circularArrow";
      ShapeType2["cloud"] = "cloud";
      ShapeType2["cloudCallout"] = "cloudCallout";
      ShapeType2["corner"] = "corner";
      ShapeType2["cornerTabs"] = "cornerTabs";
      ShapeType2["cube"] = "cube";
      ShapeType2["curvedDownArrow"] = "curvedDownArrow";
      ShapeType2["curvedLeftArrow"] = "curvedLeftArrow";
      ShapeType2["curvedRightArrow"] = "curvedRightArrow";
      ShapeType2["curvedUpArrow"] = "curvedUpArrow";
      ShapeType2["custGeom"] = "custGeom";
      ShapeType2["decagon"] = "decagon";
      ShapeType2["diagStripe"] = "diagStripe";
      ShapeType2["diamond"] = "diamond";
      ShapeType2["dodecagon"] = "dodecagon";
      ShapeType2["donut"] = "donut";
      ShapeType2["doubleWave"] = "doubleWave";
      ShapeType2["downArrow"] = "downArrow";
      ShapeType2["downArrowCallout"] = "downArrowCallout";
      ShapeType2["ellipse"] = "ellipse";
      ShapeType2["ellipseRibbon"] = "ellipseRibbon";
      ShapeType2["ellipseRibbon2"] = "ellipseRibbon2";
      ShapeType2["flowChartAlternateProcess"] = "flowChartAlternateProcess";
      ShapeType2["flowChartCollate"] = "flowChartCollate";
      ShapeType2["flowChartConnector"] = "flowChartConnector";
      ShapeType2["flowChartDecision"] = "flowChartDecision";
      ShapeType2["flowChartDelay"] = "flowChartDelay";
      ShapeType2["flowChartDisplay"] = "flowChartDisplay";
      ShapeType2["flowChartDocument"] = "flowChartDocument";
      ShapeType2["flowChartExtract"] = "flowChartExtract";
      ShapeType2["flowChartInputOutput"] = "flowChartInputOutput";
      ShapeType2["flowChartInternalStorage"] = "flowChartInternalStorage";
      ShapeType2["flowChartMagneticDisk"] = "flowChartMagneticDisk";
      ShapeType2["flowChartMagneticDrum"] = "flowChartMagneticDrum";
      ShapeType2["flowChartMagneticTape"] = "flowChartMagneticTape";
      ShapeType2["flowChartManualInput"] = "flowChartManualInput";
      ShapeType2["flowChartManualOperation"] = "flowChartManualOperation";
      ShapeType2["flowChartMerge"] = "flowChartMerge";
      ShapeType2["flowChartMultidocument"] = "flowChartMultidocument";
      ShapeType2["flowChartOfflineStorage"] = "flowChartOfflineStorage";
      ShapeType2["flowChartOffpageConnector"] = "flowChartOffpageConnector";
      ShapeType2["flowChartOnlineStorage"] = "flowChartOnlineStorage";
      ShapeType2["flowChartOr"] = "flowChartOr";
      ShapeType2["flowChartPredefinedProcess"] = "flowChartPredefinedProcess";
      ShapeType2["flowChartPreparation"] = "flowChartPreparation";
      ShapeType2["flowChartProcess"] = "flowChartProcess";
      ShapeType2["flowChartPunchedCard"] = "flowChartPunchedCard";
      ShapeType2["flowChartPunchedTape"] = "flowChartPunchedTape";
      ShapeType2["flowChartSort"] = "flowChartSort";
      ShapeType2["flowChartSummingJunction"] = "flowChartSummingJunction";
      ShapeType2["flowChartTerminator"] = "flowChartTerminator";
      ShapeType2["folderCorner"] = "folderCorner";
      ShapeType2["frame"] = "frame";
      ShapeType2["funnel"] = "funnel";
      ShapeType2["gear6"] = "gear6";
      ShapeType2["gear9"] = "gear9";
      ShapeType2["halfFrame"] = "halfFrame";
      ShapeType2["heart"] = "heart";
      ShapeType2["heptagon"] = "heptagon";
      ShapeType2["hexagon"] = "hexagon";
      ShapeType2["homePlate"] = "homePlate";
      ShapeType2["horizontalScroll"] = "horizontalScroll";
      ShapeType2["irregularSeal1"] = "irregularSeal1";
      ShapeType2["irregularSeal2"] = "irregularSeal2";
      ShapeType2["leftArrow"] = "leftArrow";
      ShapeType2["leftArrowCallout"] = "leftArrowCallout";
      ShapeType2["leftBrace"] = "leftBrace";
      ShapeType2["leftBracket"] = "leftBracket";
      ShapeType2["leftCircularArrow"] = "leftCircularArrow";
      ShapeType2["leftRightArrow"] = "leftRightArrow";
      ShapeType2["leftRightArrowCallout"] = "leftRightArrowCallout";
      ShapeType2["leftRightCircularArrow"] = "leftRightCircularArrow";
      ShapeType2["leftRightRibbon"] = "leftRightRibbon";
      ShapeType2["leftRightUpArrow"] = "leftRightUpArrow";
      ShapeType2["leftUpArrow"] = "leftUpArrow";
      ShapeType2["lightningBolt"] = "lightningBolt";
      ShapeType2["line"] = "line";
      ShapeType2["lineInv"] = "lineInv";
      ShapeType2["mathDivide"] = "mathDivide";
      ShapeType2["mathEqual"] = "mathEqual";
      ShapeType2["mathMinus"] = "mathMinus";
      ShapeType2["mathMultiply"] = "mathMultiply";
      ShapeType2["mathNotEqual"] = "mathNotEqual";
      ShapeType2["mathPlus"] = "mathPlus";
      ShapeType2["moon"] = "moon";
      ShapeType2["noSmoking"] = "noSmoking";
      ShapeType2["nonIsoscelesTrapezoid"] = "nonIsoscelesTrapezoid";
      ShapeType2["notchedRightArrow"] = "notchedRightArrow";
      ShapeType2["octagon"] = "octagon";
      ShapeType2["parallelogram"] = "parallelogram";
      ShapeType2["pentagon"] = "pentagon";
      ShapeType2["pie"] = "pie";
      ShapeType2["pieWedge"] = "pieWedge";
      ShapeType2["plaque"] = "plaque";
      ShapeType2["plaqueTabs"] = "plaqueTabs";
      ShapeType2["plus"] = "plus";
      ShapeType2["quadArrow"] = "quadArrow";
      ShapeType2["quadArrowCallout"] = "quadArrowCallout";
      ShapeType2["rect"] = "rect";
      ShapeType2["ribbon"] = "ribbon";
      ShapeType2["ribbon2"] = "ribbon2";
      ShapeType2["rightArrow"] = "rightArrow";
      ShapeType2["rightArrowCallout"] = "rightArrowCallout";
      ShapeType2["rightBrace"] = "rightBrace";
      ShapeType2["rightBracket"] = "rightBracket";
      ShapeType2["round1Rect"] = "round1Rect";
      ShapeType2["round2DiagRect"] = "round2DiagRect";
      ShapeType2["round2SameRect"] = "round2SameRect";
      ShapeType2["roundRect"] = "roundRect";
      ShapeType2["rtTriangle"] = "rtTriangle";
      ShapeType2["smileyFace"] = "smileyFace";
      ShapeType2["snip1Rect"] = "snip1Rect";
      ShapeType2["snip2DiagRect"] = "snip2DiagRect";
      ShapeType2["snip2SameRect"] = "snip2SameRect";
      ShapeType2["snipRoundRect"] = "snipRoundRect";
      ShapeType2["squareTabs"] = "squareTabs";
      ShapeType2["star10"] = "star10";
      ShapeType2["star12"] = "star12";
      ShapeType2["star16"] = "star16";
      ShapeType2["star24"] = "star24";
      ShapeType2["star32"] = "star32";
      ShapeType2["star4"] = "star4";
      ShapeType2["star5"] = "star5";
      ShapeType2["star6"] = "star6";
      ShapeType2["star7"] = "star7";
      ShapeType2["star8"] = "star8";
      ShapeType2["stripedRightArrow"] = "stripedRightArrow";
      ShapeType2["sun"] = "sun";
      ShapeType2["swooshArrow"] = "swooshArrow";
      ShapeType2["teardrop"] = "teardrop";
      ShapeType2["trapezoid"] = "trapezoid";
      ShapeType2["triangle"] = "triangle";
      ShapeType2["upArrow"] = "upArrow";
      ShapeType2["upArrowCallout"] = "upArrowCallout";
      ShapeType2["upDownArrow"] = "upDownArrow";
      ShapeType2["upDownArrowCallout"] = "upDownArrowCallout";
      ShapeType2["uturnArrow"] = "uturnArrow";
      ShapeType2["verticalScroll"] = "verticalScroll";
      ShapeType2["wave"] = "wave";
      ShapeType2["wedgeEllipseCallout"] = "wedgeEllipseCallout";
      ShapeType2["wedgeRectCallout"] = "wedgeRectCallout";
      ShapeType2["wedgeRoundRectCallout"] = "wedgeRoundRectCallout";
    })(ShapeType || (ShapeType = {}));
    var SchemeColor;
    (function(SchemeColor2) {
      SchemeColor2["text1"] = "tx1";
      SchemeColor2["text2"] = "tx2";
      SchemeColor2["background1"] = "bg1";
      SchemeColor2["background2"] = "bg2";
      SchemeColor2["accent1"] = "accent1";
      SchemeColor2["accent2"] = "accent2";
      SchemeColor2["accent3"] = "accent3";
      SchemeColor2["accent4"] = "accent4";
      SchemeColor2["accent5"] = "accent5";
      SchemeColor2["accent6"] = "accent6";
    })(SchemeColor || (SchemeColor = {}));
    var AlignH;
    (function(AlignH2) {
      AlignH2["left"] = "left";
      AlignH2["center"] = "center";
      AlignH2["right"] = "right";
      AlignH2["justify"] = "justify";
    })(AlignH || (AlignH = {}));
    var AlignV;
    (function(AlignV2) {
      AlignV2["top"] = "top";
      AlignV2["middle"] = "middle";
      AlignV2["bottom"] = "bottom";
    })(AlignV || (AlignV = {}));
    var SHAPE_TYPE;
    (function(SHAPE_TYPE2) {
      SHAPE_TYPE2["ACTION_BUTTON_BACK_OR_PREVIOUS"] = "actionButtonBackPrevious";
      SHAPE_TYPE2["ACTION_BUTTON_BEGINNING"] = "actionButtonBeginning";
      SHAPE_TYPE2["ACTION_BUTTON_CUSTOM"] = "actionButtonBlank";
      SHAPE_TYPE2["ACTION_BUTTON_DOCUMENT"] = "actionButtonDocument";
      SHAPE_TYPE2["ACTION_BUTTON_END"] = "actionButtonEnd";
      SHAPE_TYPE2["ACTION_BUTTON_FORWARD_OR_NEXT"] = "actionButtonForwardNext";
      SHAPE_TYPE2["ACTION_BUTTON_HELP"] = "actionButtonHelp";
      SHAPE_TYPE2["ACTION_BUTTON_HOME"] = "actionButtonHome";
      SHAPE_TYPE2["ACTION_BUTTON_INFORMATION"] = "actionButtonInformation";
      SHAPE_TYPE2["ACTION_BUTTON_MOVIE"] = "actionButtonMovie";
      SHAPE_TYPE2["ACTION_BUTTON_RETURN"] = "actionButtonReturn";
      SHAPE_TYPE2["ACTION_BUTTON_SOUND"] = "actionButtonSound";
      SHAPE_TYPE2["ARC"] = "arc";
      SHAPE_TYPE2["BALLOON"] = "wedgeRoundRectCallout";
      SHAPE_TYPE2["BENT_ARROW"] = "bentArrow";
      SHAPE_TYPE2["BENT_UP_ARROW"] = "bentUpArrow";
      SHAPE_TYPE2["BEVEL"] = "bevel";
      SHAPE_TYPE2["BLOCK_ARC"] = "blockArc";
      SHAPE_TYPE2["CAN"] = "can";
      SHAPE_TYPE2["CHART_PLUS"] = "chartPlus";
      SHAPE_TYPE2["CHART_STAR"] = "chartStar";
      SHAPE_TYPE2["CHART_X"] = "chartX";
      SHAPE_TYPE2["CHEVRON"] = "chevron";
      SHAPE_TYPE2["CHORD"] = "chord";
      SHAPE_TYPE2["CIRCULAR_ARROW"] = "circularArrow";
      SHAPE_TYPE2["CLOUD"] = "cloud";
      SHAPE_TYPE2["CLOUD_CALLOUT"] = "cloudCallout";
      SHAPE_TYPE2["CORNER"] = "corner";
      SHAPE_TYPE2["CORNER_TABS"] = "cornerTabs";
      SHAPE_TYPE2["CROSS"] = "plus";
      SHAPE_TYPE2["CUBE"] = "cube";
      SHAPE_TYPE2["CURVED_DOWN_ARROW"] = "curvedDownArrow";
      SHAPE_TYPE2["CURVED_DOWN_RIBBON"] = "ellipseRibbon";
      SHAPE_TYPE2["CURVED_LEFT_ARROW"] = "curvedLeftArrow";
      SHAPE_TYPE2["CURVED_RIGHT_ARROW"] = "curvedRightArrow";
      SHAPE_TYPE2["CURVED_UP_ARROW"] = "curvedUpArrow";
      SHAPE_TYPE2["CURVED_UP_RIBBON"] = "ellipseRibbon2";
      SHAPE_TYPE2["CUSTOM_GEOMETRY"] = "custGeom";
      SHAPE_TYPE2["DECAGON"] = "decagon";
      SHAPE_TYPE2["DIAGONAL_STRIPE"] = "diagStripe";
      SHAPE_TYPE2["DIAMOND"] = "diamond";
      SHAPE_TYPE2["DODECAGON"] = "dodecagon";
      SHAPE_TYPE2["DONUT"] = "donut";
      SHAPE_TYPE2["DOUBLE_BRACE"] = "bracePair";
      SHAPE_TYPE2["DOUBLE_BRACKET"] = "bracketPair";
      SHAPE_TYPE2["DOUBLE_WAVE"] = "doubleWave";
      SHAPE_TYPE2["DOWN_ARROW"] = "downArrow";
      SHAPE_TYPE2["DOWN_ARROW_CALLOUT"] = "downArrowCallout";
      SHAPE_TYPE2["DOWN_RIBBON"] = "ribbon";
      SHAPE_TYPE2["EXPLOSION1"] = "irregularSeal1";
      SHAPE_TYPE2["EXPLOSION2"] = "irregularSeal2";
      SHAPE_TYPE2["FLOWCHART_ALTERNATE_PROCESS"] = "flowChartAlternateProcess";
      SHAPE_TYPE2["FLOWCHART_CARD"] = "flowChartPunchedCard";
      SHAPE_TYPE2["FLOWCHART_COLLATE"] = "flowChartCollate";
      SHAPE_TYPE2["FLOWCHART_CONNECTOR"] = "flowChartConnector";
      SHAPE_TYPE2["FLOWCHART_DATA"] = "flowChartInputOutput";
      SHAPE_TYPE2["FLOWCHART_DECISION"] = "flowChartDecision";
      SHAPE_TYPE2["FLOWCHART_DELAY"] = "flowChartDelay";
      SHAPE_TYPE2["FLOWCHART_DIRECT_ACCESS_STORAGE"] = "flowChartMagneticDrum";
      SHAPE_TYPE2["FLOWCHART_DISPLAY"] = "flowChartDisplay";
      SHAPE_TYPE2["FLOWCHART_DOCUMENT"] = "flowChartDocument";
      SHAPE_TYPE2["FLOWCHART_EXTRACT"] = "flowChartExtract";
      SHAPE_TYPE2["FLOWCHART_INTERNAL_STORAGE"] = "flowChartInternalStorage";
      SHAPE_TYPE2["FLOWCHART_MAGNETIC_DISK"] = "flowChartMagneticDisk";
      SHAPE_TYPE2["FLOWCHART_MANUAL_INPUT"] = "flowChartManualInput";
      SHAPE_TYPE2["FLOWCHART_MANUAL_OPERATION"] = "flowChartManualOperation";
      SHAPE_TYPE2["FLOWCHART_MERGE"] = "flowChartMerge";
      SHAPE_TYPE2["FLOWCHART_MULTIDOCUMENT"] = "flowChartMultidocument";
      SHAPE_TYPE2["FLOWCHART_OFFLINE_STORAGE"] = "flowChartOfflineStorage";
      SHAPE_TYPE2["FLOWCHART_OFFPAGE_CONNECTOR"] = "flowChartOffpageConnector";
      SHAPE_TYPE2["FLOWCHART_OR"] = "flowChartOr";
      SHAPE_TYPE2["FLOWCHART_PREDEFINED_PROCESS"] = "flowChartPredefinedProcess";
      SHAPE_TYPE2["FLOWCHART_PREPARATION"] = "flowChartPreparation";
      SHAPE_TYPE2["FLOWCHART_PROCESS"] = "flowChartProcess";
      SHAPE_TYPE2["FLOWCHART_PUNCHED_TAPE"] = "flowChartPunchedTape";
      SHAPE_TYPE2["FLOWCHART_SEQUENTIAL_ACCESS_STORAGE"] = "flowChartMagneticTape";
      SHAPE_TYPE2["FLOWCHART_SORT"] = "flowChartSort";
      SHAPE_TYPE2["FLOWCHART_STORED_DATA"] = "flowChartOnlineStorage";
      SHAPE_TYPE2["FLOWCHART_SUMMING_JUNCTION"] = "flowChartSummingJunction";
      SHAPE_TYPE2["FLOWCHART_TERMINATOR"] = "flowChartTerminator";
      SHAPE_TYPE2["FOLDED_CORNER"] = "folderCorner";
      SHAPE_TYPE2["FRAME"] = "frame";
      SHAPE_TYPE2["FUNNEL"] = "funnel";
      SHAPE_TYPE2["GEAR_6"] = "gear6";
      SHAPE_TYPE2["GEAR_9"] = "gear9";
      SHAPE_TYPE2["HALF_FRAME"] = "halfFrame";
      SHAPE_TYPE2["HEART"] = "heart";
      SHAPE_TYPE2["HEPTAGON"] = "heptagon";
      SHAPE_TYPE2["HEXAGON"] = "hexagon";
      SHAPE_TYPE2["HORIZONTAL_SCROLL"] = "horizontalScroll";
      SHAPE_TYPE2["ISOSCELES_TRIANGLE"] = "triangle";
      SHAPE_TYPE2["LEFT_ARROW"] = "leftArrow";
      SHAPE_TYPE2["LEFT_ARROW_CALLOUT"] = "leftArrowCallout";
      SHAPE_TYPE2["LEFT_BRACE"] = "leftBrace";
      SHAPE_TYPE2["LEFT_BRACKET"] = "leftBracket";
      SHAPE_TYPE2["LEFT_CIRCULAR_ARROW"] = "leftCircularArrow";
      SHAPE_TYPE2["LEFT_RIGHT_ARROW"] = "leftRightArrow";
      SHAPE_TYPE2["LEFT_RIGHT_ARROW_CALLOUT"] = "leftRightArrowCallout";
      SHAPE_TYPE2["LEFT_RIGHT_CIRCULAR_ARROW"] = "leftRightCircularArrow";
      SHAPE_TYPE2["LEFT_RIGHT_RIBBON"] = "leftRightRibbon";
      SHAPE_TYPE2["LEFT_RIGHT_UP_ARROW"] = "leftRightUpArrow";
      SHAPE_TYPE2["LEFT_UP_ARROW"] = "leftUpArrow";
      SHAPE_TYPE2["LIGHTNING_BOLT"] = "lightningBolt";
      SHAPE_TYPE2["LINE_CALLOUT_1"] = "borderCallout1";
      SHAPE_TYPE2["LINE_CALLOUT_1_ACCENT_BAR"] = "accentCallout1";
      SHAPE_TYPE2["LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout1";
      SHAPE_TYPE2["LINE_CALLOUT_1_NO_BORDER"] = "callout1";
      SHAPE_TYPE2["LINE_CALLOUT_2"] = "borderCallout2";
      SHAPE_TYPE2["LINE_CALLOUT_2_ACCENT_BAR"] = "accentCallout2";
      SHAPE_TYPE2["LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout2";
      SHAPE_TYPE2["LINE_CALLOUT_2_NO_BORDER"] = "callout2";
      SHAPE_TYPE2["LINE_CALLOUT_3"] = "borderCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_3_ACCENT_BAR"] = "accentCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_3_NO_BORDER"] = "callout3";
      SHAPE_TYPE2["LINE_CALLOUT_4"] = "borderCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_4_ACCENT_BAR"] = "accentCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
      SHAPE_TYPE2["LINE_CALLOUT_4_NO_BORDER"] = "callout3";
      SHAPE_TYPE2["LINE"] = "line";
      SHAPE_TYPE2["LINE_INVERSE"] = "lineInv";
      SHAPE_TYPE2["MATH_DIVIDE"] = "mathDivide";
      SHAPE_TYPE2["MATH_EQUAL"] = "mathEqual";
      SHAPE_TYPE2["MATH_MINUS"] = "mathMinus";
      SHAPE_TYPE2["MATH_MULTIPLY"] = "mathMultiply";
      SHAPE_TYPE2["MATH_NOT_EQUAL"] = "mathNotEqual";
      SHAPE_TYPE2["MATH_PLUS"] = "mathPlus";
      SHAPE_TYPE2["MOON"] = "moon";
      SHAPE_TYPE2["NON_ISOSCELES_TRAPEZOID"] = "nonIsoscelesTrapezoid";
      SHAPE_TYPE2["NOTCHED_RIGHT_ARROW"] = "notchedRightArrow";
      SHAPE_TYPE2["NO_SYMBOL"] = "noSmoking";
      SHAPE_TYPE2["OCTAGON"] = "octagon";
      SHAPE_TYPE2["OVAL"] = "ellipse";
      SHAPE_TYPE2["OVAL_CALLOUT"] = "wedgeEllipseCallout";
      SHAPE_TYPE2["PARALLELOGRAM"] = "parallelogram";
      SHAPE_TYPE2["PENTAGON"] = "homePlate";
      SHAPE_TYPE2["PIE"] = "pie";
      SHAPE_TYPE2["PIE_WEDGE"] = "pieWedge";
      SHAPE_TYPE2["PLAQUE"] = "plaque";
      SHAPE_TYPE2["PLAQUE_TABS"] = "plaqueTabs";
      SHAPE_TYPE2["QUAD_ARROW"] = "quadArrow";
      SHAPE_TYPE2["QUAD_ARROW_CALLOUT"] = "quadArrowCallout";
      SHAPE_TYPE2["RECTANGLE"] = "rect";
      SHAPE_TYPE2["RECTANGULAR_CALLOUT"] = "wedgeRectCallout";
      SHAPE_TYPE2["REGULAR_PENTAGON"] = "pentagon";
      SHAPE_TYPE2["RIGHT_ARROW"] = "rightArrow";
      SHAPE_TYPE2["RIGHT_ARROW_CALLOUT"] = "rightArrowCallout";
      SHAPE_TYPE2["RIGHT_BRACE"] = "rightBrace";
      SHAPE_TYPE2["RIGHT_BRACKET"] = "rightBracket";
      SHAPE_TYPE2["RIGHT_TRIANGLE"] = "rtTriangle";
      SHAPE_TYPE2["ROUNDED_RECTANGLE"] = "roundRect";
      SHAPE_TYPE2["ROUNDED_RECTANGULAR_CALLOUT"] = "wedgeRoundRectCallout";
      SHAPE_TYPE2["ROUND_1_RECTANGLE"] = "round1Rect";
      SHAPE_TYPE2["ROUND_2_DIAG_RECTANGLE"] = "round2DiagRect";
      SHAPE_TYPE2["ROUND_2_SAME_RECTANGLE"] = "round2SameRect";
      SHAPE_TYPE2["SMILEY_FACE"] = "smileyFace";
      SHAPE_TYPE2["SNIP_1_RECTANGLE"] = "snip1Rect";
      SHAPE_TYPE2["SNIP_2_DIAG_RECTANGLE"] = "snip2DiagRect";
      SHAPE_TYPE2["SNIP_2_SAME_RECTANGLE"] = "snip2SameRect";
      SHAPE_TYPE2["SNIP_ROUND_RECTANGLE"] = "snipRoundRect";
      SHAPE_TYPE2["SQUARE_TABS"] = "squareTabs";
      SHAPE_TYPE2["STAR_10_POINT"] = "star10";
      SHAPE_TYPE2["STAR_12_POINT"] = "star12";
      SHAPE_TYPE2["STAR_16_POINT"] = "star16";
      SHAPE_TYPE2["STAR_24_POINT"] = "star24";
      SHAPE_TYPE2["STAR_32_POINT"] = "star32";
      SHAPE_TYPE2["STAR_4_POINT"] = "star4";
      SHAPE_TYPE2["STAR_5_POINT"] = "star5";
      SHAPE_TYPE2["STAR_6_POINT"] = "star6";
      SHAPE_TYPE2["STAR_7_POINT"] = "star7";
      SHAPE_TYPE2["STAR_8_POINT"] = "star8";
      SHAPE_TYPE2["STRIPED_RIGHT_ARROW"] = "stripedRightArrow";
      SHAPE_TYPE2["SUN"] = "sun";
      SHAPE_TYPE2["SWOOSH_ARROW"] = "swooshArrow";
      SHAPE_TYPE2["TEAR"] = "teardrop";
      SHAPE_TYPE2["TRAPEZOID"] = "trapezoid";
      SHAPE_TYPE2["UP_ARROW"] = "upArrow";
      SHAPE_TYPE2["UP_ARROW_CALLOUT"] = "upArrowCallout";
      SHAPE_TYPE2["UP_DOWN_ARROW"] = "upDownArrow";
      SHAPE_TYPE2["UP_DOWN_ARROW_CALLOUT"] = "upDownArrowCallout";
      SHAPE_TYPE2["UP_RIBBON"] = "ribbon2";
      SHAPE_TYPE2["U_TURN_ARROW"] = "uturnArrow";
      SHAPE_TYPE2["VERTICAL_SCROLL"] = "verticalScroll";
      SHAPE_TYPE2["WAVE"] = "wave";
    })(SHAPE_TYPE || (SHAPE_TYPE = {}));
    var CHART_TYPE;
    (function(CHART_TYPE2) {
      CHART_TYPE2["AREA"] = "area";
      CHART_TYPE2["BAR"] = "bar";
      CHART_TYPE2["BAR3D"] = "bar3D";
      CHART_TYPE2["BUBBLE"] = "bubble";
      CHART_TYPE2["BUBBLE3D"] = "bubble3D";
      CHART_TYPE2["DOUGHNUT"] = "doughnut";
      CHART_TYPE2["LINE"] = "line";
      CHART_TYPE2["PIE"] = "pie";
      CHART_TYPE2["RADAR"] = "radar";
      CHART_TYPE2["SCATTER"] = "scatter";
    })(CHART_TYPE || (CHART_TYPE = {}));
    var SCHEME_COLOR_NAMES;
    (function(SCHEME_COLOR_NAMES2) {
      SCHEME_COLOR_NAMES2["TEXT1"] = "tx1";
      SCHEME_COLOR_NAMES2["TEXT2"] = "tx2";
      SCHEME_COLOR_NAMES2["BACKGROUND1"] = "bg1";
      SCHEME_COLOR_NAMES2["BACKGROUND2"] = "bg2";
      SCHEME_COLOR_NAMES2["ACCENT1"] = "accent1";
      SCHEME_COLOR_NAMES2["ACCENT2"] = "accent2";
      SCHEME_COLOR_NAMES2["ACCENT3"] = "accent3";
      SCHEME_COLOR_NAMES2["ACCENT4"] = "accent4";
      SCHEME_COLOR_NAMES2["ACCENT5"] = "accent5";
      SCHEME_COLOR_NAMES2["ACCENT6"] = "accent6";
    })(SCHEME_COLOR_NAMES || (SCHEME_COLOR_NAMES = {}));
    var MASTER_OBJECTS;
    (function(MASTER_OBJECTS2) {
      MASTER_OBJECTS2["chart"] = "chart";
      MASTER_OBJECTS2["image"] = "image";
      MASTER_OBJECTS2["line"] = "line";
      MASTER_OBJECTS2["rect"] = "rect";
      MASTER_OBJECTS2["text"] = "text";
      MASTER_OBJECTS2["placeholder"] = "placeholder";
    })(MASTER_OBJECTS || (MASTER_OBJECTS = {}));
    var SLIDE_OBJECT_TYPES;
    (function(SLIDE_OBJECT_TYPES2) {
      SLIDE_OBJECT_TYPES2["chart"] = "chart";
      SLIDE_OBJECT_TYPES2["hyperlink"] = "hyperlink";
      SLIDE_OBJECT_TYPES2["image"] = "image";
      SLIDE_OBJECT_TYPES2["media"] = "media";
      SLIDE_OBJECT_TYPES2["online"] = "online";
      SLIDE_OBJECT_TYPES2["placeholder"] = "placeholder";
      SLIDE_OBJECT_TYPES2["table"] = "table";
      SLIDE_OBJECT_TYPES2["tablecell"] = "tablecell";
      SLIDE_OBJECT_TYPES2["text"] = "text";
      SLIDE_OBJECT_TYPES2["notes"] = "notes";
    })(SLIDE_OBJECT_TYPES || (SLIDE_OBJECT_TYPES = {}));
    var PLACEHOLDER_TYPES;
    (function(PLACEHOLDER_TYPES2) {
      PLACEHOLDER_TYPES2["title"] = "title";
      PLACEHOLDER_TYPES2["body"] = "body";
      PLACEHOLDER_TYPES2["image"] = "pic";
      PLACEHOLDER_TYPES2["chart"] = "chart";
      PLACEHOLDER_TYPES2["table"] = "tbl";
      PLACEHOLDER_TYPES2["media"] = "media";
    })(PLACEHOLDER_TYPES || (PLACEHOLDER_TYPES = {}));
    var BULLET_TYPES;
    (function(BULLET_TYPES2) {
      BULLET_TYPES2["DEFAULT"] = "&#x2022;";
      BULLET_TYPES2["CHECK"] = "&#x2713;";
      BULLET_TYPES2["STAR"] = "&#x2605;";
      BULLET_TYPES2["TRIANGLE"] = "&#x25B6;";
    })(BULLET_TYPES || (BULLET_TYPES = {}));
    var IMG_BROKEN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAB3CAYAAAD1oOVhAAAGAUlEQVR4Xu2dT0xcRRzHf7tAYSsc0EBSIq2xEg8mtTGebVzEqOVIolz0siRE4gGTStqKwdpWsXoyGhMuyAVJOHBgqyvLNgonDkabeCBYW/8kTUr0wsJC+Wfm0bfuvn37Znbem9mR9303mJnf/Pb7ed95M7PDI5JIJPYJV5EC7e3t1N/fT62trdqViQCIu+bVgpIHEo/Hqbe3V/sdYVKHyWSSZmZm8ilVA0oeyNjYmEnaVC2Xvr6+qg5fAOJAz4DU1dURGzFSqZRVqtMpAFIGyMjICC0vL9PExIRWKADiAYTNshYWFrRCARAOEFZcCKWtrY0GBgaUTYkBRACIE4rKZwqACALR5RQAqQCIDqcASIVAVDsFQCSAqHQKgEgCUeUUAPEBRIVTAMQnEBvK5OQkbW9vk991CoAEAMQJxc86BUACAhKUUwAkQCBBOAVAAgbi1ykAogCIH6cAiCIgsk4BEIVAZJwCIIqBVLqiBxANQFgXS0tLND4+zl08AogmIG5OSSQS1gGKwgtANAIRcQqAaAbCe6YASBWA2E6xDyeyDUl7+AKQMkDYYevm5mZHabA/Li4uUiaTsYLau8QA4gLE/hU7wajyYtv1hReDAiAOxQcHBymbzark4BkbQKom/X8dp9Npmpqasn4BIAYAYSnYp+4BBEAMUcCwNOCQsAKZnp62NtQOw8WmwT09PUo+ijaHsOMx7GppaaH6+nolH0Z10K2tLVpdXbW6UfV3mNqBdHd3U1NTk2rtlMRfW1uj2dlZAFGirkRQAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAGHqrm8caPzQ0WC1logbeiC7X3xJm0PvUmRzh45cuki1588FAmVn9BO6P3yF9utrqGH0MtW82S8UN9RA9v/4k7InjhcJFTs/TLVXLwmJV67S7vD7tHF5pKi46fYdosdOcOOGG8j1OcqefbFEJD9Q3GCwDhqT31HklS4A8VRgfYM2Op6k3bt/BQJl58J7lPvwg5JYNccepaMry0LPqFA7hCm39+NNyp2J0172b19QysGINj5CsRtpij57musOViH0QPJQXn6J9u7dlYJSFkbrMYolrwvDAJAC+WWdEpQz7FTgECeUCpzi6YxvvqXoM6eEhqnCSgDikEzUKUE7Aw7xuHctKB5OYU3dZlNR9syQdAaAcAYTC0pXF+39c09o2Ik+3EqxVKqiB7hbYAxZkk4pbBaEM+AQofv+wTrFwylBOQNABIGwavdfe4O2pg5elO+86l99nY58/VUF0byrYsjiSFluNlXYrOHcBar7+EogUADEQ0YRGHbzoKAASBkg2+9cpM1rV0tK2QOcXW7bLEFAARAXIF4w2DrDWoeUWaf4hQIgDiA8GPZ2iNfi0Q8UACkAIgrDbrJ385eDxaPLLrEsFAB5oG6lMPJQPLZZZKAACBGVhcG2Q+bmuLu2nk55e4jqPv1IeEoceiBeX7s2zCa5MAqdstl91vfXwaEGsv/rb5TtOFk6tWXOuJGh6KmnhO9sayrMninPx103JBtXblHkice58cINZP4Hyr5wpkgkdiChEmc4FWazLzenNKa/p0jncwDiqcD6BuWePk07t1asatZGoYQzSqA4nFJ7soNiP/+EUyfc25GI2GG53dHPrKo1g/1Cw4pIXLrzO+1c+/wg7tBbFDle/EbQcjFCPWQJCau5EoBoFpzXHYDwFNJcDiCaBed1ByA8hTSXA4hmwXndAQhPIc3lAKJZcF53AMJTSHM5gGgWnNcdgPAU0lwOIJoF53UHIDyFNJcfSiCdnZ0Ui8U0SxlMd7lcjubn561gh+Y1scFIU/0o/3sgeLO12E2k7UXKYumgFoAYdg8ACIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6ZQ4JB6PKzviYthnNy4d9h+1M5mMlVckkUjsG5dhiBMCEMPg/wuOfrZZ/RSywQAAAABJRU5ErkJggg==";
    var IMG_PLAYBTN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVnCAYAAACzfHDVAAAAYHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVcjJDYAwDEXBu6ughBfH+YnLQSwSHVA+Yrkwx7HtPHabHuEWrQ+lBBAZ6TMweBWoCwUH8quZH6VWFXVT696zxp12ARkVFEqn8wB8AAAACXBIWXMAAC4jAAAuIwF4pT92AADZLklEQVR42uzdd5hV9Z0/8M+dmcsUZmDovYOhKCiKYhR7JJuoSTCWGFI0WUxijBoTTXazVlyza4maYm9rTRSJigVsqCDNQhHBAogKCEgRMjMMU+7vj93sL8kqClLmnPt6PY+PeXZM9vP9vO8jZ+Y955xMfJLjorBrRMuSgmiViyjN1Ee2oSCyucbIBAAAAAAAAADbXaYgcoWNUZcrirpMbdRsysa69wbF+rggGrf439vSF7seF12aFUTnxvoosGIAAAAAAACAXacgoqEgF++/VRgr4r5o+Kh/pvD//F8uiII+LaPrum/EXzqui2b1ddHGKgEAAAAAAAB2rVxEQWMmWrQtjHZlA6N2w2tR84//zP8pgHu3ib6NBdG+zdqorK6KVUXZaB85j3sGAAAAAAAAaAoaG6OwIBdtyneP2PBabPzbr/1dAdx3VHRtyESHiIhcYzQrLo7WmVzkcjmPgAYAAAAAAABoSgpy0eIfS+D/LYD7fy3abC6Inn/7X2hsjELlLwAAAAAAAEDT9D8lcM1fHwddFBFxyAVR9M686PVp/gfqayKiJiLqLBMAAAAAAABgh8hGRGlEUekn/6PFEb3ikNgQk6O+KCJi6dzoksv83/cB/1X9xoiaJdmoWxlRV1dk2QAAAAAAAAA7QTZbH9muERX96v7n9t7/q6Exinq3i86LI94pjOOisHUu+uYykfmof7h+Y8Sa6aVRt74gGhs9DRoAAAAAAABgZ2lsLIi69QWxeUUmSjs0/vedwR8hk4uydSfE+wVd6qOyMfMx7/mtj9jwUtbjngEAAAAAAAB2obrqolg7IxtR/9Ffb4wo7P5GtCwobRaVH/c/UvNmNuqqPfIZAAAAAAAAYFerqy6KmjezH/v1ktpoVZBr/PgCeMN7yl8AAAAAAACApmJLHW5jUVQWNDSP+Q3ZeLco4i9/+8X6teHRzwAAAAAAAABNSd3/dLn/oLAoqqIuVhXFxhhSGB/xqGjlLwAAAAAAAECTU1eTjaK/KXSLIv7SWB+bc5ko9YxnAAAAAAAAgATJFv393bz1EeV//c8F1gMAAAAAAACQDgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKREkRUAAACwrUpLSwuGDRvWfMCAAS26du3avKysrLiioqKkZcuWzZs1a1bcvHnz0tLS0rJsNtusuLi4ebNmzUoLCgo+8/eijY2N9Zs3b66pra2tqqur21xTU1NdVVVVs2nTptqNGzdWbdiwoeYvf/nL5hUrVlQtWLBgw6xZs6pqamoaJQYAAEDaKYABAACIiIghQ4aUHnTQQW379u3bql27dq3at2/fpkWLFq2bN29eWVpa2qpZs2bNCwsLm2ez2fLCwsLyoqKi8sLCwtKknK+hoaG6vr6+qqGh4S91dXV/aWhoqNq8eXNVTU3NuqqqqvUbNmxYu2rVqjWrV69e99Zbb6177rnnPpgzZ06NTwYAAABJogAGAADIA8OGDWt+xBFHdBwwYECnLl26dGjdunXHFi1adCgtLe1YUlLSvlmzZq0KCgqK07yDwsLCssLCwrKIaPdp/zuNjY21mzdvXrdp06ZVNTU172/YsGHl2rVr31+2bNnKBQsWrHjyySffnzVrVpVPGAAAAE1Fpuexsd9HfaF+ZcSal0ptCAAAIAE6deqUPf744zvtueeeXbp3796lbdu2XSorKzuXlpZ2KS0t7VBYWFhhSztGQ0PDxpqampU1NTXL169fv+yDDz5Y9s477yybPXv2sj/96U8rVqxYUWdLAAAAbE9t9q6Jog4f/TUFMAAAQEJks9nMt7/97Y4jRozo1bdv397t2rXrXl5e3rWsrKxzcXFx+4gosKUmp7G2tnZVTU3Nso0bNy5btWrV0tdff/2tJ598cvG999672noAAADYFgpgAACAhPne977X6a9Fb/v27Xu1bNmyV1lZWa8kvXOXLauvr9/wl7/8ZdG6desWL1u2bNHChQsX/fGPf1w8derUjbYDAADAliiAAQAAmqhsNps59dRTuxx66KH9+/Tp87n27dv3Ly8v719UVOSRzXlq06ZNKzZu3Pj6+++//8abb775xqOPPvrG3XffvcpmAAAA+CsFMAAAQBNx6qmndvniF784qHfv3v3btWv3uYqKis8VFhaW2wxbUl9fv37Dhg1vfPDBB68vXrz4jccee2z+jTfeuNxmAAAA8pMCGAAAYBc45phjWn/rW9/aq3///kPatGnTv6Kiop9HOLO9NDQ0VG/cuPGtNWvWLFy4cOGcO+6445WHHnporc0AAACknwIYAABgJzjjjDO6f+lLX9qrV69eg1u3bj2orKysR0RkbIadJFddXb103bp18xcvXjz30UcffeXqq69+x1oAAADSRwEMAACwnZWWlhb86le/2u3QQw8d1r17931btmw5qLCwsMxmaEoaGhqqP/zww/nvvPPOzGeeeWbW2LFj36ipqWm0GQAAgGRTAAMAAGwHP/7xj7t+9atf3bdXr15D27Ztu1c2m21jKyRJXV3dmg8++OCVRYsWvfznP/95xh/+8IdltgIAAJA8CmAAAIBtcOKJJ7Y75ZRTDujXr9+w1q1bD81ms61shTSpq6tbt3bt2pfffPPNWbfccsvUe++9d7WtAAAANH0KYAAAgE+hoqKi4IILLhg0YsSI/bp27bpfy5YtB2YymUKbIR/kcrmGDz/8cP6777474/nnn59x4YUXvrZx40aPiwYAAGiCFMAAAAAf4/jjj2/7/e9//8D+/fsf2Lp1630KCgpKbAUiGhsbN61fv37eW2+9NeWGG2545u67715lKwAAAE2DAhgAAOB/ZLPZzAUXXPC5I4888sDu3bsfWFFRsVtEFNgMbFl1dfWSd999d8qsWbNmnnvuuS+vW7euwVYAAAB2DQUwAACQ10pLSwsuvfTSQYcccsjBXbt2HVFWVtbDVmDb1dbWrnr//fdfmDp16uRf/vKXL65evbreVgAAAHYeBTAAAJB3Bg0aVHrBBRd8fs899zywQ4cOBxQVFbWwFdj+Ghsba9euXTtrzpw5T59//vmTX3755WpbAQAA2LEUwAAAQF4YNmxY8/POO+/gIUOGHOZ9vrDz/W0ZfNFFFz07a9asKlsBAADY/hTAAABAarVq1arwyiuv3HfEiBEjO3TocFBhYWGZrcCu19DQUP3+++8/O2XKlIk/+clPZm7cuLHRVgAAALYPBTAAAJAqrVq1Kvztb3+7/3777Xd4x44dRxQWFpbbCjRdDQ0NG99///0pM2bMeOqHP/zhC8pgAACAz0YBDAAApMJZZ53V45vf/OaRvXr1GllaWtrVRiB5ampq3l28ePHEO++8c9LVV1/9jo0AAABsPQUwAACQWMOHDy+/6KKLvjB48OCjW7RoMdBGID0+/PDDV+fNmzfhvPPOe3L69Ol/sREAAIBPRwEMAAAkSqtWrQpvuOGGQ/bbb79/atOmzX6ZTCZrK5BeuVyubs2aNTNmzJjx2JgxYyavW7euwVYAAAA+ngIYAABIhB//+Mddv/e9732lZ8+e/1RcXNzWRiD/1NbWfvD2228/dssttzz029/+9l0bAQAA+L8UwAAAQJNVUVFRcO21137+4IMPPrZ169b7ZTKZAlsBIqJxzZo1M59//vnxp5122hR3BQMAAPx/CmAAAKDJOeWUUzqefvrpx/bu3ftL2Wy2jY0AH6e+vn7j0qVLH/vd7373x+uvv36ZjQAAAPlOAQwAADQJ2Ww2c+uttx5wyCGHnNC6deu9I8LdvsDWaFy7du1L06ZN+/OPfvSjZ1evXl1vJQAAQD5SAAMAALtU//79S6655pp/2nPPPY8tLy/vayPAZ1VTU7NswYIF488999wHp06dutFGAACAfKIABgAAdomf//znPU855ZQTu3btemRhYWGZjQDbW2NjY92KFSuevOWWW+689NJLF9kIAACQDxTAAADATuMxz8Cusn79+rlPP/30f5188slT6+rqcjYCAACklQIYAADY4fr27Vv8hz/84a+Pee5nI8CuUlNT8+68efPu/8EPfvDgwoULN9kIAACQNgpgAABghxkyZEjpNddc89XBgwefWFxc3MFGgKaitrZ21dy5c+/5yU9+8uc5c+bU2AgAAJAWWyqAPYoNAADYJqNHj+4wb968n06ZMuXRYcOGnaH8BZqa4uLi9sOGDTtjypQpj86bN++nJ510UntbAQAA0s4dwAAAwFY599xze33/+9//dufOnY/IZDJZGwGSIpfL1S1fvvzJG2644fbLLrvsbRsBAACSyiOgAQCAz+y8887r+53vfOfbHTt2PDyTyRTaCJBUuVyuYcWKFU/cdNNN//XrX/96sY0AAABJowAGAAC22WWXXTboG9/4xg9at249zDaAtFm7du2su++++9pzzjnnNdsAAACSQgEMAABsNcUvkE8UwQAAQJIogAEAgE9N8Qvks7Vr18665557rvv5z38+3zYAAICmaksFcGHlwOj6UV9orIqoWZG1PQAAyBO/+MUvet9xxx3nHHrooT8pLS3tYiNAPiotLe2y7777HvP973+/X1lZ2ZIpU6assxUAAKCpKetcHwXlH/01BTAAAOS5M844o/u99957zpe//OWflZeX94qIjK0AeS5TXl7e8+CDDx71/e9/v3dEvDVjxowPrQUAAGgqFMAAAMD/ceKJJ7a77777fjJq1Kh/KS8v7xOKX4B/lCkvL+99+OGHj/rWt77VfvXq1Qvnz59fbS0AAMCutqUC2DuAAQAgzwwdOrTs+uuvP6l///4nFRYWltkI20NjY2Ns2rQpqquro6amJurr62PTpk2xefPmqK+vj+rq6qivr4/NmzfHpk2boqGhYZv/fxUWFkZJSUk0a9YsioqKoqysLIqKiqJZs2ZRUlISRUVFUVpa+r9/FRQUCIjtoqGhoeq11167a8yYMffMmTOnxkYAAIBdZUvvAFYAAwBAnujUqVP2nnvuGbXXXnudnM1mK22Ej9PQ0BAbN26MDRs2/J+/Nm7cGBs3boyamprYtGlTbNq0KWpqaqK2trbJnqe4uDhKSkqitLT0f/9eUVERFRUV0aJFi//zV0VFRRQWFvog8LHq6urWvvjii7eceOKJf169enW9jQAAADubAhgAAPLcXXfdddAXv/jF00tLS7vZRn7L5XKxYcOGWLt2baxbty7Wrl37d3+tW7cuNmzYkPd7atGiRbRu3TpatWoVrVu3jjZt2vzvf27dunW0aNHCh4morq5e+sgjj1zzne98Z6ptAAAAO5MCGAAA8tTVV189+MQTTzyzoqJioG3kj8bGxli5cmUsX748Pvjgg1i9evX//n3t2rXR2NhoSZ9RYWFhtGrVKtq1axdt27b937937tw5OnTo4LHTeWbDhg3z77333qvOPPPMebYBAADsDApgAADIM1/72tfaXHrppad27979qIjQRKVUQ0NDrFq1KlasWBHvv//+//595cqVTfqRzGlXXFwcHTp0iI4dO0bnzp2jY8eO0alTp2jXrp1HS6dYLpdrfOeddx76+c9/fv2ECRPW2QgAALAjKYABACBP9OrVq9ldd931jT322OM7hYWFZTaSHh9++GG88847sXTp0njvvfdixYoVsXr16mhoaLCchCgsLIz27dtHp06dolu3btG9e/fo3r27x0mnTENDQ9W8efNu++Y3v/nHJUuWbLYRAABgR1AAAwBAHrjrrrtG/NM//dOZJSUlXWwj2davXx9Lly6Nd955539L3w8//NBiUqqysvJ/y+C//tWqVSuLSbiamppljz322G9Gjx49xTYAAIDtTQEMAAAp9qtf/arPD3/4w5+1atVqL9tIno0bN8aSJUvirbfeikWLFsV7770XmzZtspg8V1JSEl27do0+ffpE3759o3fv3lFeXm4xCbRu3bqXr7322ivGjh27yDYAAIDtRQEMAAApNGjQoNI77rjju7vttttJBQUFWRtJhtWrV8ebb74ZixcvjiVLlsTy5cujsbHRYtiigoKC6Ny5c/Tu3Tt69+4d/fr1i7Zt21pMQjQ2Nta98cYbd33rW9+6ff78+TU2AgAAfFYKYAAASJHS0tKCBx988Jj99tvvn7PZbBsbaboaGhri7bffjrfeeisWLFgQS5YscXcv201FRUX06tUr+vbtG3379o2ePXtGYWGhxTRhdXV1a2bMmHHjV77ylYdqamr85gcAALDNFMAAAJASp59+erdf/vKX51ZWVu5jG03T6tWr47XXXouFCxfGm2++GRs3brQUdooWLVpE3759Y8CAATFw4EB3CDdh69evf/E//uM//vPqq69+xzYAAIBtoQAGAICEGzRoUOm99977w969ex+byWTc4teErF+/PubNmxcLFiyIN954Q+FLk9GiRYvo169fDBgwIPbYY4+orKy0lCYkl8s1LF68eNyJJ554rcdCAwAAW0sBDAAACXbNNdcMOemkk35RVlbWyzZ2vVwuF++++27MnTs3XnvttViyZIl3+NLkFRQURK9evWLQoEExePDg6Natm6U0EdXV1UvuvvvuX//kJz+ZYxsAAMCnpQAGAIAEOuqoo1r99re//VmHDh0Ot41da9OmTTF79uyYO3duLFy4MKqqqiyFRGvevHn0798/Bg8eHHvuuWeUlJRYyi62cuXKp04//fTLJ0yYsM42AACAT6IABgCAhBk3btwRRxxxxFnZbLaNbewaVVVVMXfu3Jg7d27Mnz8/amtrLYVUKi4ujoEDB8bgwYNj8ODBUV5ebim7SF1d3ZqnnnrqqlGjRj1hGwAAwJYogAEAICFOOeWUjhdddNEvW7duvZ9t7HwrV66MWbNmxdy5c+Odd96JXC5nKeSdzp07x9577x3Dhg2LDh06WMgusHbt2hnnnXfepbfccsv7tgEAAHwUBTAAADRxpaWlBU899dQ3Bw8e/L2CggLPYt2JVqxYES+99FK89NJLsXz5cguBv/HXMnjvvfeOTp06WchO1NjYuGnu3Lk3H3744XfV1NR40TgAAPB3FMAAANCEjR49usOll176yzZt2gy3jZ1j/fr18eKLL8bMmTNj6dKlFgKfQs+ePWPfffeNYcOGRYsWLSxkJ1mzZs0L55577q/vvvvuVbYBAAD8lQIYAACaoIqKioKJEyd+c/Dgwd8vKCgotpEda8OGDfHiiy/G9OnTlb7wGfXo0SOGDx8ew4YNi4qKCgvZwdwNDAAA/CMFMAAANDGnnHJKx7Fjx/5rZWXlMNvYcerr6+PVV1+NGTNmxLx586Kurs5SYDvKZrMxZMiQ2HfffWP33XePwsJCS9mB1q5dO+MXv/jFv995550rbQMAAPKbAhgAAJqIbDabeeKJJ47fZ599fuSu3x0jl8vFwoULY/r06TF79uzYtGmTpcBOUFpaGkOGDInhw4fHgAEDLGQHaWhoqJ42bdo1Rx555J9tAwAA8pcCGAAAmoDjjz++7ZVXXvmr1q1be9fvDrBmzZqYNm1azJw5M1audHMc7EodO3aMz3/+87H//vt7X/CO+3fetDPPPPOScePGfWAbAACQfxTAAACwi9100037HXvssf9WXFzc1ja2n1wuF6+99lo8//zzMW/evKivr7cUaEKKiopizz33jBEjRsTnPve5yGQylrId1dbWrvrjH/948Q9+8INZtgEAAPlFAQwAALvIkCFDSu+///5zunTp8k+2sf2sXbs2Jk+eHNOnT48PP/zQQiABKisrY8SIEXHIIYdEeXm5hWxHy5Yte+zrX//6f86ZM6fGNgAAID9sqQAurBwYXT/qC41VETUrsrYHAADb6IILLtjt97///VVt2rQZZhvbx+LFi2P8+PFx9913xxtvvBG1tbWWAgmxadOmeOONN+LZZ5+NtWvXRps2bTweejtp0aJFv5NOOumg0tLSuc8+++xaGwEAgPQr61wfBR/zu7XuAAYAgO0sm81mJk2a9PVhw4b9pKCgwG9VfkZ1dXUxY8aMeOaZZ+K9996zEEiRfv36xSGHHBJDhw6NgoICC/mMGhsbN8+YMeOaL37xi+Pq6upyNgIAAOnlEdAAALCTHH/88W2vuuqqCyorK/exjc9mzZo18dRTT8XUqVNj06ZNFgIpVlFREZ///OfjsMMOi8rKSgv5jNavXz/r9NNPv3DcuHEf2AYAAKSTAhgAAHaC22677fNf+9rXzstms5W2se0WLVoUjz/+eMybNy9yOTewQT4pKiqKIUOGxBFHHBG9e/e2kM+grq5u3QMPPHDRySefPM02AAAgfRTAAACwA1VUVBQ8/fTTpwwcOPCUTCbjGabbIJfLxauvvhpPPvlkLFy40EIgz2UymRgwYEAcccQRMWjQIAvZ9n+3Ns6fP/+Www8//JaNGzc22ggAAKTHlgrgwsqB0fWjvtBYFVGzwuvKAABgS0488cR2EyZMuLx79+5fzmQyGRvZOo2NjTFr1qy49dZb48knn4wPPvC0UuC/rV69OmbMmBFz5syJ0tLS6NSpU/jX7NbJZDKZ9u3bD/3+978/dPny5TNfffXValsBAIB0KOtcHwXlH/O9gDuAAQBg29x66637H3vssRcWFRW1sI2tU1NTE0899VQ8++yzsWHDBgsBPlGLFi3i4IMPjsMPPzxKS/28YmvV19d/OG7cuPNPPvnk6bYBAADJ5xHQAACwHWWz2cyzzz77rSFDhvzAI5+3zqZNm2Ly5Mnx1FNPKX6BbdKiRYs47LDD4pBDDlEEb6VcLtfwyiuvXHfooYfeWVdX5yXrAACQYApgAADYTo455pjW11133cWVlZV728ant2HDhnj88cdjypQpUVtbayHAZ1ZcXBwHHnhgfPGLX4wWLTyIYWusWbNm2re//e3zn3nmGb+JAwAACeUdwAAAsB1cfvnlu1900UW/LS8v72cbn05VVVVMmDAhbrnllnjzzTejoaHBUoDtoqGhIZYsWRLPPfdc1NTURI8ePSKb9XOMT6OsrKzb17/+9SPbtm0774knnlhtIwAAkMDreu8ABgCAz+bhhx/+8qGHHnpOQUFBsW18sk2bNsUzzzwTTzzxRFRVVVkIsMOVl5fHkUceGYccckgUF/tX9afR2Ni46emnn/71Mccc87htAABAsngENAAAbKN27doVTZ48+YxevXodZxufrK6uLp5++umYOHGi4hfYJSoqKuKLX/xiHHzwwe4I/pQWLVr0x4MOOuiadevWeUwDAAAkhEdAAwDANjj22GPbPvzww7/p2LHjobaxZXV1dfHkk0/GddddF3Pnzo26ujpLAXaJzZs3x2uvvRbPPfdcRET06NEjCgsLLWYLWrduvfv3vve9fd9+++1pCxYsqLYRAABo+rb0CGgFMAAAfITLL7989wsuuOB3zZs372UbH6+xsTGmTJkS119/fbzyyiuKX6DJ2Lx5cyxYsCCmT58excXF0a1bt8hkMhbzMUpKSjp8+ctfPrJt27ZzvBcYAACaPu8ABgCArTB+/Pgjv/CFL/xLQUFBiW18vAULFsT48eNj6dKllgE0eT169IivfOUrMWjQIMvYgsbGxpqJEydecuyxxz5pGwAA0HR5BzAAAHwK7dq1K3ruued+1qNHj6/axsdbtGhR3H///bF48WLLABKnV69ecdxxx0WfPn0sYwuWLl3654MOOujy1atX19sGAAA0Pd4BDAAAn2DYsGHNn3766V936tTpC7bx0TZs2BD33Xdf/PGPf4y1a9daCJBI69evj2nTpsW6deuiZ8+eUVLiYQ8fpbKysv+3v/3t/lOmTJmyfPlyz/cHAIAmxjuAAQBgC372s5/1uP76669t0aKF54J+hJqamhg/fnzcfPPN8fbbb0cul7MUINFyuVy888478cwzz0RVVVX07t07slk/A/lHZWVl3U488cTD6+rqZkyfPv1DGwEAgCZ0va4ABgCAj3bFFVfscdZZZ11dXFzcwTb+Xi6XixkzZsR1110XCxYsiMbGRksBUqWxsTGWLFkSM2bMiPLy8ujSpUtkMhmL+RvZbLbFQQcddHibNm1mP/HEE6ttBAAAmoYtFcDeAQwAQN6aNGnSqAMOOODsTCZTaBt/b9GiRXHPPffEu+++axlA3ujWrVucdNJJ0bt3b8v4B7lcrm7y5Mm//vKXv/yIbQAAwK63pXcAK4ABAMg7paWlBTNnzjyzT58+x9vG39uwYUOMGzcuZsyY4VHPQF7KZDKx3377xde//vWoqKiwkH+waNGiP+27775X1dTUeCwEAADsQgpgAAD4H926dctOnjz5V506dRppG/9fLpeLqVOnxp///OfYuHGjhQB5r6KiIkaNGhX777+/x0L/g+XLlz9+6KGHXvLuu+/W2QYAAOwaWyqAvQMYAIC8MXz48PInnnjiynbt2o2wjf/vnXfeiWuvvTaee+652Lx5s4UARMTmzZtjzpw58dprr0XPnj2jRYsWlvI/Kioq+n7rW98aMnXq1Ofee+89f3AAAMAusKV3ACuAAQDIC9/+9rc73n777X9o0aLFANv4b1VVVXHXXXfFvffeG+vXr7cQgI+wbt26eP7552P9+vWx2267RVFRkaVERElJSefjjjvuoA8++GDKK6+88hcbAQCAnUsBDABAXjv//PP7XXzxxX8oKSnpbBv/bfr06XHttdfGokWLLAPgU3jnnXdi2rRp0bp16+jc2R8nERHZbLbyC1/4whElJSUvTp48eY2NAADAzqMABgAgb/3ud7/b60c/+tFVRUVFrWwjYs2aNXHzzTfHpEmTora21kIAtkJtbW289NJL8c4770Tfvn2jtLQ073dSWFhYNnz48C/26dNn4UMPPbTMpwQAAHYOBTAAAHnp1ltv3f+b3/zmfxYWFjbP913kcrl4/vnn4/rrr4/ly5f7cAB8BitXroxp06ZFRUVFdOvWLTKZTF7vo6CgIDto0KBDBw0atOiBBx54xycEAAB2vC0VwJmex8Z+H/WF+pURa17ym6wAACTTww8//KXDDjvsXzKZTN6/rPGDDz6I22+/Pd544w0fDIDtbMCAAfGtb30r2rRpk/e7yOVyjVOmTPn1yJEjH/LJAACAHavN3jVR1OGjv6YABgAgdV555ZXTPve5z30r3/fQ0NAQjz32WDz++ONRV1fngwGwg2Sz2Tj66KPjC1/4QhQUFOT9Pl5//fU79tprr9/7ZAAAwI6jAAYAIC9ks9nMyy+/fFafPn2Oz/ddvPvuu3HbbbfFe++954MBsJN069YtvvOd70S3bt3yfhdLliy5f5999rmypqam0ScDAAC2PwUwAACpV1paWjBr1qyzevfufVw+7yGXy8WTTz4ZDz74oLt+AXaBbDYbxxxzTBxxxBF5fzfw0qVLHxg6dOjlSmAAANj+FMAAAKRar169mk2ePHlsu3btDsrnPaxcuTJuueWWePvtt30oAHaxnj17ximnnBIdOnTI6z2sXr16yiGHHPIvS5Ys2exTAQAA28+WCuDCyoHR9aO+0FgVUbMia3sAADRpQ4cOLXvqqacub9Omzf75uoNcLhfPPPNMXH/99bF27VofCoAmYP369TFlypQoKSmJnj17RiaTycs9NG/evPtJJ500ZPLkyc+sWLHCoykAAGA7KetcHwXlH/01BTAAAIk1ZMiQ0kceeeSKVq1a7Z2vO6iuro7bb789nnjiiWhs9IRNgKaksbEx5s+fH++//34MGDAgstn8/DlLaWlpp6997WuDn3rqqadXrlxZ75MBAACfnQIYAIDUOfTQQ1s8+OCDv2/ZsuUe+bqDOXPmxNVXX+2RzwBN3PLly+OFF16Ijh075u0joUtLSzudcMIJ+7/00ktPv/3227U+FQAA8NkogAEASJVhw4Y1v++++37TsmXLQfl4/vr6+hg/fnz88Y9/jNpaP0MHSILNmzfHiy++GJs3b47ddtstCgoK8m4HxcXFbY866qg9n3vuuaeXL1/ucdAAAPAZKIABAEiNI488snLcuHG/b9GixcB8PP97770XV111VcyZM8eHASCBFi1aFC+//HL069cvWrRokXfnLykp6XDcccftP2fOnGcWLVq0yScCAAC2jQIYAIBUOPLIIyvvvPPO35aXl++Wj+d/+umn48Ybb4wPP/zQhwEgwf7yl7/ECy+8ECUlJdGrV6+8O3+zZs3aHHXUUfspgQEAYNspgAEASLxjjz227W233faH5s2b98m3s1dVVcXNN98cTz31VDQ2NvowAKRAY2NjzJ8/P5YtWxYDBgyIZs2a5dX5mzVr1uaYY4458M0333xm4cKFNT4RAACwdRTAAAAk2qGHHtritttuuzofy9+33347rrnmmli8eLEPAkAKvf/++/HKK69Enz59orKyMq/Ons1mK4888sh9Zs6c+dTSpUs3+zQAAMCnpwAGACCxjjjiiJb33nvvteXl5f3y6dy5XC4mTZoUN998c1RVVfkgAKRYVVVVTJ06NbLZbPTp0ycymUzenL24uLjtV7/61c+/8sorTy1evLjWpwEAAD4dBTAAAIl06KGHtrj33nt/l2/lb3V1ddx0000xefLkyOVyPggAeSCXy8WCBQvi3Xffjd133z2y2fz5mUyzZs1aH3300fvNmDHjSXcCAwDAp6MABgAgcYYOHVo2fvz4qysqKgbk07mXLVsWV111lUc+A+SplStXxiuvvBKf+9znoqKiIm/O3axZszZHH3300GeeeebJFStW1PkkAADAlimAAQBIlCFDhpQ++uij17Rs2XL3fDr31KlT49prr42NGzf6EADksaqqqpg+fXq0bds2unTpkjfnLikpaT9q1KihTz755JMrV66s90kAAICPt6UCuMB6AABoSjp16pSdMGHCv1dWVu6RL2dubGyMcePGxR133BF1dW56AiCitrY2br755hg/fnw0NjbmzbkrKyv3mDBhwr9369bNXQkAALCNFMAAADQZrVq1Kpw+ffolbdq02T9fzlxdXR2/+93vYtKkSd73C8DfyeVy8fjjj8fvf//7qK6uzptzt2nTZv8pU6Zc0qpVq0KfAgAA2HoKYAAAmoSKioqC2bNnX9KuXbuD8uXMS5cujYsuuijmz5/vAwDAx3r11VfjoosuiqVLl+bNmdu1a3fQ7Nmz/72iosLPrgAAYCu5iAYAoEmYOXPmz9q1a3dIvpz35ZdfjiuuuCLWrVsnfAA+0bp16+KKK66Il19+OW/O3K5du4Nnzpz5M+kDAMDWUQADALDLvfjii2N69OgxKh/Omsvl4oEHHogbbrghamtrhQ/Ap1ZbWxs33HBDPPDAA3nz2oAePXqMevHFF8dIHwAAPj0FMAAAu9SkSZO+NnDgwFPy4ax1dXVx8803x8SJE73vF4BtksvlYuLEiXHLLbdEXV1dXpx54MCBJ0+aNOlr0gcAgE9HAQwAwC7z6KOPHnXggQeekw9nXbduXfz617+OWbNmCR6Az2zmzJnx61//Ol9eJZA58MADz3n00UePkjwAAHyywsqB0fWjvtBYFVGzImtDAADsEDfeeOO+Rx999EWZTKYw7Wddvnx5XHXVVbFy5UrBA7DdbNiwIWbPnh0DBw6MioqKtB8307179/179uz56sMPP7xc+gAA5LuyzvVRUP7RX1MAAwCw011xxRV7fPe7372qoKCgWdrPOmfOnPjtb38bGzduFDwA2111dXVMmzYtOnfuHB07dkz1WTOZTOHuu+9+eJs2bV6aNGnSKukDAJDPFMAAADQZZ5xxRvef/exnvy0sLCxP+1knTJgQd999d9TX1wsegB2moaEhXnrppchms9G3b99UnzWTyRTttddeB/3lL395dubMmRukDwBAvlIAAwDQJBx00EEVf/jDH64pLi7ulOZz5nK5eOCBB+Kxxx4TOgA77c+eBQsWRF1dXfTv3z8ymUxqz1pQUFBywAEHDJs+ffqkpUuXbpY+AAD5aEsFcIH1AACwMwwaNKj0vvvuu7qsrKxXms9ZV1cX1113XUyaNEnoAOx0EydOjOuvvz7q6upSfc6ysrJef/rTn67u379/idQBAODvKYABANjhKioqCh577LGLKyoqBqb5nNXV1XHNNdfE7NmzhQ7ALvPKK6/ElVdeGVVVVak+Z4sWLQZOnDhxbEVFhZ9vAQDA33CBDADADjdz5syftW3b9sA0n3HdunVx2WWXxRtvvCFwAHa5xYsXx2WXXRZr165N9TnbtWt34MyZM38mcQAA+P8UwAAA7FBPPvnkqB49eoxK8xlXrVoVV1xxRSxfvlzgADQZK1asiCuuuCJWrlyZ6nP26NFj1KRJk0ZJHAAA/lth5cDo+lFfaKyKqFmRtSEAALbZjTfeuO+XvvSlCzOZTGp/8fDdd9+NK6+8MtatWydwAJqc6urqmDVrVvTv3z8qKytTe85u3boN79mz57yHH37Yb2MBAJAXyjrXR0H5R39NAQwAwA5x3nnn9T311FOvLigoKE7rGV977bW45pprorq6WuAANFmbN2+OGTNmRI8ePaJ9+/apPGMmkykYNGjQIYWFhVOee+45v5UFAEDqKYABANipjjrqqFb/8R//8YdmzZq1SusZX3755bj++uujrq5O4AA0eQ0NDfHSSy9Fp06dolOnTqk8Y0FBQXbYsGGfnz9//qQ33nhjk9QBAEizLRXA3gEMAMB21a1bt+wNN9zwnyUlJR3TesYpU6bEjTfeGPX19QIHIDHq6+vjxhtvjKlTp6b2jCUlJZ1uuOGG/+jWrZu7GgAAyFsKYAAAtqunn376XyorK/dI6/kmTZoUd955ZzQ2NgobgMRpbGyMO+64I5588snUnrGysnLw008//UtpAwCQrxTAAABsN88///w3unTp8k9pPd/EiRNj3LhxkcvlhA1AYuVyubj//vtTXQJ36dLlS88+++yJ0gYAIB95BzAAANvFTTfdNPzII488L5PJZNJ4vsceeyzGjx8vaABS47XXXotmzZpF3759U3m+zp0779urV695Dz/88DJpAwCQNlt6B7ACGACAz+wXv/hF7x/+8IdXFxQUNEvj+R544IF45JFHBA1A6ixYsCDq6upiwIABqTtbJpPJDBo06ODGxsbnpk6dul7aAACkiQIYAIAd5oADDqj43e9+99tmzZq1TeP5xo0bF5MmTRI0AKm1aNGi2Lx5cwwcODB1ZysoKMjut99+w5577rnH33vvvc3SBgAgLbZUAHsHMAAA2yybzWbuvPPOfyktLe2exvNNmDBB+QtAXpg0aVI89NBDqTxbaWlpj3vuuedfstlsRtIAAOQDBTAAANvs+eef/06HDh0OTePZHn744Xj44YeFDEDeeOSRR+LPf/5zKs/WoUOHw5599tlvSxkAgHygAAYAYJvcd999hw8ePPjUNJ7t/vvvjwkTJggZgLzz2GOPxX333ZfKs+25554/+NOf/nSYlAEASDvvAAYAYKudccYZ3ceMGXN5QUFBcdrONnHixHjkkUeEDEDeWrx4cWSz2ejbt2/ajpbp06fPvn/5y18mz5w5c4OkAQBIsi29A1gBDADAVhk2bFjzG2+88Q/NmjVrl7azPfroo6l99CUAbI2FCxdGUVFR9OvXL1XnKigoKD7wwAP3e/LJJx9dsWJFnaQBAEiqLRXAHgENAMBWuffee39ZWlraPW3nevzxx+PBBx8UMAD8jz//+c8xceLE1J2rtLS0x3333fdLCQMAkFYKYAAAPrVJkyaN6tSp0xEpPFeMHz9ewADwD8aPHx+TJ09O3bk6der0hUmTJn1VwgAApJFHQAMA8Kmcd955fU888cR/z2QyRWk618yZM+Puu+8WMAB8jNdeey06duwYnTt3TtW5unbtuk9BQcHzzz333DopAwCQNN4BDADAZ3LEEUe0vOKKK67NZrOVaTrXyy+/HDfffHPkcjkhA8DHyOVyMXv27OjSpUt06tQpNefKZDJF++yzz/CpU6c+9u67726WNAAASeIdwAAAbLNsNpu55ZZb/q2kpKRjms61YMGCuPnmm6OxsVHIAPAJGhsb4+abb44333wzVecqLS3tcvfdd5+fzWYzUgYAIC0UwAAAbNGkSZO+3rZt2wPTdKZly5bFDTfcEPX19QIGgE+prq4urr322li+fHmqztWuXbsDH3/88VESBgAgLTwCGgCAj3XZZZcN+upXvzo2k8mk5hcH33///bjyyiujqqpKwACwlerq6uLll1+OIUOGRHl5eWrO1aVLl31LS0unPvPMM2ukDABAEngENAAAW61///4lJ5988q8ymUxRWs60YcOG+P3vfx8bN24UMABso40bN8bvfve7VP15WlBQkP3hD394ft++fYslDABA4q9vrQAAgI/y4IMPnl1WVtYrLeeprq6O3/zmN7Fq1SrhAsBntGrVqrjyyiujuro6NWcqKyvr8/DDD58lXQAAkk4BDADA/zF+/Pgju3XrdnRazlNfX5/KdxYCwK60fPnyuO6666K+vj41Z+rRo8dXx40bd4R0AQBIMgUwAAB/53vf+16nI4444py0nCeXy8Vtt90Wb7zxhnABYDt7/fXX47bbbotcLpeaMx155JHnfvvb3+4oXQAAkkoBDADA/6qoqCi4+OKLLywsLCxPy5nGjx8fs2bNEi4A7CCzZs2Khx56KDXnKSwsrPj1r399QUVFhZ+bAQCQSC5kAQD4XxMnThxdWVk5OC3nef7552PixImCBYAd7LHHHosXXnghNeeprKzc89FHHz1RsgAAJFFh5cDo+lFfaKyKqFmRtSEAgDxxwQUX7DZq1KgLM5lMYRrO8+qrr8Ytt9ySqkdSAkBT/7O3d+/e0a5du1Scp2PHjkNzudxzU6ZMWSddAACamrLO9VHwMc/wcwcwAADRt2/f4h//+McXZzKZVPwG4HvvvRc33HBDNDY2ChcAdpKGhoa47rrrYtmyZak4T0FBQfbss88e27dv32LpAgCQqGtZKwAAYPz48T8qKyvrkYazbNiwIX7/+99HbW2tYAFgJ9u0aVP8/ve/j40bN6biPGVlZb3GjRs3RrIAACSJAhgAIM/ddNNNw/v06XN8Gs5SX18f1157baxdu1awALCLrFmzJq699tqor69PxXn69ev3jd///vdDJQsAQFIogAEA8thBBx1Uceyxx/5rRGTScJ477rgjFi9eLFgA2MUWLVoUd955Z1qOU/CNb3zj34YNG9ZcsgAAJOIC1goAAPLXzTfffFZxcXG7NJxl4sSJMX36dKECQBMxbdq0mDRpUirOUlJS0unOO+88Q6oAACSBAhgAIE/913/914FdunT5UhrO8tprr8Wf//xnoQJAEzN+/PhYsGBBKs7SrVu3o2+66abhUgUAoKlTAAMA5KEvfelLlV/5yld+lYazrFixIq6//vpobGwULAA0MY2NjXHdddfFihUr0nCczHHHHfergw46qEKyAAA0ZQpgAIA8dPXVV5+ezWYrk36OmpqauPbaa2PTpk1CBYAmatOmTXHttddGTU1N4s+SzWbb3njjjT+RKgAATZkCGAAgz9x6663Du3Tp8uWknyOXy8Utt9wSK1euFCoANHErV66MW2+9NXK5XOLP4lHQAAA0dQpgAIA8MnTo0LKvfvWrv0jDWSZMmBBz584VKgAkxJw5c+Kxxx5LxVlGjRr1i6FDh5ZJFQCApkgBDACQR+64444fFRcXd0z6OV5++eV45JFHBAoACfPQQw+l4he4SkpKOt5xxx0/lCgAAE2RAhgAIE9cfvnlu/fs2XNU0s/xwQcfxB133JGKR0gCQL7J5XJx2223xZo1axJ/lp49ex57+eWX7y5VAACaGgUwAEAe6NatW/a73/3uv2YymURf/9XX18cNN9wQ1dXVQgWAhKqqqoobb7wx6uvrE32OTCZT8N3vfvdX3bp1y0oVAICmRAEMAJAHxo8ff0pZWVmvpJ/jnnvuiaVLlwoUABJuyZIlcd999yX+HGVlZT3Hjx9/ikQBAGhKFMAAACn385//vOeAAQNGJ/0c06dPjylTpggUAFJi8uTJMWPGjMSfY8CAAaN//vOf95QoAABNhQIYACDFstls5qyzzjo3k8kk+tGEK1asiLvvvlugAJAyd911V6xYsSLRZ8hkMtmzzjrr3Gw2m5EoAABNgQIYACDFxo0b98XKysq9knyG2trauOGGG6K2tlagAJAyf/1zfvPmzYk+R2Vl5V7jxo0bKVEAAJoCBTAAQEoNHz68/OCDDz4t6ee4//77Y/ny5QIFgJRavnx5jBs3LvHnGDFixI+HDRvWXKIAAOxqCmAAgJS69dZbT8tms22TfIYZM2bEc889J0wASLnJkyfHzJkzE32G4uLitrfffvtp0gQAYFdTAAMApNBVV121R48ePb6S5DOsXLky7rrrLmECQJ64++6744MPPkj0GXr27PnVK664Yg9pAgCwKymAAQBSprS0tOAb3/jGT5N8rdfY2Bi333679/4CQB6pqamJ2267LRobG5N8jIJvfvObZ5aWlvqZGwAAu+6i1AoAANJlwoQJX6uoqBiQ5DOMHz8+Fi1aJEwAyDNvvvlmPPjgg4k+Q4sWLQY9+OCDx0gTAIBdRQEMAJAiRx55ZOWwYcN+kOQzzJ07N5544glhAkCemjhxYixYsCDRZxg+fPiPjjjiiJbSBABgV1AAAwCkyBVXXHFyUVFRRVLnr6qqijvvvDNyuZwwASBP5XK5uP3226O6ujqxZygqKmrxm9/85mRpAgCwKyiAAQBS4vzzz+/Xu3fv45J8httvvz0+/PBDYQJAnlu3bl3cfvvtiT5D7969jz///PP7SRMAgJ1NAQwAkALZbDZz6qmn/jyTyST2+m769OkxZ84cYQIAERExe/bsmDFjRmLnz2QyBaeeeurPs9lsRpoAAOxMCmAAgBT44x//eERlZeXgpM6/du3auPfeewUJAPyde+65J9atW5fY+SsrKwf/6U9/+oIkAQDYmRTAAAAJ17dv3+JDDjnkR0k+w9133x01NTXCBAD+Tk1NTdx9992JPsPBBx/8o759+xZLEwCAnUUBDACQcHfdddc3S0pKOiV1/smTJ8e8efMECQB8pLlz58azzz6b2PlLSko63nPPPd+SJAAAO4sCGAAgwb70pS9VDhw48KSkzr9mzZoYP368IAGALXrggQdizZo1iZ2/f//+Jx111FGtJAkAwM6gAAYASLArrrji1MLCwvIkzp7L5eK2226LTZs2CRIA2KJNmzbFbbfdFrlcLpHzFxYWll1++eU/kCQAADuDAhgAIKF+8Ytf9O7evftXkjr/s88+G2+88YYgAYBP5Y033ojnn38+sfN369bt6F/96ld9JAkAwI6mAAYASKgf/vCHP8pkMom8nvvggw/igQceECIAsFXGjRsX69atS+TsmUym4NRTT/2xFAEA2NEUwAAACXTdddcNa9eu3YFJnD2Xy8Udd9wRtbW1ggQAtsqmTZvizjvvTOz8bdq02f+mm27aT5IAAOxICmAAgIQpLS0t+NrXvnZ6Uud/4YUXYuHChYIEALbJq6++GjNmzEjs/Mccc8zpFRUVfiYHAMAO42ITACBhbr/99oMrKip2S+LsGzZsiHHjxgkRAPhM7r///qiqqkrk7OXl5X3/67/+6wgpAgCwoyiAAQASpKKiouCwww47Nanz33vvvYn9YS0A0HRs2LAh7r///sTOf9BBB/1zq1atCiUJAMCOoAAGAEiQ+++//+iysrKeSZx9zpw58dJLLwkRANguXnjhhViwYEEiZy8tLe32xz/+8StSBABgR1AAAwAkRN++fYv33Xfff07i7LW1tXHvvfcKEQDYru6+++6oq6tL5Oz77bffKf379y+RIgAA25sCGAAgIW6++eZRxcXFbZM4+yOPPBJr164VIgCwXa1atSoee+yxRM6ezWbb3njjjV+TIgAA25sCGAAgAYYOHVq21157fSeJs7/33nvxxBNPCBEA2CEmTpwYK1asSOTsQ4YM+c7QoUPLpAgAwPakAAYASIBrr732xKKiosqkzZ3L5eKee+6JxsZGIQIAO0R9fX3cddddkcvlEjd7UVFR5bXXXnuCFAEA2J4UwAAATdwBBxxQMWDAgG8kcfYZM2bEW2+9JUQAYId6880348UXX0zk7AMGDPjG8OHDy6UIAMD2ogAGAGjirrrqqhOKiooqkjb3pk2b4oEHHhAgALBT3H///VFbW5u4uYuKilpcffXV7gIGAGC7UQADADRhBx10UEX//v0Teffvww8/HB9++KEQAYCdYv369TFhwoREzj5w4MBvHHDAARVSBABge1AAAwA0Yf/5n/95bGFhYfOkzb1q1aqYPHmyAAGAnerpp5+O1atXJ27uwsLC8ssuu2yUBAEA2B4UwAAATdQBBxxQMWjQoNFJnP3uu++O+vp6IQIAO1V9fX3cddddiZx99913/+bQoUPLpAgAwGelAAYAaKIuv/zyYwsLC8uTNvfcuXNjwYIFAgQAdokFCxbE3LlzEzd3UVFRi9/97ndflyAAAJ+VAhgAoAkaOnRo2aBBgxL37t+6urr405/+JEAAYJf605/+FHV1dYmbe/fdd//mkCFDSiUIAMBnoQAGAGiCfvOb33ylqKioZdLmfu655xL53j0AIF1Wr14dzz33XOLmLioqann11VcfLUEAAD4LBTAAQBPTq1evZoMHD/5m0uaurq6ORx55RIAAQJPwyCOPRHV1deLmHjJkyLe6deuWlSAAANtKAQwA0MTcdNNNxxQXF7dN2twTJkyIqqoqAQIATUJVVVUifzmtuLi43a233uouYAAAtpkCGACgCWnVqlXhXnvtdVLS5l61alU8++yzAgQAmpTJkyfHqlWrEjf30KFDR7dq1apQggAAbAsFMABAE3LLLbccXlJS0jlpcz/44INRX18vQACgSamvr48HH3wwcXOXlJR0vummmw6VIAAA20IBDADQRGSz2cwBBxzw7aTNvWjRonjppZcECAA0SS+99FIsXrw4cXOPGDHiO9lsNiNBAAC2lgIYAKCJuOaaa/YuLy/vm7S5H3roocjlcgIEAJqkXC6XyLuAy8vL+1111VV7SRAAgK2lAAYAaCK+8pWvfDdpM8+bNy8WLlwoPACgSVu4cGG8+uqrrg8BAMgLCmAAgCbgsssuG1RZWblPkmbO5XIxfvx44QEAifDAAw8k7qklrVu33veSSy7pLz0AALaGAhgAoAkYNWrUCUmbefbs2bFs2TLhAQCJsGzZsnjllVcSN/cJJ5xwovQAANgaCmAAgF3sn//5nzt37NjxiCTN3NjYGA888IDwAIBEGT9+fDQ0NCRq5k6dOn1h9OjRHaQHAMCnpQAGANjFfvSjH30tk8kk6rps2rRpsWrVKuEBAImyatWqeOGFFxI1cyaTKfzpT386SnoAAHxaCmAAgF1o0KBBpX369Plqkmaur6+PCRMmCA8ASKQJEyZEXV1dombu27fvV/r27VssPQAAPg0FMADALnTZZZcdXlRUVJGkmadOnRpr164VHgCQSOvXr48pU6YkauaioqLK3/zmN0dIDwCAT0MBDACwi2Sz2cy+++57UpJmrqurc/cvAJB4jz76aOLuAt5///1PymazGekBAPBJFMAAALvI1VdfPbSsrKx3kmaeMmVKbNiwQXgAQKJt2LAhnn/++UTNXFZW1ueqq67aS3oAAHwSBTAAwC7y5S9/+bgkzVtfXx8TJ04UHACQCo8//nji7gL+0pe+dLzkAAD4JApgAIBdYPTo0R3atm07IkkzT5s2LdatWyc8ACAVPvzww5g+fXqiZm7fvv2I0aNHd5AeAABbogAGANgFfvrTn47KZDKFSZm3vr4+HnnkEcEBAKnyyCOPRH19fWLmzWQyhT/96U+/JjkAALZEAQwAsJN16tQp26dPn6OTNLO7fwGANFq3bl1MmzYtUTP36dPnmE6dOmWlBwDAx1EAAwDsZFddddUB2Wy2dVLmbWxsjEmTJgmOVOvYsWN06OCJmgD5aNKkSdHY2JiYebPZbOurrrrqAMkBAPBxFMAAADvZiBEjvp6keV988cVYtWqV4Ei1Ll26xIUXXhinnXZadO3a1UIA8siqVavipZdecj0JAEBqKIABAHaiM844o3tlZeXeSZk3l8vFxIkTBUdeyGQyMXjw4PjVr34VY8aMcUcwQB55/PHHI5fLJWbeysrKvc8444zukgMA4KMogAEAdqJTTjnlqxGRScq8CxYsiPfee09w5JVMJhN77713XHjhhTFmzJho3769pQCk3HvvvRcLFy5M1B9X/3NdCQAA/4cCGABgJ+nVq1ezXr16fTlJM3v3L/nsr0XwBRdcECeffHK0bdvWUgBSLGnXPb169fpyr169mkkOAIB/pAAGANhJrrjiioOLiopaJmXeBN4JAztEYWFhDB8+PC688MIYPXp0VFZWWgpACi1YsCCWLVuWmHmLiopaXnnllYdIDgCAf6QABgDYSYYPH/6VJM2btHfhwY5WVFQUI0aMiEsuuSRGjx4dLVu2tBSAFMnlcvH4448naub99tvvK5IDAOAfKYABAHaC0aNHd6isrByalHnXrl0bL7/8suDgI/y1CL744ovjhBNOiBYtWlgKQEq89NJLsW7dusTMW1lZudfo0aM7SA4AgL+lAAYA2AlOP/30o5J07fXMM89EQ0OD4GALiouL47DDDouxY8fGqFGjoqyszFIAEq6hoSGeeeaZJI1c8D/XmQAA8P8vEq0AAGDHymazmX79+n05KfPW1tbGlClTBAefUnFxcYwcOTIuvfTSGDVqVJSWlloKQII9//zzUVtbm5h5+/Xr9+VsNpuRHAAAf6UABgDYwX7zm9/sWVJS0jkp886YMSOqq6sFB1uppKQkRo4cGZdcckkcffTRUVJSYikACVRdXR0zZ85M0p8/na+44orBkgMA4K8UwAAAO9gXvvCFLyVl1lwuF08//bTQ4DNo3rx5HHXUUXHJJZfEyJEjI5vNWgpAwjz11FORy+USM++RRx75ZakBAPBXCmAAgB1oyJAhpZ07dz4iKfO+/vrrsWLFCsHBdlBeXh6jRo2KSy+9VBEMkDArVqyI119/PTHzdunS5fD+/ft79AQAABGhAAYA2KHGjh17aGFhYWJeCOruX9j+KioqYtSoUXHxxRfH4YcfHkVFRZYC4LpouyosLGz+H//xHwdLDQCACAUwAMAOteeeex6ZlFnXrl0b8+bNExrsIK1atYrjjz8+LrroohgxYkQUFPh2DKApmzdvXqxZsyYx8+61115HSg0AgAgFMADADnPMMce0bt269b5Jmfe5556LxsZGwcEO1qZNmxg9enRcfPHFimCAJqyxsTGee+65JP35MvyYY45pLTkAAPykAQBgBznzzDMPz2Qyibjeqq+vj6lTpwoNdqK2bdvG6NGj47zzzovhw4crggGaoBdeeCHq6+sTMWsmkyk844wzDpUaAAB+wgAAsIP079//C0mZdc6cObFhwwahwS7QqVOnOPnkk+Pf/u3fYu+9945MJmMpAE3Ehg0bYvbs2YmZd8CAAR4DDQCAAhgAYEf43ve+16mysnKPpMybpMcbQlp17tw5xowZE7/61a8UwQBNyPPPP5+YWSsrKwd/73vf6yQ1AID8pgAGANgBTj755CMiIhHtzcqVK+P1118XGjQRXbt2jTFjxsQ555wTgwcPthCAXez111+PlStXJmXczMknn3y41AAA8psCGABgB+jXr19iHv88ZcqUyOVyQoMmpnfv3nHaaafFOeecE/3797cQgF0kl8vFlClTknQd6jHQAAB5TgEMALCdnX766d0qKip2S8Ks9fX1MW3aNKFBE9anT58466yz4pxzzonddtvNQgB2gWnTpkV9fX0iZq2oqNjt9NNP7yY1AID8pQAGANjORo8efURSZp03b15s3LhRaJAAffr0ibPPPjvOPPPM6Nmzp4UA7EQbN26MefPmuR4FACARFMAAANtZr169EvPetSQ9zhD4bwMGDIhf/vKXceaZZ0b37t0tBGAnmTp1apKuRw+TGABA/lIAAwBsR2eccUb38vLyvkmYdf369fHaa68JDRJqwIAB8S//8i9x2mmnRbdunvQJsKPNnz8/Pvzww0TMWl5e3u9HP/pRF6kBAOQnBTAAwHZ03HHHHZSUWWfMmBGNjY1CgwTLZDIxePDg+Nd//dcYM2ZMdOjQwVIAdpDGxsaYMWNGYub9xje+cYjUAADykwIYAGA76tOnz8FJmDOXyyXqMYbAlmUymdh7773jwgsvjDFjxkT79u0tBWAHeOGFF5J0XXqIxAAA8pMCGABgOznppJPat2zZcvckzLpkyZJYuXKl0CBl/loEX3DBBXHyySdH27ZtLQVgO1qxYkW8/fbbiZi1srJy0PHHH+8PAgCAPKQABgDYTr773e8eGBGZJMyapMcXAluvsLAwhg8fHhdeeGGMHj06KisrLQVgO5k+fXpSRi34/ve/f6DEAADyjwIYAGA72X333Q9Nwpz19fUxc+ZMgUEeKCoqihEjRsQll1wSo0ePjpYtW1oKwGc0c+bMqK+vT8SsAwcOPFRiAAD5RwEMALAdHHTQQRUtW7bcKwmzLly4MKqrq4UGeeSvRfDFF18cJ5xwQrRo0cJSALZRVVVVvP7664mYtVWrVkOHDx9eLjUAgPyiAAYA2A7OPvvsz2cymaIkzOrxz5C/iouL47DDDouxY8fGqFGjoqyszFIAtkFSnqaSyWSy55577uclBgCQXxTAAADbwe67735AEuasra2NOXPmCAzyXHFxcYwcOTIuvfRSRTDANpg9e3bU1dUlYtY99tjjAIkBAOQXBTAAwGfUqlWrwnbt2u2fhFnnzZsXtbW1QgMiIqKkpCRGjhwZY8eOjaOPPjpKSkosBeBT2LRpU8ybNy8Rs7Zv337/iooKPwMEAMgjLv4AAD6jCy+8cPeioqKKJMz64osvCgz4P5o3bx5HHXVUXHLJJTFy5MjIZrOWAvAJZs2alYg5i4qKWlx88cWDJAYAkD8UwAAAn9GBBx6YiMfqVVdXJ+ZOFWDXKC8vj1GjRsWll16qCAb4BPPmzYuamppEzHrQQQd5DDQAQB5RAAMAfEZdu3YdnoQ5582bF/X19QIDPlFFRUWMGjUqLr744jj88MOjqKjIUgD+QV1dXbz66quJmLVLly77SwwAIH8ogAEAPoNTTjmlY3l5+W5JmPXll18WGLBVWrVqFccff3xcdNFFMWLEiCgo8C0kwN966aWXEjFnRUXFbieddFJ7iQEA5AffvQMAfAYnnnji55MwZ21tbcyfP19gwDZp06ZNjB49OsaOHasIBvgb8+fPj9ra2iSMmvnud7/7eYkBAOQH37UDAHwGn/vc5/ZLwpwLFy6Muro6gQGfyV+L4PPOOy+GDx+uCAby3ubNm2PhwoWJmLVfv37DJQYAkB98tw4AsI1atWpV2Lp1672TMKvHPwPbU6dOneLkk0+Oc889NwYNGmQhQF6bPXt2IuZs06bN3hUVFX4WCACQB1z0AQBso/PPP39gYWFheVOfs76+PubMmSMwYLvr2bNn/OQnP4nzzjsv9t5778hkMpYC5J3Zs2dHfX19k5+zqKio4vzzzx8oMQCA9FMAAwBso/3333/fJMz5+uuvR01NjcCAHaZLly4xZsyYOOecc2Lw4MEWAuSV6urqeOONNxIx64EHHriPxAAA0k8BDACwjbp27ZqIxz/PnTtXWMBO0bt37zjttNPinHPOif79+1sIkDeScr3VvXv3vaUFAJB+CmAAgG0wZMiQ0srKyj2a+py5XM7jn4Gdrk+fPnHWWWfFOeecE7vttpuFAKk3e/bsyOVyTX7Oli1b7jlo0KBSiQEApJsCGABgG5x55pl7ZjKZbFOfc9myZbFu3TqBAbtEnz594uyzz44zzzwzevbsaSFAaq1bty6WL1/e5OfMZDLZs846a4jEAADSrcgKAAC23tChQ4clYc558+YJC9jlBgwYEAMGDIgFCxbE+PHjY+nSpZYCpM68efOiS5cuTX7OffbZZ5+ImC4xAID0cgcwAMA26Nix4z5JmHP+/PnCApqMAQMGxC9/+cs47bTTolu3bhYCpEpSrrs6deq0j7QAANJNAQwAsJWOOOKIlhUVFf2a+pxVVVWxaNEigQFNSiaTicGDB8e//uu/xpgxY6JDhw6WAqTCW2+9FVVVVU1+zoqKis8deuihLSQGAJBeCmAAgK108sknD46ITFOfc/78+dHY2CgwoEnKZDKx9957x4UXXhhjxoyJ9u3bWwqQaI2NjbFgwYJE/Cv4u9/97h4SAwBILwUwAMBW2n333fdMwpze/wskwV+L4AsuuCBOPvnkaNu2raUAiZWU66/BgwfvKS0AgPQqsgIAgK3Trl27wU19xlwul5Q7UAAiIqKwsDCGDx8e++yzT0ybNi0mTJgQ69evtxggURYsWBC5XC4ymab9sJgOHToMlhYAQHq5AxgAYCsMGjSotGXLlgOa+pzvvfdebNy4UWBA4hQVFcWIESPikksuidGjR0fLli0tBUiMDz/8MJYtW9bk52zZsuXA/v37l0gMACCdFMAAAFvhxz/+8aBMJtPkn6Li7l8g6f5aBI8dOzZOOOGEaNGihaUAibBw4cImP2Mmk8n+5Cc/GSAtAIB0UgADAGyFvffee88kzJmEHzwCfBrNmjWLww47LMaOHRujRo2KsrIySwGatKT8Il5SrmsBANh63gEMALAVunbtOqSpz1hfXx9vvvmmsIBUKS4ujpEjR8bBBx8czz77bDz++ONRXV1tMUCT8+abb0Z9fX0UFTXtH7t16dJlT2kBAKSTO4ABAD6lioqKgoqKikFNfc4lS5bE5s2bBQakUklJSYwcOTLGjh0bRx99dJSUeIUl0LTU1tbG0qVLm/ycLVu2HFRaWupngwAAKeQiDwDgUzr77LP7FhYWNvlnj7722mvCAlKvefPmcdRRR8Ull1wSI0eOjGbNmlkK4HpsKxQWFpafffbZvaQFAJA+CmAAgE9p//3375+EOV9//XVhAXmjvLw8Ro0aFf/+7/8eI0eOjGw2aymA67FP6fOf//xAaQEApI8CGADgU+rRo8fuTX3G2traePvtt4UF5J2KiooYNWpUXHzxxXH44Yc3+XdvAum2ePHiRLySo1evXoOkBQCQPgpgAIBPqXXr1k3+DoklS5ZEQ0ODsIC81apVqzj++OPj4osvjhEjRkRBgW97gZ2voaEhlixZ0uTnbNOmjQIYACCFfCcMAPApDBkypLR58+a9m/qcb775prAAIqJ169YxevToGDt2rCIYcF32MZo3b95n0KBBpdICAEgX3wEDAHwKp556av9MJtPkr53eeustYQH8jTZt2sTo0aPjvPPOi+HDhyuCAddlfyOTyRT84Ac/+Jy0AADSxXe+AACfwuDBg5v84/Hq6+tj0aJFwgL4CJ06dYqTTz45/u3f/i323nvvyGQylgLsUIsXL07Eqzn23HPPgdICAEgXBTAAwKfQpUuXAU19xnfeeSfq6uqEBbAFnTt3jjFjxiiCgR2utrY23n333SRc53oPMABAyiiAAQA+hZYtW/Zv6jN6/DPAp9elS5cYM2ZMnHvuuTF48GALAfL2+iwJ17kAAGwdBTAAwCcYPnx4eUlJSeemPqfHPwNsvV69esVpp50W55xzTvTvrwMB8u/6rLS0tPPw4cPLpQUAkB4KYACAT/Ctb31rt4ho8s8IXbx4sbAAtlGfPn3irLPOinPOOSd22203CwG2i4T8gl7m29/+dj9pAQCkhwIYAOAT7L777k2+CVi7dm1s2LBBWACfUZ8+feLss8+OM888M3r27GkhwGfy4Ycfxrp165r8nAMHDlQAAwCkSJEVAABsWadOnZr8D8TefvttQQFsRwMGDIgBAwbEggULYvz48bF06VJLAbb5Oq1Vq1audwEA2GkUwAAAn6CyslIBDJCnBgwYEP3794958+bFQw89FO+++66lAFtlyZIlsddeezX1613PvgcASBEFMADAFnTq1CnbvHnzXk19ziVLlggLYAfJZDIxePDg2GOPPeLll1+OBx98MFauXGkxQGqu05o3b967Xbt2RatXr66XGABA8nkHMADAFowZM6ZnJpPJNuUZGxsbPZoUYCfIZDKx9957x4UXXhhjxoyJ9u3bWwrwiZYuXRqNjY1NesaCgoLsqaee2kNaAADp4A5gAIAt2Hvvvfs29RlXrlwZtbW1wgLYSf5aBO+5554xa9asmDBhQqxevdpigI9UW1sb77//fnTu3LlJzzls2LC+EbFIYgAAyecOYACALejRo0eTL4DfeecdQQHsAoWFhTF8+PC48MILY/To0VFZWWkpQGKv15Jw3QsAwKejAAYA2ILWrVs3+ff/vvvuu4IC2IUKCwtjxIgRcckll8To0aOjZcuWlgIk7notCde9AAB8Oh4BDQCwBc2bN+/Z1GdUAAM0kW+wi4pixIgRsd9++8WUKVPiscceiw0bNlgMEO+9914SrnsVwAAAKeEOYACAj9G/f/+SkpKSjk19TgUwQNPSrFmzOOyww2Ls2LExatSoKCsrsxTIc0m4XistLe3Ut2/fYmkBACSfAhgA4GOccMIJ3Zr69dK6deuiqqpKWABNUHFxcYwcOTJ+/etfK4Ihz1VVVcX69eub+pgF3/zmN7tLCwAg+RTAAAAfY8iQIT2b+oxJeJwgQL77axE8duzYOProo6OkpMRSIA8l4botCde/AAB8MgUwAMDH6N69e8+mPqPHPwMkR/PmzeOoo46KSy65JEaOHBnNmjWzFMgjSbhuS8L1LwAAn0wBDADwMVq1atWjqc+4bNkyQQEkTHl5eYwaNSr+/d//PUaOHBnZbNZSIA8k4botCde/AAB8MgUwAMDHqKio6NXUZ1y+fLmgAJL750yMGjUqLr744jj88MOjqKjIUiDFknDd1rJly16SAgBIPgUwAMBHyGazmbKysq5NecbGxsZYtWqVsAASrlWrVnH88cfHxRdfHCNGjIiCAt+qQxqtWrUqGhsbm/SMJSUlXbPZbEZaAADJ5rtKAICPcNxxx7UrKCgobsozrl69Ourr64UFkBKtW7eO0aNHx9ixYxXBkEJ1dXXxwQcfNOkZCwoKio877rh20gIASDbfTQIAfITPf/7zXZr6jO+//76gAFKoTZs2MXr06Dj//PNj+PDhimBIkRUrVrgOBgBgh/NdJP+PvTuPr7I888d/nSwEkhD2HUQEUVRAoIiouCtq64Jabd1arVorbqO2tlXbaavTOu38Rqffdmpbu9rWpYogsqgFRXCttAIKArJDgAAJBLKQ5JzfH8WO4+DOcp6T9/v18jWvTv657ut6hNvnk/t+AICd2G+//bL+xVcSXiAC8PF17do1Lr300rj99ttj2LBhkUq5lRWSLgn7tyTsgwEAeH8FWgAA8H917txZAAxAVujevXtceeWVsXr16njiiSdi9uzZkclkNAYSKAn7tyTsgwEAeH8CYACAnWjXrp0roAHIKj169Igrr7wyli5dGpMmTYo5c+ZoCiRMEvZvSdgHAwDw/gTAAAA7UVxc3D3baxQAAzRPffr0ibFjx8aSJUti/PjxsWDBAk2BhEjC/i0J+2AAAN6fbwADAOxESUlJz2yur7q6Ourq6gwKoBnbb7/94l/+5V/ia1/7WhxwwAEaAglQV1cX1dXV9sEAAOxWAmAAgHc5/PDDSwsKCtpmc40VFRUGBUBERPTt2zduvPHGuOGGG2LffffVEMhy2b6PKygoaDt8+PASkwIASC4BMADAu5x44oldsr3GDRs2GBQA/8uAAQPiG9/4Rtxwww3Ru3dvDQH7uE+yH+5qUgAAyeUbwAAA79KvX7+sD4DXr19vUADs1IABA+LAAw+MuXPnxoQJE2LlypWaAlkkCTe5HHDAAV0i4i3TAgBIJgEwAMC7dO/evXO21+gEMADvJ5VKxaBBg2LgwIExe/bsGD9+fKxbt05jwD4uZ/bDAAC8NwEwAMC7tG/fvlO21ygABuDDSKVSMWzYsBg6dGjMnj07HnvsMbdIwF6WhBPASdgPAwDw3gTAAADv0rp166w/8ZCEF4cAZI+3g+BDDz00XnnllZg4caK/S8A+LtH7YQAA3psAGADgXUpKSrL6xENjY2Ns3rzZoAD4yPLz8+Pwww+P4cOHx/PPPx8TJ06MqqoqjYE9aPPmzdHY2BgFBdn7Wi7b98MAALw/ATAAwLu0bNmySzbXV1lZGZlMxqAA+Njy8/Nj1KhRMXLkyHjhhRcEwbAHZTKZqKqqio4dO9oPAwCwWwiAAQDepaioKKuvvKusrDQkAHaJgoKCGDVqVIwYMSJmzpwZkydPji1btmgM7IH9XDYHwNm+HwYA4P3laQEAwP8YPnx4SX5+fkk21ygABmBXa9GiRRx//PFxxx13xNlnnx0lJSWaAs14P5efn18yfPhwfxAAACSUABgA4B2OOOKIDtleo+//ArC7FBUVxejRo+P73/9+nH322VFcXKwpsBsk4cr1JOyLAQDYOQEwAMA79O3bt1221+gEMAC729tB8B133BGnn356tGrVSlOgme3n9ttvv7YmBQCQTAJgAIB36NSpkwAYAHYoKSmJz3zmM3HnnXfG6NGjo0WLFpoCzWQ/l4R9MQAAOycABgB4hw4dOrTN9hqTcGUgALmlpKQkzj777PjOd74To0aNivz8fE2BHN/PJWFfDADAzgmAAQDeoaysrG221ygABmBvad++fVx00UVx5513xgknnBCFhYWaAjm6nysrK3MCGAAgoQTAAADvUFJS0j6b68tkMlFdXW1QAOxV7dq1i/POOy+++93vxqhRoyIvz+sF+CiSsJ8rLS0VAAMAJJT/QgMAeIfi4uK22VxfXV1dNDY2GhQAWeHtE8F33HGHIBg+gsbGxqirq7MvBgBgt/BfZgAA79CqVausPung9C8A2ahDhw5x0UUXxbe//e04/PDDBcGQA/u6oqIiJ4ABABLKf5EBALxDQUGBABgAPqauXbvGpZdeGt/61rdi2LBhkUqlNAUSuq9r0aJFW1MCAEimAi0AAPgfhYWFZdlc39atWw0JgKzXrVu3uPLKK2P16tXxxBNPxOzZsyOTyWgMJGhfl+37YgAA3psAGADgnZujgoLW2VyfE8AAJEmPHj3iyiuvjKVLl8akSZNizpw5mgIJ2ddl+74YAID35gpoAIAdWrdunZefn98ym2sUAAOQRH369ImxY8fGLbfcEgMGDNAQSMC+Lj8/v1WrVq28OwQASCCbOACAHQYNGlQSEVn9scJt27YZFACJtd9++8UNN9wQX/va1+KAAw7QEJq1BOzr8gYPHlxsUgAAySMABgDY4YADDijJ9hpramoMCoDE69u3b9x4441xww03xL777qshNEu1tbVZX2P//v1LTQoAIHl8AxgAYIeePXtm/QuuJLwoBIAPa8CAATFgwICYP39+jBs3LpYvX64pNBtJ2Nf16NGjxKQAAJJHAAwAsEOnTp0EwACwFwwYMCAOPPDAmDt3bkyYMCFWrlypKeS8JOzrunbtKgAGAEggATAAwA5lZWVZ/4Krrq7OoADISalUKgYNGhQDBw6M2bNnx4QJE2Lt2rUaQ85KQgDcpk0bV0ADACSQABgAYIeysjIngAFgL0ulUjFs2LAYOnRozJ49O8aPHx/r1q3TGHKOABgAgN1FAAwAsENJSUlxttfoBDAAzcXbQfCQIUPi5ZdfjokTJ0ZFRYXGkDOSEAAnYX8MAMD/JQAGANihqKioKNtrrKmpMSgAmpW8vLw4/PDDY/jw4fH888/HE088EZWVlRpD4iUhAG7RokWRSQEAJI8AGABgh8LCwhbZXF86nY7t27cbFADNUn5+fowaNSpGjhwZL7zwQkycODGqqqo0hsTavn17ZDKZSKVSWVtjixYtWpgUAEDyCIABAHbI9gC4oaHBkABo9goKCmLUqFExYsSImDlzZkyePDm2bNmiMSROJpOJhoaGyOaMtbCw0AlgAIAk/neTFgAA7NgYFRRk9QuuxsZGQwKAHVq0aBHHH398HHnkkfHMM8/E1KlTY9u2bRpDomR7AJzt+2MAAN5jH6cFAAA7NkZZ/oLL9c8A8H8VFRXF6NGj49hjj41nnnkmpkyZEjU1NRpDImT7DS8FBQWugAYASCABMADA2xujLH/B5QpoAHhvbwfBRx11VEyfPj2efvrpqK2t1RiymgAYAIDdIU8LAAD+QQAMAMlXUlISn/nMZ+LOO++M0aNHZ/X1uiAABgBgdxAAAwDskO1XQAuAAeDDKykpibPPPjv+7d/+LUaPHh2FhYWagv3dR5Sfn9/SlAAAkkcADADw9sYoL88JYADIMa1bt46zzz47vve978UJJ5wgCMb+7iPIz8/3LwwAQAIJgAEAdkilUlm9N2psbDQkAPiY2rVrF+edd15897vfjRNOOCEKCgo0Bfu7D94f55sSAEDyCIABAHbI9gA4nU4bEgB8Qu3bt/9nEDxq1KjIy/NqBPu799kfp0wJACB5/FcOAMAOXnABQPPRoUOHuOiii+J73/ueIJi9JpPJZHuJ/sUAAEggmzgAgP+R1QFwAl4QAkDidOzYMS666KL41re+FYcffnj4fTDs796xOc7yG3IAANg5mzgAgITsjQTAALD7dOvWLS699NL41re+FcOGDRMEs0dk+xXQeXl5/kUAAEigAi0AAPiHbH/BJQAGgN2ve/fuceWVV8ayZcviiSeeiDlz5mgKzXl/5/AIAEACCYABAHbIZDJOAAMAERGx7777xtixY2PJkiUxYcKEmD9/vqZgfwwAQCIIgAEA/ocr7gCA/2W//faLG264Id56660YP358vPnmm5rCLpPtV0Cn3IUOAJBIAmAAgB2y/QVXtr8gBIBc1rdv37jxxhvjrbfeinHjxsWiRYs0hU/MFdAAANjEAQDsXln9Bs4BDADY+/r27Rs333xz3HDDDdG7d28NIdf3d75BAgCQQE4AAwDskO0nMATAAJA9BgwYEAMGDIj58+fHI488EitXrtQUcnF/5woaAIAEcgIYAGCHVCqVzvL6DAkAssyAAQPi1ltvjbFjx0bPnj01hJza32UScEc1AAD/lxPAAAD/QwAMAHysv6MHDRoUBx98cDz//PMxadKk2LRpk8aQ+P1dtv+CJAAAO+cEMADADul0dr/fEgADQHarr6+PioqK2LZtm2aQE/u7dDrtBDAAQAI5AQwA8D+cAAYAPrK6urp4+umnY9q0acJfcm1/5wQwAEACCYABAP6HEw4AwIfW0NAQ06ZNiyeffDK2bt2qIXxkCfgGsAAYACCBBMAAADtkMpmsDoDz8ny9AwCywdvB71NPPRXV1dUaQs7u7wTAAADJJAAGANgh219wCYABYO9qbGyMGTNmxJNPPhmVlZUawieWn5+f9VtkUwIASB4BMADADplMpiGb6yssLDQkANgL0ul0zJo1KyZPnhwbN27UEHaZgoLsfjXX1NTUaEoAAAncZ2oBAMA/NDY2bs/m+gTAALBnpdPpePnll2Py5Mmxdu1aDWGXa9GiRbb/O1BvSgAAySMABgDYoampSQAMAEQmk4nZs2fH448/HuXl5RpCs93fNTY2CoABABJIAAwAsENDQ0NWv+ASAAPA7vV28PvEE0/E6tWrNYTdLtuvgM72G3IAAHiPfaYWAAD8gyugAaD5mjNnTkyaNCmWLl2qGewx2X4FtAAYACCZBMAAADs0NTU5AQwAzcyCBQtiwoQJ8dZbb2kG9nfv0tDQIAAGAEggATAAwA7Z/oJLAAwAu87ChQtj/PjxsXjxYs1gr8n2K6Cz/RckAQB4j32mFgAA/EO2B8AFBQWRl5cX6XTasADgY1q+fHmMGzcu5s+frxnsVXl5eVkfAG/fvt0JYACABBIAAwDs0NDQkPUnHFq1ahXbtm0zLAD4iFauXBmPPPKI4Jes2tclYH8sAAYASCABMADADrW1tXXZXqMAGAA+mnXr1sX48eNj9uzZkclkNISs2tdlu7q6ulqTAgBIHgEwAMAOW7du3ZrtNSbhRSEAZIP169fHY489JvjFvu4TqK6u3mpSAADJIwAGANihqqpKAAwACbdhw4Z4/PHH45VXXommpiYNwb7uE6isrHT1DABAAgmAAQB22LRpU9a/4GrZsqVBAcBOVFVVxcSJE+OFF16IxsZGDSHrJSEA3rRpkxPAAAAJJAAGANhh3bp1WR8AOwEMAP/bli1bYsKECYJfEicJ+7ry8nIBMABAAgmAAQB2WLZsmSugASAhqqurY/LkyTFz5syor6/XEBInCfu6pUuXCoABABJIAAwAsMP8+fOz/gRwcXGxQQHQrNXU1MSUKVPimWeeEfySaEnY173++uu+AQwAkEACYACAHRYsWFCXyWQaUqlUYbbW2Lp1a4MCoFmqq6uLp59+OqZNmxbbtsmkSL5s39el0+mGpUuXbjcpAIDkEQADALxDU1PTtoKCgrbZWp8AGIDmZvv27TF9+vR48sknY+tWt9GSO7J9X9fU1ORfOACAhBIAAwC8Q0NDw9ZsDoBLS0sNCYDm8ndyTJs2LZ566qmorq7WEHJOtu/rGhsb/YsHAJBQAmAAgHeor6+vbNWqVc9src8JYAByXWNjY8yYMSOefPLJqKys1BByVrbv6+rr66tMCQAgmQTAAADv0NDQkNVvmgXAAOSqdDods2bNismTJ8fGjRs1hJyX7fu6bN8XAwDw3gTAAADvUFdXV5XN9ZWWlkYqlYpMJmNYAOSETCYTr732Wjz++OOxatUqDaFZSKVSUVJSktU11tbWVpkUAEAyCYABAN5h27Ztm7K5vvz8/GjVqlXU1NQYFgCJlslkYvbs2fH4449HeXm5htCstGrVKvLz87O6xq1btzoBDACQUAJgAIB3qK6u3pztNZaVlQmAAUist4PfiRMnxpo1azSEZqmsrCzra9y2bVuVSQEAJJMAGADgHaqqqjZle43t2rWLtWvXGhYAiTNnzpyYNGlSLF26VDNo1tq1a5f1NW7atMkJYACALNbQWBgFjQ0REZFKRSavMJre/pkAGADgHSoqKqqyvcYkvDAEgHdasGBBTJgwId566y3NgITs5zZs2CAABgDIYoUFDf9MejMRqab0/+S+AmAAgHdYtWpV1r/oatu2rUEBkAgLFy6M8ePHx+LFizUD3iEJAfDq1aurTAoAIJkEwAAA77BgwYKsD4CdAAYg2y1fvjzGjRsX8+fP1wzYiST8Ql8S9sUAAOycABgA4B2eeOKJjZlMpimVSuVna41OAAOQrVauXBmPPPKI4Bc+QLb/Ql8mk2l64oknNpoUAEAyCYABAN6huro6vX379g1FRUVdsrVGJ4AByDZr166NCRMmxOzZsyOTyWgIJHw/t3379g3V1dVpkwIASCYBMADAu9TV1a0XAAPAB1u/fn089thjgl/Isf1cXV3delMCAEguATAAwLvU1dVVtGnTJmvrKykpiRYtWsT27dsNC4C9oqKiIiZOnBivvPJKNDU1aQh8BEVFRVFcXJz1+2GTAgBILgEwAMC7bN26dV2XLll7ADhSqVR07Ngx1qxZY1gA7FFVVVUxceLEeP755wW/8DF17NgxUqlU1u+HTQoAILkEwAAA71JVVZX1Jx46deokAAZgj9m8eXM8/vjj8cILL0RjY6OGwCfcx9kPAwCwOwmAAQDeZf369Vn/zbMkvDgEIPm2bNkSU6ZMiZkzZ0Z9fb2GwC7QsWNH+2EAAHYrATAAwLusXr066088JOHFIQDJVVNTE1OmTIlnnnlG8Au7WBJ+kW/VqlUCYACABBMAAwC8y9///ves/+aZABiA3aG2tjYmT54czz77bNTV1WkINNN93KuvvioABgBIMAEwAMC7PPzww+t//OMfN6RSqcJsrbFz584GBcAus3379pg+fXpMnTo1tm3bpiGwG2X7CeB0Ot3w8MMPC4ABABJMAAwA8C7V1dXpurq68latWu2TrTV26NAh8vLyIp1OGxgAH1tDQ0NMmzYtnnrqqaiurtYQ2M3y8vKiQ4cOWV1jfX39mtraWptMAIAEEwADAOxEbW3tmmwOgAsKCqJdu3axceNGwwLgI2tsbIwZM2bEk08+GZWVlRoCe0j79u2joCC7X8fV1NSUmxQAQLIJgAEAdmLz5s2r2rdvn9U1duvWTQAMwEeSTqdj1qxZMXnyZH+HwF7av2W7LVu2rDQpAIBkEwADAOzEpk2bVvfp0yera+zWrVvMmzfPsAD4QG8Hv1OmTIkNGzZoCOzF/Vu227BhwxqTAgBINgEwAMBOrFixYvWwYcOyusYkvEAEYO/KZDLx0ksvxZQpU6K83K2usLd17do162tctWrVKpMCAEg2ATAAwE7Mnz9/9ZgxY7K6xiS8QARg78hkMjF79uyYOHFirFnjMB9kiyT8At+8efP8oQEAkHACYACAnRg3btyab37zm5mISGVrjU4AA7Azc+bMiSeeeCKWLVumGZBlEvALfJlx48atNikAgGQTAAMA7MTrr79e29DQsKmwsLBDttZYXFwcZWVlsWXLFgMDIBYsWBDjx4+PJUuWaAZkobKysiguLs7qGhsaGjYuWLCgzrQAAJJNAAwA8B62bt26vF27dh2yucauXbsKgAGauYULF8b48eNj8eLFmgFZLAm3t2zbtm25SQEAJJ8AGADgPVRVVS1t167d0GyusWfPnrFw4ULDAmiGli1bFo899ljMnz9fMyABevbsmfU1VlZWLjUpAIDkEwADALyHdevWLevTp09W15iEF4kA7ForVqyIRx99VPALCZOEfdvatWuXmRQAQPIJgAEA3sPChQuXHX744VldY69evQwKoJlYtWpVjB8/PubOnRuZTEZDIGGSsG9buHDhMpMCAEg+ATAAwHuYNm3a0ksuuSSra+zevXvk5+dHU1OTgQHkqHXr1sX48eNj9uzZgl9IqIKCgkR8A/jpp59eZloAADmw/9QCAICde+ihhzbcd999W/Pz80uzdjNXUBBdunSJNWvWGBhAjqmoqIiJEyfGyy+/HOl0WkMgwbp27RoFBdn9Gq6xsbH6kUce2WBaAADJJwAGAHgf27ZtW15WVnZwNtfYq1cvATBADqmqqoqJEyfG888/74YHyBFJ+P7vtm3blpsUAEBuEAADALyPLVu2LMv2ALhnz57x0ksvGRZAwm3evDkef/zxeOGFF6KxsVFDIIck4fu/W7ZsWWpSAAC5QQAMAPA+1q9fvyzbT2z06NHDoAASbMuWLTFlypSYOXNm1NfXawjkoCTs19avX7/MpAAAcoMAGADgfSxYsGDh0KFDs7rGfffdN1KpVGQyGQMDSJCampqYMmVKPPPMM4JfyGGpVCr23XffrK9z/vz5C00LACA3CIABAN7Ho48++uYFF1yQ1TWWlJRE586dY926dQYGkAC1tbUxefLkePbZZ6Ourk5DIMd17do1WrVqlfV1/vnPf15kWgAAuUEADADwPiZNmlRVX1+/oaioqGM217nvvvsKgAGy3Pbt22P69OkxderU2LZtm4ZAM9GnT5+sr7G+vr7iySefrDItAIDcIAAGAPgAW7duXZTtAXCfPn3ipZdeMiyALNTQ0BDTpk2Lp556KqqrqzUEmpkkXP+8detWp38BAHKIABgA4ANUVFQs7NChw8hsrjEJLxYBmpvGxsaYMWNGPPnkk1FZWakh0EwlYZ9WUVHh+78AADlEAAwA8AGWLl266MADD8zqGnv16hUFBQXR2NhoYAB7WTqdjlmzZsWkSZNi06ZNGgLNWGFhYfTs2TMR+13TAgDIHQJgAIAPMHPmzEWnnnpqdm/qCgqiZ8+esWzZMgMD2EveDn4nT54cGzdu1BAg9tlnn8jPz0/CfnexaQEA5I48LQAAeH+//OUvV6bT6bpsr7NPnz6GBbAXZDKZePHFF+O73/1u3H///cJf4J+ScP1zOp2u++Uvf7nStAAAcocTwAAAH6C6ujpdXV29uE2bNodkc539+vWL6dOnGxjAHpLJZGL27NkxceLEWLNmjYYAO92fJWCvu7i6ujptWgAAuUMADADwIWzYsGFetgfA/fv3NyiAPeTVV1+NSZMmxapVqzQD2KlUKpWI/dmGDRvmmhYAQG4RAAMAfAiLFy9+o2/fvlldY1lZWXTu3DnWr19vYAC7yYIFC2L8+PGxZMkSzQDeV5cuXaK0tDQJ+9z5pgUAkFsEwAAAH8JTTz31+ujRo7O+zv33318ADLAbLFy4MMaPHx+LFy/WDOBD78uSYMqUKa+bFgBAbsnTAgCAD/aLX/xiTWNjY1W215mUF40ASbFs2bK4++674z/+4z+Ev8BHkoTv/zY0NFTee++9q00LACC3OAEMAPAhNDQ0ZDZv3jy/Q4cOI7O5TgEwwK6xYsWKePTRR2P+fDejArm7L9uyZYs/5AAAcpAAGADgQ1q3bl3WB8AdO3aMNm3axObNmw0M4GNYtWpVjB8/PubOnRuZTEZDgI+lbdu20aFDh0Tsb00LACD3CIABAD6kefPmzTvooIOyvs4DDzwwXnrpJQMD+AjWrVsX48ePj9mzZwt+gV2yH0uCuXPnzjMtAIDcIwAGAPiQ/vznP88/77zzsr7OAw44QAAM8CFVVFTEuHHjBL/ALt+PJcHDDz/sBDAAQA4SAAMAfEgTJ06srK2tXdGqVat9srnOgw8+2LAAPkBVVVVMnDgxnn/++WhqatIQYJdKwq0xNTU1yydNmlRlWgAAuUcADADwEWzYsOHvvXr1yuoAuG3bttG1a9dYu3atgQG8y+bNm+Pxxx+PF154IRobGzUE2OW6desWbdu2TcS+1rQAAHKTABgA4CNYuHDha7169Toj2+scMGCAABjgHbZs2RJTpkyJ5557LrZv364hwG6TlO//Lly48O+mBQCQmwTAAAAfwcSJE/9+wgknZH2dBx54YEyfPt3AgGavpqYmpkyZEs8880zU19drCLDbDRgwIBF1jh8//u+mBQCQmwTAAAAfwb333rv6Bz/4wfqioqLO2VznAQccEHl5eZFOpw0NaJZqa2tj8uTJ8eyzz0ZdXZ2GAHtEXl5e9O/fP+vrrK+vX3ffffeVmxgAQG4SAAMAfESVlZVzu3btmtXHgFu1ahX77LNPLFu2zMCAZqWuri6efvrpmDZtWmzbtk1DgD1qn332iVatWmV9nZs2bZpjWgAAuUsADADwES1dunR2tgfAERGDBg0SAAPNRkNDQ0ybNi2eeuqpqK6u1hBgr+2/kuCtt976m2kBAOQuATAAwEc0ffr0v48cOTLr6xw4cGBMmDDBwICc1tDQEM8991w8+eSTUVlZqSHAXt9/JcG0adP+bloAALlLAAwA8BH9x3/8x9JbbrmlOj8/v3U219mrV68oKyuLLVu2GBqQc9LpdMyaNSsmTZoUmzZt0hBgrysrK4tevXplfZ2NjY1b7rnnnmUmBgCQuwTAAAAfUW1tbXrDhg1/7dKly3HZXGcqlYqBAwfGrFmzDA3IGW8Hv5MnT46NGzdqCJA1Bg4cGKlUKuvr3Lhx4yu1tbVpEwMAyF0CYACAj+Gtt956JdsD4IgQAAM5I51Ox8svvxxTpkyJ8vJyDQGyct+VBIsWLXrFtAAAcpsAGADgYxg/fvwrRxxxRNbXedBBB0VBQUE0NjYaGpBImUwmZs+eHRMnTow1a9ZoCJCVCgoK4qCDDkpErY888ogAGAAgx+VpAQDAR/fjH/94ZX19/fpsr7OoqCj69etnYEAivfrqq3HHHXfEz3/+c+EvkNX69esXRUVFWV9nXV1d+b333rvaxAAAcpsTwAAAH9OGDRte6dGjx6ezvc5BgwbFggULDAxIjCVLlsSECRNi/vz5mgEkwuDBgxNR5/r1653+BQBoBgTAAAAf07x5815OQgA8bNiwePjhhyOTyRgakNXefPPNmDBhQixevFgzgMRIpVIxdOjQRNQ6d+7cl0wMACD3CYABAD6m++677+XRo0dnIiKVzXW2bds2evfuHcuWLTM0ICstW7YsHnvsMSd+gUTq06dPtG3bNgmlpu+9996/mhgAQO4TAAMAfEwTJ06s3Lp165LS0tK+2V7rkCFDBMBA1lmxYkU8+uijgl8g0YYMGZKIOqurqxc+/fTTm00MACD3CYABAD6B8vLyl/fff/+sD4AHDx4c48aNMzAgK6xcuTImTJgQc+fOdT09kHhJ+f7vmjVrfP8XAKCZEAADAHwCM2fOfG7//ff/fLbX2a1bt+jWrVuUl5cbGrDXrFu3LsaPHx+zZ88W/AI5oWfPntGlS5dE1DpjxoznTAwAoHkQAAMAfAK33Xbba5dcckl1fn5+62yvdciQIQJgYK9Yv359PPbYY4JfIOck5frnxsbGzbfddts8EwMAaB4EwAAAn0BlZWXThg0b/tqlS5fjsr3WQw89NCZNmmRowJ78MzKeeOKJeP7556OpqUlDgJxz6KGHJqLOioqKV6qrq9MmBgDQPAiAAQA+oXnz5s1MQgDcu3dv10ADe0RVVVVMnDgxXnjhhWhsbNQQICd17949evbsmZT9quufAQCakTwtAAD4ZP77v/97VkQk4kTFpz71KQMDdpstW7bEQw89FLfffns899xzwl8gpw0fPjwRdWYymfTdd9/9gokBADQfTgADAHxCkyZNqtqyZcuCsrKyg7K91uHDh8fjjz9uaMAuVVNTE1OmTIlnnnkm6uvrNQTIealUKg477LBE1Lply5bXp0+fvsXUAACaDwEwAMAusHz58lkDBw7M+gC4S5cu0atXr1i5cqWhAZ9YbW1tTJ48OZ599tmoq6vTEKDZ6N27d3Ts2DEx+1QTAwBoXgTAAAC7wLPPPvvCwIEDr0hCrcOGDRMAA59IXV1dPP300zFt2rTYtm2bhgDNzrBhwxJT61/+8pcXTQwAoHnxDWAAgF3g1ltvnV9fX782CbUefvjhkUqlDA34yBoaGmLq1Klx6623xuOPPy78BZqlJF3/XFdXt/rWW29dYGoAAM2LE8AAALtAQ0NDZs2aNc/16dPns9lea7t27aJPnz6xZMkSgwM+7J9xMW3atHjqqaeiurpaQ4Bmbb/99ou2bdsmotbVq1fPNDEAgOZHAAwAsIs8++yz05IQAEdEHHHEEQJg4AOl0+mYNWtWTJo0KTZt2qQhABFx5JFHJqbW6dOnTzMxAIDmxxXQAAC7yC233PJaQ0NDZRJqHT58eLRo0cLQgJ1Kp9Px3HPPxW233Rb333+/8Bdgh6KiovjUpz6ViFobGho23HLLLXNNDQCg+XECGABgF6murk6Xl5c/t88++5yR7bW2bNkyDj300Hj55ZcNDvindDodL7/8ckyZMiXKy8s1BOBdhgwZEkVFRYmodc2aNc/V1tamTQ0AoPkRAAMA7EIvvvjiM0kIgCMiRo4cKQAGIiIik8nE7NmzY+LEibFmzRoNAXif/VNSzJo161kTAwBongTAAAC70O233/7KOeecszU/P78022sdMGBAtG/f3tWu0My9+uqrMWnSpFi1apVmALyPjh07xgEHHJCIWhsbG6u/8Y1v/NXUAACaJwEwAMAutHLlyob169fP6tat2+hsrzWVSsXhhx8ekyZNMjhohubMmROTJ0+OJUuWaAbAh3D44YdHKpVKRK3r16+fVVFR0WhqAADNU54WAADsWq+++mpirts77LDDDAyamTfffDP+/d//PX7yk58IfwE+pFQqFSNGjEhMva+88sozpgYA0Hw5AQwAsIvddNNNz5166qnV+fn5rbO91m7dukX//v1j4cKFBgc5btmyZfHYY4/F/PnzNQPgIzrggAOic+fOiai1sbFxy4033jjL1AAAmi8BMADALrZy5cqG8vLyGT179vx0Euo9+uijBcCQw5YvXx7jxo0T/AJ8wv1SUpSXlz9TXl7eYGoAAM2XABgAYDeYMWPGUxdccEEiAuAhQ4ZE69ato7q62uAgh6xcuTImTJgQc+fOjUwmoyEAH1ObNm3i0EMPTUy9zz777FOmBgDQvPkGMADAbvDVr371lYaGhk1JqLWgoCCOOOIIQ4McsW7duvj5z38ed955Z8yZM0f4C/AJjRw5MvLz8xNRa0NDw8abbrrpVVMDAGjenAAGANgNKisrm1atWjW9T58+5ySh3qOPPjqefPJJQREk2Pr16+Oxxx6L2bNn+3cZYBdJpVIxatSoxNS7cuXKadXV1WmTAwBo3pwABgDYTaZNm5aY6/c6duwYAwYMMDRIoA0bNsSvf/3r+Nd//dd49dVXhb8Au9CAAQOiY8eOian36aefftLUAAAQAAMA7CZf+9rX5tTX11ckpd6jjjrK0CBBqqqq4v77749vf/vb8eKLL0ZTU5OmAOxiRx55ZGJqra+vX/eNb3zjdVMDAMAV0AAAu0ltbW16xYoVT++///6fT0K9hx56aLRt2zaqqqoMD7LYli1bYsqUKfHcc8/F9u3bNQRgN2nbtm0MGTIkMfUuX778qdraWtc/AwDgBDAAwO70xz/+cUJSas3Pz4/jjjvO0CBL1dTUxKOPPhq33XZb/OUvfxH+Auxmxx57bOTn5yel3Myvf/3rCaYGAECEABgAYLe66667llZXV89PSr1HH310tGjRwuAgi7wd/H7jG9+IqVOnRn19vaYA7GYtWrSIo48+OjH1btmy5Y177rlnhckBABDhCmgAgN3u9ddfn3T44YcPSEKtxcXFcdhhh8XMmTMNDvayurq6ePrpp2PatGmxbds2DQHYgw477LAoKSlJTL3z5s17wtQAAHibE8AAALvZ9773vanpdLohKfWecMIJkUqlDA72koaGhpg6dWrceuut8fjjjwt/AfawVCoVJ5xwQmLqTafT27/73e8+ZXIAALzNCWAAgN1s+vTpWyoqKmZ26dIlER/Y7d69e/Tv3z/efPNNw4M9qKGhIaZNmxZPPfVUVFdXawjAXnLAAQdE9+7dE1NvRUXFczNmzPAXBwAA/+QEMADAHjBr1qxEXcuXpFMvkHTpdDqee+65uP322+PRRx8V/gLsZccff3yi6p0xY8YkUwMA4J2cAAYA2AO++tWvvnT66adXFRYWtk1CvQMHDoyOHTvGhg0bDA92k3Q6HbNmzYrJkyfHxo0bNQQgC3Ts2DEGDhyYmHobGhoqb7755pdMDgCAd3ICGABgDygvL29YsWLF1MRsEvPy4sQTTzQ42A3S6XS8+OKL8Z3vfCfuv/9+4S9AFjnppJMiLy85r8tWrFgxpaKiotHkAAB4JwEwAMAe8qtf/erRiMgkpd6jjjoqysrKDA52kUwmE6+++mp873vfi1//+texdu1aTQHIImVlZXHUUUcl6q+W//7v//6zyQEA8G4CYACAPeQ///M/l1dWVv4tKfUWFhbGMcccY3CwC7wd/P785z+PNWvWaAhAFjruuOOioCA5X0urqqqa/dOf/nS1yQEA8G4CYACAPeill14al6R6jzvuuCgqKjI4+JjmzJkTd911V/z85z+P1au9owfIVkVFRYn7xbcXXnhhnMkBALAzBVoAALDnjB079pkFCxZUFhYWtktCvSUlJXHEEUfE9OnTDQ8+gjfffDPGjx8fb731lmYAJMCRRx4ZJSUliam3oaFh0zXXXPOsyQEAsDMCYACAPai8vLxh6dKlE/v3739xUmo+8cQT49lnn410Om2A8AEWLVoUjz32WCxevFgzABIiLy8vTjzxxETVvGTJkifKy8sbTA8AgJ3ucbUAAGDP+u1vfzsxIjJJqbdjx44xdOhQg4P3sXz58rj77rvjRz/6kfAXIGGGDRsWHTp0SFLJmd/85jePmxwAAO9FAAwAsIf953/+5/JNmza9kqSaTz/99EilUoYH77Jy5cr4yU9+Et///vdj/vz5GgKQMHl5eXHGGWckquZNmza9fM8996wwPQAA3osroAEA9oKXXnpp/KmnnnpYUurt2rVrDBkyJGbPnm14EBHr1q2L8ePHx+zZsyOTyWgIQEINHTo0OnfunKiaX3jhhQkmBwDA+xEAAwDsBZdffvkzS5YsWVdUVNQlKTWfccYZ8be//U3YRbO2fv36eOyxxwS/ADkglUrF6aefnqia6+rq1lx22WXTTQ8AgPcjAAYA2AsqKyub5s+f/8ihhx56dVJq7tatm1PANFsbNmyIxx9/PF555ZVoamrSEIAc8KlPfSq6du2aqJrfeOONcdXV1WnTAwDg/fgGMADAXvL1r399XDqdrktSzb4FTHNTVVUV999/f3z729+OF198UfgLkCNSqVR8+tOfTlTN6XS69pvf/OZjpgcAwAdxAhgAYC+ZMWNG9Zo1a/7Ss2fPxLx97N69ewwcODDmzJljgOS0LVu2xIQJE+KFF16IxsZGDQHIMYceemh069YtUTWvXr36qRkzZlSbHgAAH8QJYACAvejXv/71HyMiUR8SPeuss5wCJmdt27YtHn300bjtttviueeeE/4C5KC8vLwYM2ZM0srO/OpXv/qT6QEA8KH2vFoAALD3fP/733+rqqoqUR/V7dGjR3zqU58yPHJKfX19TJ06Nb71rW/F1KlTo76+XlMActSIESOiS5cuiap506ZNf73rrruWmh4AAB+GABgAYC975plnHkpazWeccUbk5dlKkjvmzZsXjz76aGzdulUzAHJYQUFBnH766Ymre9q0aQ+aHgAAH5a3dgAAe9nYsWNn1tfXr01SzZ07d47DDjvM8ACARBk5cmR06NAhUTXX1dWtHjt27POmBwDAhyUABgDYyyorK5tee+21Pyat7jPPPDMKCgoMEABIhBYtWiTy9O/s2bP/UF1dnTZBAAA+LAEwAEAWuOqqqyY0NjZWJanm9u3bx9FHH214AEAiHHfccdGmTZtE1dzQ0LDxiiuumGh6AAB8FAJgAIAssGDBgrqFCxc+lrS6R48eHYWFhQYIAGS1li1bxsknn5y4uhcuXDhu6dKl200QAICPQgAMAJAlvv71r/8pnU7XJqnmtm3bximnnGJ4AEBWO+2006K0tDRRNTc1NdV+7Wtfe8j0AAD4qATAAABZ4umnn968fPnyxF3xN3r06GjXrp0BAgBZqUOHDnH88ccnru5ly5ZNmD59+hYTBADgoxIAAwBkkbvvvvtPmUymKUk1FxYWxumnn254AEBWOvPMMxP3yYpMJtN41113/dH0AAD4OATAAABZ5Be/+MWatWvXTkta3UcccUT06tXLAAGArNK7d+847LDDEld3eXn5X+6///51JggAwMchAAYAyDIPP/zwn5JWcyqVijPPPNPwAICsMmbMmEilUomr+8EHH/yT6QEA8HEJgAEAsszXv/71NzZs2DAraXUPHDgwDj74YAMEALLCoEGDYsCAAYmru6KiYuatt966wAQBAPi4BMAAAFlo3Lhxv01i3WPGjIm8PFtMAGDvysvLizFjxiSy9j//+c+/NUEAAD7RflgLAACyz/XXXz+nqqrqr0mru1evXnHUUUcZIACwVx1zzDHRvXv3xNW9adOmV2666aa5JggAwCchAAYAyFJ/+tOf7k1i3WPGjInS0lIDBAD2ijZt2sRZZ52VyNofeOCBe00QAIBPSgAMAJClbrrpprlJPAVcXFwcZ555pgECAHvFWWedFS1btkxc3Zs2bXrl5ptvnmeCAAB8UgJgAIAsNm7cuF8lse5Ro0ZF7969DRAA2KP69OkTI0eOTGTtjz322K9MEACAXUEADACQxcaOHTu7qqrqb0mrO5VKxfnnnx+pVMoQAYA9tv/4/Oc/n8j9R2Vl5d+uueaav5kiAAC7ggAYACDLTZ069bdJrLtv374xZMgQAwQA9ojDDjsssTeQTJ48+TcmCADAriIABgDIcpdeeumLVVVVryax9s9//vNRXFxsiADAblVaWhrnn39+Imuvqqr66+WXX/6SKQIAsKsIgAEAEuChhx76WRLrLisri9NPP90AAYDd6qyzzoqSkpIklp753e9+91MTBABgVxIAAwAkwA033DB3w4YNs5JY+3HHHRd9+vQxRABgt+jbt28cddRRiay9oqJi1te//vU3TBEAgF1JAAwAkBA///nPfxoR6aTVnUql4vOf/3zk5dl6AgC7Vn5+flx00UWRSqWSWH76F7/4xX+bIgAAu5q3cAAACXHHHXe8tW7duulJrL13795xzDHHGCIAsEudcMIJ0b1790TWXl5e/pc77rjjLVMEAGBXEwADACTI3XfffW8mk2lKYu1nnXVWtG3b1hABgF2iQ4cOcfrppyey9kwm03T33Xf/3BQBANgdBMAAAAlyzz33rCgvL386ibW3bNkyzj33XEMEAHaJc889N1q0aJHI2tesWTP1xz/+8UpTBABgdxAAAwAkzA9/+MOfZzKZhiTWPnz48Bg0aJAhAgCfyKGHHhpDhw5NZO3pdLrhBz/4wS9MEQCA3UUADACQMPfee+/qRYsWPZDU+i+++OIoKSkxSADgY2ndunVcfPHFia1/4cKFf7jvvvvKTRIAgN1FAAwAkECXXXbZrxsaGjYlsfaysjJXQQMAH9u5554bpaWliay9oaFh4+WXX/47UwQAYHcSAAMAJNDs2bNrXn311V8ntf4jjjgiDj74YIMEAD6SwYMHx+GHH57Y+l955ZX7Zs+eXWOSAADsTgJgAICEOueccx6tqalZmtT6L7roomjZsqVBAgAfSsuWLeNzn/tcYuuvqalZMmbMmMdMEgCA3U0ADACQUJWVlU3Tpk37RVLrb9++fZx++ukGCQB8KGeccUa0b98+sfU/+eST91ZXV6dNEgCA3U0ADACQYOedd960qqqqV5Ja/wknnOAqaADgAx188MFx/PHHJ7b+TZs2vXzBBRc8a5IAAOwJAmAAgIT74x//eG9EZJJYeyqVigsuuMBV0ADAe2rZsmVccMEFkUqlkrqEzP333/8zkwQAYE8RAAMAJNzNN988b9WqVU8ktf6OHTsm+nt+AMDudcEFF0THjh0TW/+KFSse//rXv/6GSQIAsKcIgAEAcsCNN974k6ampq1JrX/kyJExdOhQgwQA/pdPfepTMWLEiMTW39TUVH3zzTf/t0kCALAnCYABAHLAxIkTK//+97//KslruPDCC6OsrMwwAYCIiGjTpk18/vOfT/QaZs+efd/EiRMrTRMAgD1JAAwAkCPOPvvsh2pqapYntf7S0tK46KKLDBIAiFQqFV/84hejtLQ0sWuoqal566yzznrYNAEA2NMEwAAAOaKioqJx0qRJP07yGgYPHhwjR440TABo5o444og46KCDEr2GJ5544qeVlZVNpgkAwJ4mAAYAyCGXXHLJzIqKihlJXsMFF1wQ3bp1M0wAaKZ69uyZ+KufKyoqZnzhC1+YZZoAAOwNAmAAgBzzb//2b/ek0+ntSa2/RYsWceWVV0ZhYaFhAkAzU1hYGF/60pcSvQ9Ip9Pb/+3f/u0e0wQAYG8RAAMA5Jh777139aJFix5M8hq6d+8eZ555pmECQDNzxhlnRPfu3RO9hsWLFz947733rjZNAAD2FgEwAEAO+uxnP/vL2traRL94PPHEE2Pw4MGGCQDNxKBBg+Kkk05K9Bpqa2tXn3vuub80TQAA9iYBMABADlq8eHH9uHHj/j3Ja0ilUnHJJZdE27ZtDRQAclybNm3ikksuiVQqleh1jBs37t8XL15cb6IAAOxNAmAAgBx1+eWXv1RRUTEjyWsoLS2NL3zhC4l/GQwAvLe3f+mrdevWiV5HRUXFM5dffvlLJgoAwN4mAAYAyGE33HDDXU1NTVuTvIaDDjrI94ABIId95jOfiUMOOSTRa2hqaqq+4YYbfmiaAABkAwEwAEAOGzdu3MbZs2cn/jt0p5xyiu8BA0AOOuSQQ+LTn/504tfx17/+9efjxo3baKIAAGQDATAAQI77zGc+81B1dfXCJK8hlUrFF7/4xejQoYOBAkCO6NixY3zpS19K/KceNm/ePO+00057xEQBAMgWAmAAgBxXXV2dfuCBB34UEekkr6O4uDguvfTSyMuzhQWApMvPz4/LLrssiouLk76U9P333/+ftbW1aVMFACBbeHsGANAMXH/99XMWLVr0YNLXsf/++8e5555roACQcOedd1707ds38etYuHDhH7/61a++bqIAAGQTATAAQDNxySWX/Lyurq486es4/vjjfQ8YABJs2LBhccwxxyR+HXV1dWsuvPDC+0wUAIBsIwAGAGgmXnvttdoHHnjguxGRSfI6UqlUfOlLX4oePXoYKgAkTO/evePSSy9N/Hd/IyLzwAMPfO/111+vNVUAALKNABgAoBm5+uqr/7Z06dJHk76OoqKiGDt2bJSWlhoqACRE69at46qrrorCwsLEr2X58uXjrr766r+ZKgAA2UgADADQzJx33nn/r66ubnXS19GhQ4e4/PLLIy/PlhYAsl1eXl5cfvnl0b59+8Svpb6+ft0ll1zyE1MFACBr999aAADQvLz++uu1Dz744Pcj4VdBR0QMGDAgzjrrLEMFgCw3ZsyYOPDAA3NiLY899tgPXnnllW2mCgBAthIAAwA0Q1/5ylf+umbNmqm5sJaTTz45Dj30UEMFgCw1ZMiQOOmkk3JiLWvXrv3LpZde+oKpAgCQzQTAAADN1GWXXfYf9fX1FUlfRyqViksvvTS6d+9uqACQZXr06BFf/OIXI5VKJX4tDQ0Nm6655pofmioAANlOAAwA0EzNmDGj+oEHHvhO5MBV0C1btozrr78+2rZta7AAkCXatWsX1113XbRs2TIXlpN56KGH/nXSpElVJgsAQLYTAAMANGNf+cpX/rpkyZI/58Ja2rZtG1dffXW0aNHCYAFgL2vRokVcffXVOfPLWUuXLn30iiuueNlkAQBIAgEwAEAzd+655/6ktrZ2eS6spXfv3jlzzSQAJNXbn2fYZ599cmI9tbW1y88555wfmywAAEkhAAYAaOYWLFhQ97Of/ezbmUymMRfWM2zYsDjllFMMFgD2kk9/+tMxdOjQnFhLJpNp/NnPfvbtBQsW1JksAABJIQAGACBuvfXWBfPnz78/V9Zz5plnxuDBgw0WAPaw4cOHx2c+85mcWc/8+fN/d+utty4wWQAAkkQADABARESMGTPmvpqamrdyYS2pVCouu+yy6Nmzp8ECwB7Su3fvuPjii3PmUwxbt25ddPrpp//aZAEASBoBMAAAERGxcuXKhh/+8Ie3pdPpnLjisGXLlvEv//Iv0aVLF8MFgN2sS5cucf3110dRUVFOrKepqanmu9/97jfKy8sbTBcAgKQRAAMA8E933XXX0ueff/6eXFlPaWlpXHvttVFWVma4ALCblJWVxXXXXRclJSU5s6aZM2fe/f/+3/9bZboAACSRABgAgP/l5JNPHldeXv50rqynU6dOMXbs2Jw5kQQA2aSoqCiuueaa6NixY86sqby8/MlTTz11gukCAJBUAmAAAP6PSy655K66urq1ubKefffdN6644orIy7P9BYBdJS8vL6688sro3bt3zqyprq6u/JJLLvmh6QIAkOi9uhYAAPBus2bNqn7ooYfujIh0rqxp4MCBcd555xkuAOwi559/fhxyyCG5tKT0gw8+eOesWbOqTRcAgCTLb3tQ9NzpjndbRG15oQ4BADRTEydOXDNmzJi8Tp06Dc2VNfXp0yfy8/PjzTffNGAA+ATOOuusOOmkk3JqTa+//vp9Z5555kTTBQAgCYq7N0Ze6c5/5gQwAADv6dRTT/31li1bXs+lNZ122mlx9NFHGy4AfEzHHntsnHrqqTm1pi1btrxx2mmn/cZ0AQDIBQJgAADeU0VFReONN974jcbGxqpcWtcFF1wQRx55pAEDwEd05JFHxuc+97mcWlNjY2PVzTff/I2KiopGEwYAIBcIgAEAeF9//OMf1z/yyCPfiRz6HnAqlYqLLroohgwZYsAA8CENHTo0LrrookilUrm0rPQjjzzynfvvv3+dCQMAkCsEwAAAfKBLL730hQULFvwupzbCeXnxpS99Kfbff38DBoAPcNBBB8WXvvSlyMvLrVdJCxYs+N2ll176ggkDAJBLBMAAAHwoo0eP/mVVVdXcXFpTYWFhfOUrX4kePXoYMAC8h169esUVV1wRBQUFObWuqqqqOaNHj/6lCQMAkGsEwAAAfCgVFRWNV1111S0NDQ0bcmldJSUlcfPNN8c+++xjyADwLr17946bbropiouLc2pdDQ0NG6666qqv++4vAAC5SAAMAMCHNmHChE3333//tzKZTDqX1lVcXBzXXXdddO/e3ZABYIfu3bvHtddeG61atcqpdWUymfT999//rQkTJmwyZQAAcpEAGACAj2Ts2LGz58+f/9tcW1fr1q3juuuuiw4dOhgyAM1ehw4d4rrrrovWrVvn3Nrmz5//m7Fjx842ZQAAcpUAGACAj+y44477xaZNm17MtXW1a9cubrzxxmjXrp0hA9BstW3bNmf/Pty4ceOLxx13nO/+AgCQ0wTAAAB8ZNXV1emLL774W3V1datzbW0dO3aMG2+8Mdq0aWPQADQ7ZWVlceONN0bHjh1zbm21tbWrL7zwwturq6vTJg0AQC7Lb3tQ9NzZD9LbImrLC3UIAICdWrZsWf327dtfOvbYY0/Ny8trkUtrKykpiaFDh8Zrr70WNTU1hg1As9ChQ4f42te+Fp06dcq5tTU1NW39zne+M/bBBx9cb9IAAOSC4u6NkVe6858JgAEA+NhefPHFzYcccsiyAQMGnBgRqZzaRBcXx5AhQ4TAADQLHTt2jJtuuik6dOiQi8tLjx8//ravfvWrc0waAIBc8X4BsCugAQD4RC688MIZb7zxxm9ycW3t27ePm266KSdPQgHA2zp16pTL4W+88cYbv77wwgufM2kAAJoLATAAAJ/YqFGjfrFhw4aZubi2t0Pgzp07GzQAOadz585x0003Rfv27XNyfRs2bJg5atSo+0waAIDmRAAMAMAnVltbm77sssu+V1dXtzoX19euXbu44YYbomPHjoYNQM7o0KFDXH/99dGuXbtc3Z+s/sIXvvDd2tratGkDANCc+AYwAAC7xJIlS+oj4pVRo0admpeX1yLX1ldcXBxDhw6NuXPnxrZt2wwcgETr0qVL3HjjjTl77XNTU1P1nXfeec0f/vCHdaYNAEAuer9vAAuAAQDYZWbNmlXVo0ePuYceeujoVCqVn2vra9WqVYwYMSIWLVoUlZWVBg5AIu23335x0003RVlZWU6uL51ON/z617++4fbbb3/TtAEAyFUCYAAA9phJkyatPeqoozbsu+++R+fi+goLC2P48OGxbNmy2LBhg4EDkCgDBgyIa6+9Nlq1apWza5w2bdq/XXLJJc+ZNgAAuez9AmDfAAYAYJc77bTTHn/rrbcezNX1FRUVxTXXXBNDhgwxbAASY8iQIXHNNddEUVFRzq5xwYIFvzv99NOfMG0AAJozATAAALvFEUcccc+GDRtm5ur6CgoK4sorr4wjjjjCsAFIwt/LceWVV0ZBQUHOrrG8vPypESNG/LdpAwDQ3AmAAQDYLaqrq9MXXXTRd2pra1fk7GY6Ly8uvvjiOPLIIw0cgKw1atSouPjiiyMvL3dfA23dunXxZz/72e83NDRkTBwAgObON4ABANhtli9fvr2mpuaFY4899uT8/PyWubjGVCoVgwYNikwmE4sWLTJ0ALLK6aefHueee26kUqmcXWN9fX3FDTfccM3UqVOrTBwAgObi/b4BLAAGAGC3evnll7cUFBS8cMQRR4zOy8trkYtrTKVSccABB0SnTp1i7ty5kck4fATA3lVYWBhXXHFFHHPMMTm9zsbGxuo777zzKz/72c9WmzoAAM2JABgAgL1qxowZlb169Xp98ODBJ6dSqfxcXWfPnj2jb9++8fe//z0aGxsNHoC9olWrVnH11VfHwIEDc3qd6XS64be//e2Nt9122wJTBwCguREAAwCw1z3xxBPlw4cPX9OvX79jIyJn76Hs2LFjDBw4MObMmRN1dXUGD8Ae1a5du7jxxhujT58+ub7U9JQpU779xS9+8XlTBwCgOXq/ADhPewAA2FPGjBkz9Y033vh1rq+zZ8+eceONN0bHjh0NHYA9pkuXLnHTTTdF9+7dc36tc+fO/eU555zzF1MHAID/SwAMAMAe9alPfernS5cufTjX19mlS5e49dZb48ADDzR0AHa7gQMHxje/+c3o1KlTzq/1rbfeemjEiBG/MnUAANg5ATAAAHvcsccee8/GjRtfyPV1FhcXx7XXXhsjRowwdAB2m8MPPzyuuuqqaNmyZc6vdePGjc8fffTR95g6AAC8NwEwAAB7XEVFReNxxx339crKyr/l+loLCgrisssui/PPPz9SqZThA7DLpFKpOP/88+PSSy+NgoKCnF/vpk2bXj7ssMNuqaysbDJ9AAB4bwJgAAD2isWLF9efddZZN1dXV7/ZHNZ7/PHHx5e//OUoKioyfAA+sRYtWsSXv/zlOP7445vFequrq98cM2bMN8rLyxtMHwAA3l9+24Oi585+kN4WUVteqEMAAOw2a9asaVi1atWs0aNHH1dQUNA619fbrVu3OOCAA2LevHlRX1/vAQDgYykrK4trrrkmDjrooGax3rq6uvKxY8de89RTT202fQAA+Ifi7o2RV7rznwmAAQDYq+bNm1ezevXqZ04++eTjCwoKSnN9ve3atYuRI0fG8uXLY+PGjR4AAD6S/v37x0033RRdu3ZtFuutr69fd9111335T3/6U4XpAwDA/xAAAwCQ1ebMmbMtlUq9fOSRR56Ul5eX83ckt2jRIkaMGBG1tbWxdOlSDwAAH8rxxx8fX/rSl5rN5wQaGxu33HXXXdf99Kc/XWn6AADwvwmAAQDIejNnzqzs2bPn64MHDz4plUrl5/p6U6lUHHLIIdGqVatYsGBBZDIZDwEAO5WXlxef/exn4/TTT49UKtUs1pxOp7f//ve//+o3vvGN1z0BAADwfwmAAQBIhEmTJpXvs88+8wYOHHhCKpUqaA5r3m+//WLAgAExd+5c3wUG4P8oKyuL6667LoYNG9Zs1pxOp7f/8Y9/vOmqq676qycAAAB2TgAMAEBiTJw4cc3BBx+85MADDzwulUrlNYc1t2/fPoYOHRqLFi2KLVu2eAgAiIiIffbZJ66//vro2bNns1lzJpNpnDBhwm1f/OIXn/cEAADAexMAAwCQKI8++ujy/fff/42DDjrohOZwHXRERHFxcRx11FHR2NgYb731locAoJkbPXp0XHHFFVFSUtJs1pxOpxsefvjhr15yySWzPAEAAPD+BMAAACTO+PHjVw0cOHDpAQcccGxzOQmcSqViwIAB0aVLl3jjjTeiqanJgwDQzBQVFcWll14aJ554YrP53m/EP07+Pv7447dffPHFMz0FAADwwQTAAAAk0iOPPLLs0EMPXbb//vs3mxA4IqJHjx4xZMiQePPNN2Pr1q0eBIBmonv37vEv//IvccABBzSrdWcymaYnnnji9s997nPPeAoAAODDEQADAJBYDz/88NJjjjlmY+/evY+KiGZzFKq0tDSGDx8eq1evjvXr13sQAHLcwIED45prrol27do1t6VnZsyY8YOzzjprqqcAAAA+PAEwAACJdv/99795zDHHVO6zzz5HRDMKgVu0aBGHHXZYtGzZMhYuXBjpdNrDAJBjCgoK4pxzzonzzz8/WrRo0dyWn37uuefuOuWUUyZ4EgAA4KMRAAMAkHi///3v5w8bNmxF3759j2lO10GnUqno27dvDB06NBYvXhxbtmzxMADkiJ49e8YNN9wQgwcPblbf+434x7XPU6ZM+fbpp58+2ZMAAAAfnQAYAICc8OCDDy4ZNmzYin79+jWrEDgionXr1nHEEUdEfX19LF261MMAkGCpVCpOOOGEuOKKK6JNmzbNbv07wt9vnXPOOX/xNAAAwMcjAAYAIGc89NBDS4YNG7a8X79+xza3EDg/Pz8OPvjg6NWrV8yfPz8aGho8EAAJU1JSEpdffnmccMIJkZ+f3+zWn8lkGp944olvffazn53maQAAgI9PAAwAQE556KGHlo4cOXJdnz59RqWa252ZEdG1a9cYNmxYLFu2LCorKz0QAAnRt2/fuO6662K//fZrluvPZDLpp59++rvnnHPO054GAAD4ZATAAADknD/96U+LDj300KX7779/s7sOOiKiuLg4jjzyyCgpKYk333wz0um0hwIgSxUUFMRnP/vZuPDCC6OkpKRZ9iCdTjc88sgjt5x//vnTPREAAPDJCYABAMhJDz/88NId3wQelUqlmt09mqlUKvr06RMHH3xwLFy4MLZt2+ahAMgynTt3jrFjx8bQoUOjGV5aERH/CH+feOKJ2y+88MLnPBEAALBrCIABAMhZDz300JIePXq8NmjQoGPz8vJaNMcetG3bNkaNGhVNTU2xZMkSDwVAFkilUjF69Oi48soro0OHDs22D01NTdt++9vf/stll132oqcCAAB2HQEwAAA5bdKkSeXdu3efM3jw4GYbAufn58eAAQOiV69esWDBgti+fbsHA2Avad26dVx66aVx/PHHR35+frPtQ2NjY/WvfvWrf7nuuute81QAAMCuJQAGACDnTZ48eW1jY+OMI4444uiCgoKS5tqHrl27xqhRo2Lbtm2xcuVKDwbAHpRKpWLUqFExduzY6NWrV7PuRX19/fo77rjjK9/61rcWejIAAGDXEwADANAsPP/881UbNmx45rjjjjuqsLCwrLn2obCwMAYNGhT77bdfLF68OGpraz0cALtZ+/bt44orrogTTzwxCgub9/uU2tralTfffPPVP/nJT1Z7MgAAYPcQAAMA0Gz87W9/27p27doZJ5xwwsjCwsK2zbkXnTp1ipEjR0Z1dbXTwAC70ciRI+Pqq6+OHj16NPte1NTULL/hhhuu/e1vf7vOkwEAALuPABgAgGbltdde2zpv3rynTznllKFFRUWdmnMvCgsL49BDD4399tsvFi1a5DQwwC709qnfk08+udmf+o2I2Lx587yLL774unHjxm30dAAAwO71fgFwat9zYsTOftC4LmLjq610DwCAxOrVq1fhs88++69du3Y9QTciGhoaYurUqTF58uRobGzUEICPqaCgIE499dQYPXq04HeH8vLyp4499tjvrly5skE3AABg9+swrDYKuuz8ZwJgAAByWuvWrfNeeumlm/fdd9+zdeMfVq9eHffff38sWbJEMwA+ov322y8uuugi1z2/w8KFC38/fPjwnzY0NGR0AwAA9gwBMAAAzd7zzz9/8aGHHnp1RKR0IyKTycTMmTPjz3/+c9TV1WkIwAcoKSmJ8847L0aMGBGplL9Kdki//PLL9xx77LEPagUAAOxZ7xcA+wYwAADNwn333Tfn+OOP39yrV6/DQwgcqVQqevfuHcOHD49169ZFRUWFhwTgPRxyyCExduzY6N+/v/B3h0wm0/jMM8/828knnzxONwAAYM97v28AC4ABAGg2fve7370xePDgJf369Ts6lUrl60hEcXFxjBgxInr06BFLly6N2tpaTQHYoUOHDvGFL3whzjzzzCguLtaQHZqammoeeOCBWz73uc9N1w0AANg7BMAAALDDww8/vKygoOC54cOHH1FQUFCqI//QrVu3OO6446K0tDQWL14cTU1NmgI0Wy1btoxzzjknLr300ujevbuGvENtbe2K22677arbbrvtDd0AAIC9RwAMAADv8Oyzz25avHjx0yeddNKQoqKiTjryD3l5edGnT58YOXJkbN26NVatWqUpQLNz+OGHx1e+8pUYMGBA5OXlacg7VFVV/e3CCy+8/oEHHvDdAAAA2MsEwAAA8C7z58+vefbZZ58+44wz+hcXF/fSkf/RsmXLGDJkSOyzzz6xdOnSqKmp0RQg53Xs2DG++MUvximnnBItW7bUkHdZt27dMyeffPI3Xn755W26AQAAe9/7BcCpfc+JETv7QeO6iI2vttI9AAByWmFhYer555//0sEHH3y5bvxfTU1N8fzzz8f48eOjurpaQ4Cc07p16zjzzDPjyCOPdOJ35zJ///vff3rMMcfc39DQkNEOAADIDh2G1UZBl53/TAAMAAARMWnSpM8cc8wxt6RSKdfg7ERNTU1MmTIlpk2bFg0NDRoCJF5hYWGccsopcdJJJ0VRUZGG7EQ6na6fOnXqd88555y/6AYAAGSX9wuAXQENAAAR8Yc//GHhfvvt98aAAQOOysvLkwS8S2FhYQwYMCCGDh0amzZtinXr1mkKkFiDBw+Oq666KoYOHRoFBQUashONjY1Vv//972/5whe+MEs3AAAg+/gGMAAAfAgTJkxYXV1dPf3II4/8VGFhYTsd+b9KS0vjsMMOi/79+8eaNWti8+bNmgIkRu/evePyyy+PU045JUpLSzXkPWzdunXxLbfccs33vve9hboBAADZyTeAAQDgI+jTp0+LJ5988us9evQ4TTfe3/z58+ORRx6JlStXagaQtXr16hXnnHNODBgwQDM+wKpVq5444YQTfrBy5Ur3/QMAQBbzDWAAAPgYnnnmmfOHDx9+fSqVytON95bJZGL27Nkxbty4qKio0BAga3Tu3DnOOuusGDp0aKRSKQ15/z/Lm2bNmvXDk08++THdAACA7OcbwAAA8DH85je/eX3//fd//cADDzzSd4HfWyqViu7du8cxxxwT7dq1i2XLlkV9fb3GAHtN27Zt49xzz42LL744evToIfz9AI2NjdUPPvjgLZ/97Gf/ohsAAJAMvgEMAAAf0/jx41dFxPOHHXbYiMLCwjIdeW95eXnRu3fvOOqoo6KgoCBWrlwZjY2NGgPsMcXFxXHKKafEl770pejbt2/k5bnA4YPU1tau+MEPfnD9LbfcMk83AAAgQf/94xvAAADwyQwePLjVo48++s1u3bqdpBsfTn19fTzzzDMxderU2LZtm4YAu01ZWVmceuqpceSRR0ZRkQsbPqyVK1c+/ulPf/pHixcvdm0DAAAkjG8AAwDALvLkk0+edeSRR96USqVcl/MhCYKB3eXtE7/HHnus4PcjyGQyDbNmzfoP3/sFAIDk8g1gAADYRX7/+98v6NGjx2uHHHLIyPz8fL8x+SEUFBREv3794qijjoq8vLxYtWqVq6GBT6Rly5ZxwgknxBVXXBEHHXRQFBQUaMqH1NDQsOG3v/3t1z7/+c8/oxsAAJBcroAGAIBd7Lzzzut4991339m2bdvBuvHR1NTUxLPPPhvTpk2LLVu2aAjwoZWVlcXxxx8fxxxzTBQXF2vIR1RVVfW3a6+99vZHHnlkg24AAECyuQIaAAB2g06dOhVMmzZtbN++fT8XESkd+WgaGhri+eefjyeffDI2bJBFAO/7522cdNJJccQRR0RhodvKPobMokWL/nTsscf+pLKyskk7AAAg+QTAAACwG/3hD38Ydfrpp99WUFDQRjc+unQ6Ha+++mpMnTo1Vq5cqSHAP/Xq1StOOeWUGDp0aOTl5WnIx9DY2Fg1YcKEOy666KKZugEAALlDAAwAALvZaaed1vbee+/9docOHUbqxse3fPnymDZtWrz88suRTqc1BJqhvLy8OOyww+L444+P3r17a8gnsHHjxue//OUvf3fSpElVugEAALlFAAwAAHtAYWFh6qmnnjpv+PDh16RSKXeUfgIbNmyIGTNmxHPPPRc1NTUaAs1AcXFxjBo1Ko4++ujo2LGjhnwCmUym4ZVXXvl/J5100kMNDQ0ZHQEAgNzzfgFwftuDoufOfpDeFlFb7p0VAAB8WOl0On7zm9+8Xlpa+uLgwYM/VVhYWKYrH09xcXEMGDAgjj322GjTpk2sXbs2amtrNQZyUIcOHeKMM86ISy+9NAYOHBjFxcWa8gnU1tau+slPfnLjxRdf/IybFAAAIHcVd2+MvNKd/8wJYAAA2A1OPPHENvfdd9+tnTp1Olo3PrnGxsb429/+Fs8++2wsWrRIQyAH9OvXL44++ugYNmxYFBQUaMguUFFR8cwXv/jFf5s+ffoW3QAAgNzmCmgAANhLHn744RNGjx799YKCgta6sWusX78+Zs6cGc8//3xUV1drCCRIaWlpHHnkkXHUUUdF586dNWQXaWxs3DJ16tS7PvvZz/5FNwAAoHkQAAMAwF50ySWXdP3+97//rXbt2g3VjV2nsbExXnvttXjuuedi/vz5GgJZbMCAATFq1KgYPHiw0767WFVV1atf//rXv/e73/1urW4AAEDzIQAGAIC9rF27dvlTp0699OCDD740lUrl68iutXz58nj++efj5ZdfjpqaGg2BLFBSUhLDhw+PI444Inr37q0hu1gmk2mcN2/efSeeeOJvq6urfewXAACaGQEwAABkia9//ev73Xjjjf9aWlraXzd2vXQ6HW+++WY899xz8dprr0VjY6OmwB5UUFAQgwcPjlGjRsUBBxwQeXl5mrIbVFdXL/zP//zPf/3BD36wRDcAAKB5EgADAEAWOfjgg1v9+c9/vrZ3795jIiKlI7tHZWVlvPjii/HCCy/EunXrNAR2o65du8bIkSPj8MMPj7Zt22rI7pNZunTpn88888z/t3jx4nrtAACA5ksADAAAWejuu+8eePHFF9/WqlUrd6PuZuXl5fHqq6/GSy+9FOvXr9cQ2AU6d+4cI0aMiGHDhkW3bt00ZDerqalZ9tvf/vbOm266aa5uAAAAAmAAAMhS/fr1K3r44Ycv79+//4WpVMpdqXvA8uXL46WXXoqXX345qqurNQQ+grKyshg+fHiMGDHCd333kEwmk164cOEfzj777F8sXbp0u44AAAARAmAAAMh6P/3pT4d97nOf+2bLli176Mae0dDQEHPnzo2//vWvMXfu3Ni+Xa4CO9OyZcsYNGhQDBs2LA455JAoKCjQlD2ktrZ21R//+Mc7rr322r/rBgAA8E4CYAAASIA+ffq0ePTRR69wGnjPS6fTsXTp0nj11VedDIaIaNu2bQwbNiyGDRsWffr0ibw8fyTtSZlMpuG11177+ZlnnvmnioqKRh0BAADeTQAMAAAJ8uMf//jQCy644JutWrXaRzf2vLdPBs+ePTvmzp0bdXV1mkKzUFZWFoMHD45hw4ZF//79Iz8/X1P2gpqammX333//nTfccINv/QIAAO9JAAwAAAnTrl27/HHjxp37qU996qq8vDwb870kk8nEihUrYu7cuTFnzpxYsWJFZDIZjSEnpFKp6Nu3bwwbNiwGDRoUHTt21JS9qKmpqfbVV1/92ZgxY/5cWVnZpCMAAMD7EQADAEBCffnLX+5x++23f7V9+/aH68bet2XLlnjjjTdizpw5MW/evKivr9cUEqVly5Zx8MEHx6BBg+KQQw6J0tJSTckCGzdufPG73/3uv//iF79YoxsAAMCHIQAGAIAEKywsTE2cOPGMkSNHXlNQUNBaR7JDXV1dvPnmm/HGG2/EG2+8EevXr9cUslKXLl3ioIMOioMOOigOOOCAKCoq0pQs0djYuGXmzJk/PvPMMyc2NDS4XgAAAPjQBMAAAJADjjzyyNY/+9nPrujbt++5EZGnI9mluro6Fi5cGPPnz4958+ZFZWWlprBXtGvXLg455JAYMGBA9O/fP1q39nsjWSj91ltv/fmqq676xaxZs6q1AwAA+KgEwAAAkEN++ctfjhgzZsyNrVq16q0b2SmdTsfKlStj0aJFsXDhwli8eHFs27ZNY9gtSkpKol+/ftG/f//Yf//9o1evXpGX53dEslVNTc3yRx999EdXXnnlK7oBAAB8XAJgAADIMd26dSt8+OGHPzd48ODL8vPzbdyzXCaTiTVr1sTChQtj0aJFsWjRotiyZYvG8LGUlZVF//79/xn6du/ePVKplMZkuaampprXXnvtV2PGjHmgoqKiUUcAAIBPQgAMAAA56rjjjiv7r//6r8tdC508mzdvjuXLl8eKFSti+fLlsXjx4qipqdEY/pfi4uLo169f9O7dO/bZZ5/Yd999o6ysTGMSJJPJpJcsWfLn66677pfTp0/3mx8AAMAuIQAGAIAc99Of/nTIueeee3NpaWlf3UimxsbGWLlyZSxdujSWLVsWy5cvj3Xr1kUmk9GcZiKVSkWXLl1in332iT59+kSfPn2iV69eUVBQoDkJtXXr1sUPPvjgj6699tq/6wYAALArCYABAKAZaNeuXf64cePOGTp06BUFBQWtdST56uvrY+XKlf88KbxixYpYu3ZtpNNpzUm4vLy86Nq1a+yzzz7//KdXr17RsmVLzckBjY2NW/7617/+4pxzznm0srKySUcAAIBdTQAMAADNyIknntjmnnvuuXzfffcdk0qlHB3MMdu3b481a9bEmjVrYu3atbF27dooLy+PDRs2CIazUF5eXnTs2DG6desWXbt2jW7dukW3bt2iR48eUVhYqEE5JpPJNC5ZsuRR1z0DAAC7mwAYAACaoa9+9av7Xnfdddd16NDhCN3IfY2Njf8MhNetWxfr1q2LioqKWLduXWzbtk2DdrPS0tLo3LnzP//p0qVLdO3aNbp27eoK52Ziw4YNM//rv/7rxz/60Y+W6wYAALC7CYABAKAZ++UvfznirLPOuq64uNj3gZupmpqaWL9+/T//qaioiMrKyqisrIxNmzZFY2OjJn2AgoKCaN++fbRr1y7at28fHTt2jC5dukSnTp2ic+fOUVxcrEnN1NatW98aP378PVdcccXLugEAAOwpAmAAAGjm2rVrl//ggw+eOWLEiCsLCwvb6gjvtHnz5n+GwZs2bYrKysqorq6OLVu2xJYtW6K6ujqqq6sjk8nk3NpTqVS0bt06WrduHWVlZdGmTZsoLS39X2Fvu3btok2bNh4U/peGhobKl1566efnnHPO+OrqavevAwAAe5QAGAAAiIiIoUOHFt97770XHHjggRfk5+c7ssiHlk6n/xkEV1dXR01Nzfv+k8lkora2NtLpdNTX10dTU1PU1dXt0u8U5+XlRcuWLSM/Pz+KiooiLy8vWrVqFalUKoqLi3f6T0lJSbRq1eqfgW9paWnk5eUZMB9aU1NTzYIFC/745S9/+Y+zZ8+u0REAAGBvEAADAAD/y2mnndb2rrvuurRPnz5n5+XlFeoIe9LbgfDbtm/f/r7XUBcUFESLFi3++b/fDnxhT8pkMg1LliwZd8stt/xq0qRJVToCAADsTQJgAABgp0477bS2d95554X777//5wTBAP9XJpNpWLhw4QO33nrrHwS/AABAtni/ADi/7UHRc2c/SG+LqC33/gcAAHLZokWL6u69995X0un0swcddFCnkpKS3roC8A8VFRUz/7//7/+77aKLLpq6aNGiOh0BAACyRXH3xsgr3fnPBMAAAEDMnDmz8u67736qqalpWr9+/Ypbt27dN5VKpXQGaG4ymUx6zZo1U+65555/Peeccx6cOXNmpa4AAADZRgAMAAB8KDNnzqz88Y9//Gw6nZ4uCAaak7eD37vvvvtfzz///McEvwAAQDYTAAMAAB+JIBhoLgS/AABAEgmAAQCAj+XtILisrOyFvn37diwuLu4VEYJgIBdkKioqnrv33nu/PWbMmEcEvwAAQJK8XwCc2vecGLGzHzSui9j4aivdAwAA/unqq6/u8ZWvfOX8Pn36nJWXl9dCR4CkSafT9UuXLh3/X//1Xw/84he/WKMjAABAEnUYVhsFXXb+MwEwAADwkZ1xxhntb7/99rMPPPDA8/Pz81vrCJDtmpqaqhcsWPDgd77znUcmTpzotC8AAJBoAmAAAGC3GD58eMkPf/jDzwwePPjioqKijjoCZJv6+voNr7322u9vvPHGx2fPnl2jIwAAQC4QAAMAALvV0KFDi++5556zDjnkkPOKioq66giwt9XV1a19/fXXH7z++uvHC34BAIBcIwAGAAD2iFatWuXdc889w0455ZTzO3bseJSOAHtYZsOGDbOmTJny4PXXX/9qbW1tWksAAIBcJAAGAAD2uH/913/tf/7555/dq1ev0/Ly8lroCLC7pNPp+pUrV05+4IEHHvnOd76zSEcAAIBcJwAGAAD2mjPOOKP97bfffvYBBxzw2YKCgjY6AuwqjY2NVW+++eafv/e97z06YcKETToCAAA0FwJgAABgrxs+fHjJ97///dGDBg0aU1paur+OAB9XdXX1wtdee+3Rr371q1Nfe+21Wh0BAACaGwEwAACQVb761a/ue8EFF3y6b9++ZxUUFLTWEeCDNDY2bnnrrbfG/+EPf5j4ox/9aLmOAAAAzZkAGAAAyEpDhw4t/sEPfnDy4MGDz27dunV/HQHerbq6+s2XX375weuuu+7ppUuXbtcRAAAAATAAAJDlCgsLU3ffffeQ0aNHn9G1a9fj8vLyinQFmq90Ol1XXl4+bcqUKROuvfbav+sIAADA/yYABgAAEqNPnz4t/v3f/33UyJEjz2rfvv2nIiKlK9AsZDZt2vTXF1544bGvfe1rzzntCwAA8N4EwAAAQCJddNFFXa6++uqTDzzwwLNbtmzZTUcg99TV1a1ZsGDBuJ/+9KdP3n///et0BAAA4IMJgAEAgETr1q1b4d13333k4YcffmqHDh2OyMvLK9QVSK50Ot2wcePGWbNmzZp8/fXXz6qoqGjUFQAAgA9PAAwAAOSMo48+uvWtt956/CGHHHJKu3btBkdEnq5AIqQrKytfmzdv3uQ777xz+owZM6q1BAAA4OMRAAMAADnpuOOOK/vGN75x/CGHHHJa27ZtB4bvBUO2yVRVVc2dN2/epO9///vTpk+fvkVLAAAAPjkBMAAAkPNuu+22vmedddZJffr0Oa5Vq1a9dQT2ntra2uXLly+f/uijjz51xx13vKUjAAAAu5YAGAAAaFa+9KUvdbv44ouP7t+//wlOBsMekamqqpq7cOHCv/z+97+fcd9995VrCQAAwO4jAAYAAJqtSy65pOtll112jDAYdrl0VVXVvIULF/7lV7/61bO/+93v1moJAADAniEABgAAiIirr766x/nnnz9q//33P7JNmzZDUqlUga7Ah5fJZBoqKyv/vnjx4uf+9Kc/zbr33ntX6woAAMCeJwAGAAB4l379+hV97WtfGzRy5MhRPXv2PLaoqKizrsD/VV9fv37VqlXPvPDCC8/9+7//+5zFixfX6woAAMDeJQAGAAB4H61bt8678847Bx599NFHde/efURpaen+4apomq/M1q1bF69Zs+bF5557btY3v/nNOdXV1WltAQAAyB4CYAAAgI9g8ODBrcaOHXvI8OHDD+vevfvw1q1bHxACYXJXprq6+s01a9a88sorr7z8k5/8ZN5rr71Wqy0AAADZSwAMAADwCVx//fX7nHHGGYf169dvePv27Yfm5+e31hWSrLGxsXrjxo2vvvXWWy+PHz/+lR//+McrdQUAACA5BMAAAAC70Je//OUe55xzzvA+ffoM7tix45CioqKuukI2q6+vX7t27doXFy9ePGfixImv3Xvvvat1BQAAILkEwAAAALvRl7/85R6f+cxnBvfr129Qly5dDm/ZsqVAmL2qrq5u7bp16wS+AAAAOUoADAAAsIe0atUq75prrtnn2GOPPXi//fY7uH379oeUlpb2TaVS+brDbpKuqalZtnHjxnlvvfXW3GeffXbef/3Xfy2vra1Naw0AAEBuEgADAADsRQceeGDLq6+++oAhQ4Yc3LNnz4Pbtm17sGuj+biampqqq6qqXi8vL583Z86ceb/85S/nvfjii1t1BgAAoPkQAAMAAGSZoUOHFn/xi1/cf9CgQQf26NHjwHbt2h3YqlWr3qlUKk932CFdU1OzvLKycsHq1asXzJkzZ8Gf//znJTNmzKjWGgAAgOZNAAwAAJAAxx13XNkFF1xw4MEHH3xA165dDywtLd23pKRkn1QqVag7uS2TyTRs27ZtRXV19dJ169YtfOONNxZOmDBh4YQJEzbpDgAAAO8mAAYAAEiw8847r+OJJ57Yp3///vt16dKlT5s2bfZr3bp1v/z8/GLdSZampqaa6urqxZs3b16ybt26pQsXLlzy9NNPL33ooYc26A4AAAAflgAYAAAgx7Rr1y7/kksu6TFkyJCe++67b89OnTr1Kisr61VcXNyzZcuW3VKpVL4u7R2ZTKaprq6uvKamZtWWLVtWVlRUrFy6dOnK2bNnr7r//vvXVFZWNukSAAAAn4QAGAAAoBnp1KlTwec+97luQ4cO7bnPPvv0aNeuXafWrVt3Li4u7tqyZcvORUVFnfLy8lro1MeTTqe319fXr6+rq6uoqalZW11dvb6ysnL9ihUrVr/66qurHnzwwbUVFRWNOgUAAMDuIgAGAADgfznjjDPaH3bYYZ369OnTuUuXLp3Kysral5SUtC0uLu5YVFTUrqioqG2LFi065OfnlzaXnjQ1NW3dvn37xvr6+qr6+vrKmpqaDdu2bavasmXLpnXr1lUsXbp0/Ysvvrh+4sSJlZ4gAAAA9iYBMAAAAB9Lr169CkeNGtXuoIMOatexY8ey9u3bl7Zp06Z1SUlJWXFxcetWrVq1btGiRVlRUVHrwsLC1hGRX1hYWBoR+QUFBSV5eXkFeXl5u/0/LtPpdG06nW5sbGzcFhFNDQ0NW3f83+r6+vrq7du3b6mtra2uqamp3rZtW/XmzZurN23aVL1hw4YtCxYsqJo1a1bl0qVLt5s4AAAASSAABgAAYK/q169fUffu3Vvss88+xSUlJQVv//8LCwtT3bp1+8BTxuXl5VsbGhoyb//vbdu2Na5YsaJmzZo12xcvXlyvwwAAADQn7xcAF2gPAAAAu9vixYvrdwS11boBAAAAu0+eFgAAAAAAAADkBgEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4o0AIAAAAAAACA5GhoLIyCxoaIiEilIpNXGE1v/0wADAAAAAAAAJAghQUN/0x6MxGppvT/5L6ugAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAIb/v5272ZHiusM4/FZ1NUkz9sQwOF4EyZJtpJCwysa5jSy4n1xPEqRIuQFvvfGSgIwBOzGRQAQERnx0d1UW0cgWGvKxsMGvnmfVdc7/1OJsf+oCAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoMY3JP//9K8My551lzpAk293a7QAAAAAAAAD8iIw3r+SL7TpPxuSt4/ibJJuz20QDBgAAAAAAAHhzrJPp6NvHYcyyjLl7dJTPbl/Jp6sPLufSsM+5ec7q5YOrF0OeP/SVaAAAAAAAAIA3weH7u6zfm79dWDIMSw6225w785vsx3XyzasOby5ssz69c4sAAAAAAAAAr9n69C6bC9sT93a7rKdnORin5Otxynzi1JQcfiwCAwAAAAAAALxO69O7HH68TaaT98cp85R8vbp3Nfszv8q0LHn7xMF1sjk/ZzUPmZ/MmWefhAYAAAAAAAD4oayPdjn7223Gn7x6ZrXPnetX8mBKkpv3cufDd/Pufn5FL56SzcVtNheT3dNt8tQlAwAAAAAAAHyv1sm0ySv/9XtsNWZ3I/lHkgzHi7/4XY7WYz5yiwAAAAAAAAA/Ivtcv/3nPEyS1fHa42t5+vNLyX7JoRsCAAAAAAAAePPt1/nbV3/KvePn1Xc371/NYxEYAAAAAAAA4M0yTHk2rvNo2WdzvHZqzN9v/SF3vju3evng/at5fPDLPDu1yuGyZHSVAAAAAAAAAK/XOGe4ueSvZ4e8M8xZbVe5ceuPufvy3Oqkw4+v5emDX+fuuTlLhhwsEYIBAAAAAAAAXpclGR8OuXP0TR4cPM/9z/+SRyfNDf/1TZezOp/87KdjzizJZkhO7edMy/w/nAUAAAAAAADg/zaMWcZkP8/ZLsmLacr2/MV8+cnvs/tP5/4FmLjAq1ifcioAAAAASUVORK5CYII=";
    function getSmartParseNumber(size, xyDir, layout) {
      if (typeof size === "string" && !isNaN(Number(size)))
        size = Number(size);
      if (typeof size === "number" && size < 100)
        return inch2Emu(size);
      if (typeof size === "number" && size >= 100)
        return size;
      if (typeof size === "string" && size.includes("%")) {
        if (xyDir && xyDir === "X")
          return Math.round(parseFloat(size) / 100 * layout.width);
        if (xyDir && xyDir === "Y")
          return Math.round(parseFloat(size) / 100 * layout.height);
        return Math.round(parseFloat(size) / 100 * layout.width);
      }
      return 0;
    }
    function getUuid(uuidFormat) {
      return uuidFormat.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
    function encodeXmlEntities(xml) {
      if (typeof xml === "undefined" || xml == null)
        return "";
      return xml.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
    function inch2Emu(inches) {
      if (typeof inches === "number" && inches > 100)
        return inches;
      if (typeof inches === "string")
        inches = Number(inches.replace(/in*/gi, ""));
      return Math.round(EMU * inches);
    }
    function valToPts(pt) {
      var points = Number(pt) || 0;
      return isNaN(points) ? 0 : Math.round(points * ONEPT);
    }
    function convertRotationDegrees(d) {
      d = d || 0;
      return Math.round((d > 360 ? d - 360 : d) * 6e4);
    }
    function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }
    function rgbToHex(r, g, b) {
      return (componentToHex(r) + componentToHex(g) + componentToHex(b)).toUpperCase();
    }
    function createColorElement(colorStr, innerElements) {
      var colorVal = (colorStr || "").replace("#", "");
      if (!REGEX_HEX_COLOR.test(colorVal) && colorVal !== SchemeColor.background1 && colorVal !== SchemeColor.background2 && colorVal !== SchemeColor.text1 && colorVal !== SchemeColor.text2 && colorVal !== SchemeColor.accent1 && colorVal !== SchemeColor.accent2 && colorVal !== SchemeColor.accent3 && colorVal !== SchemeColor.accent4 && colorVal !== SchemeColor.accent5 && colorVal !== SchemeColor.accent6) {
        console.warn('"'.concat(colorVal, '" is not a valid scheme color or hex RGB! "').concat(DEF_FONT_COLOR, `" used instead. Only provide 6-digit RGB or 'pptx.SchemeColor' values!`));
        colorVal = DEF_FONT_COLOR;
      }
      var tagName = REGEX_HEX_COLOR.test(colorVal) ? "srgbClr" : "schemeClr";
      var colorAttr = 'val="' + (REGEX_HEX_COLOR.test(colorVal) ? colorVal.toUpperCase() : colorVal) + '"';
      return innerElements ? "<a:".concat(tagName, " ").concat(colorAttr, ">").concat(innerElements, "</a:").concat(tagName, ">") : "<a:".concat(tagName, " ").concat(colorAttr, "/>");
    }
    function createGlowElement(options, defaults) {
      var strXml = "";
      var opts = __assign(__assign({}, defaults), options);
      var size = Math.round(opts.size * ONEPT);
      var color = opts.color;
      var opacity = Math.round(opts.opacity * 1e5);
      strXml += '<a:glow rad="'.concat(size, '">');
      strXml += createColorElement(color, '<a:alpha val="'.concat(opacity, '"/>'));
      strXml += "</a:glow>";
      return strXml;
    }
    function genXmlColorSelection(props) {
      var fillType = "solid";
      var colorVal = "";
      var internalElements = "";
      var outText = "";
      if (props) {
        if (typeof props === "string")
          colorVal = props;
        else {
          if (props.type)
            fillType = props.type;
          if (props.color)
            colorVal = props.color;
          if (props.alpha)
            internalElements += '<a:alpha val="'.concat(Math.round((100 - props.alpha) * 1e3), '"/>');
          if (props.transparency)
            internalElements += '<a:alpha val="'.concat(Math.round((100 - props.transparency) * 1e3), '"/>');
        }
        switch (fillType) {
          case "solid":
            outText += "<a:solidFill>".concat(createColorElement(colorVal, internalElements), "</a:solidFill>");
            break;
          default:
            outText += "";
            break;
        }
      }
      return outText;
    }
    function getNewRelId(target) {
      return target._rels.length + target._relsChart.length + target._relsMedia.length + 1;
    }
    function correctShadowOptions(ShadowProps) {
      if (!ShadowProps || typeof ShadowProps !== "object") {
        return;
      }
      if (ShadowProps.type !== "outer" && ShadowProps.type !== "inner" && ShadowProps.type !== "none") {
        console.warn("Warning: shadow.type options are `outer`, `inner` or `none`.");
        ShadowProps.type = "outer";
      }
      if (ShadowProps.angle) {
        if (isNaN(Number(ShadowProps.angle)) || ShadowProps.angle < 0 || ShadowProps.angle > 359) {
          console.warn("Warning: shadow.angle can only be 0-359");
          ShadowProps.angle = 270;
        }
        ShadowProps.angle = Math.round(Number(ShadowProps.angle));
      }
      if (ShadowProps.opacity) {
        if (isNaN(Number(ShadowProps.opacity)) || ShadowProps.opacity < 0 || ShadowProps.opacity > 1) {
          console.warn("Warning: shadow.opacity can only be 0-1");
          ShadowProps.opacity = 0.75;
        }
        ShadowProps.opacity = Number(ShadowProps.opacity);
      }
      if (ShadowProps.color) {
        if (ShadowProps.color.startsWith("#")) {
          console.warn('Warning: shadow.color should not include hash (#) character, , e.g. "FF0000"');
          ShadowProps.color = ShadowProps.color.replace("#", "");
        }
      }
      return ShadowProps;
    }
    function parseTextToLines(cell, colWidth, verbose) {
      var _a, _b;
      var FOCO = 2.3 + (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.autoPageCharWeight) ? cell.options.autoPageCharWeight : 0);
      var CPL = Math.floor(colWidth / ONEPT * EMU) / ((((_b = cell.options) === null || _b === void 0 ? void 0 : _b.fontSize) ? cell.options.fontSize : DEF_FONT_SIZE) / FOCO);
      var parsedLines = [];
      var inputCells = [];
      var inputLines1 = [];
      var inputLines2 = [];
      if (cell.text && cell.text.toString().trim().length === 0) {
        inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: " " });
      } else if (typeof cell.text === "number" || typeof cell.text === "string") {
        inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: (cell.text || "").toString().trim() });
      } else if (Array.isArray(cell.text)) {
        inputCells = cell.text;
      }
      if (verbose) {
        console.log("[1/4] inputCells");
        inputCells.forEach(function(cell2, idx) {
          return console.log("[1/4] [".concat(idx + 1, "] cell: ").concat(JSON.stringify(cell2)));
        });
      }
      var newLine = [];
      inputCells.forEach(function(cell2) {
        var _a2;
        if (typeof cell2.text === "string") {
          if (cell2.text.split("\n").length > 1) {
            cell2.text.split("\n").forEach(function(textLine) {
              newLine.push({
                _type: SLIDE_OBJECT_TYPES.tablecell,
                text: textLine,
                options: __assign(__assign({}, cell2.options), { breakLine: true })
              });
            });
          } else {
            newLine.push({
              _type: SLIDE_OBJECT_TYPES.tablecell,
              text: cell2.text.trim(),
              options: cell2.options
            });
          }
          if ((_a2 = cell2.options) === null || _a2 === void 0 ? void 0 : _a2.breakLine) {
            if (verbose)
              console.log("inputCells: new line > ".concat(JSON.stringify(newLine)));
            inputLines1.push(newLine);
            newLine = [];
          }
        }
        if (newLine.length > 0) {
          inputLines1.push(newLine);
          newLine = [];
        }
      });
      if (verbose) {
        console.log("[2/4] inputLines1 (".concat(inputLines1.length, ")"));
        inputLines1.forEach(function(line, idx) {
          return console.log("[2/4] [".concat(idx + 1, "] line: ").concat(JSON.stringify(line)));
        });
      }
      inputLines1.forEach(function(line) {
        line.forEach(function(cell2) {
          var lineCells = [];
          var cellTextStr = String(cell2.text);
          var lineWords = cellTextStr.split(" ");
          lineWords.forEach(function(word, idx) {
            var cellProps = __assign({}, cell2.options);
            if (cellProps === null || cellProps === void 0 ? void 0 : cellProps.breakLine)
              cellProps.breakLine = idx + 1 === lineWords.length;
            lineCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: word + (idx + 1 < lineWords.length ? " " : ""), options: cellProps });
          });
          inputLines2.push(lineCells);
        });
      });
      if (verbose) {
        console.log("[3/4] inputLines2 (".concat(inputLines2.length, ")"));
        inputLines2.forEach(function(line) {
          return console.log("[3/4] line: ".concat(JSON.stringify(line)));
        });
      }
      inputLines2.forEach(function(line) {
        var lineCells = [];
        var strCurrLine = "";
        line.forEach(function(word) {
          if (strCurrLine.length + word.text.length > CPL) {
            parsedLines.push(lineCells);
            lineCells = [];
            strCurrLine = "";
          }
          lineCells.push(word);
          strCurrLine += word.text.toString();
        });
        if (lineCells.length > 0)
          parsedLines.push(lineCells);
      });
      if (verbose) {
        console.log("[4/4] parsedLines (".concat(parsedLines.length, ")"));
        parsedLines.forEach(function(line, idx) {
          return console.log("[4/4] [Line ".concat(idx + 1, "]:\n").concat(JSON.stringify(line)));
        });
        console.log("...............................................\n\n");
      }
      return parsedLines;
    }
    function getSlidesForTableRows(tableRows, tableProps, presLayout, masterSlide) {
      if (tableRows === void 0) {
        tableRows = [];
      }
      if (tableProps === void 0) {
        tableProps = {};
      }
      var arrInchMargins = DEF_SLIDE_MARGIN_IN;
      var emuSlideTabW = EMU * 1;
      var emuSlideTabH = EMU * 1;
      var emuTabCurrH = 0;
      var numCols = 0;
      var tableRowSlides = [];
      var tablePropX = getSmartParseNumber(tableProps.x, "X", presLayout);
      var tablePropY = getSmartParseNumber(tableProps.y, "Y", presLayout);
      var tablePropW = getSmartParseNumber(tableProps.w, "X", presLayout);
      var tablePropH = getSmartParseNumber(tableProps.h, "Y", presLayout);
      var tableCalcW = tablePropW;
      function calcSlideTabH() {
        var emuStartY = 0;
        if (tableRowSlides.length === 0)
          emuStartY = tablePropY || inch2Emu(arrInchMargins[0]);
        if (tableRowSlides.length > 0)
          emuStartY = inch2Emu(tableProps.autoPageSlideStartY || tableProps.newSlideStartY || arrInchMargins[0]);
        emuSlideTabH = (tablePropH || presLayout.height) - emuStartY - inch2Emu(arrInchMargins[2]);
        if (tableRowSlides.length > 1) {
          if (typeof tableProps.autoPageSlideStartY === "number") {
            emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.autoPageSlideStartY + arrInchMargins[2]);
          } else if (typeof tableProps.newSlideStartY === "number") {
            emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.newSlideStartY + arrInchMargins[2]);
          } else if (tablePropY) {
            emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu((tablePropY / EMU < arrInchMargins[0] ? tablePropY / EMU : arrInchMargins[0]) + arrInchMargins[2]);
            if (emuSlideTabH < tablePropH)
              emuSlideTabH = tablePropH;
          }
        }
      }
      if (tableProps.verbose) {
        console.log("[[VERBOSE MODE]]");
        console.log("|-- TABLE PROPS --------------------------------------------------------|");
        console.log("| presLayout.width ................................ = ".concat((presLayout.width / EMU).toFixed(1)));
        console.log("| presLayout.height ............................... = ".concat((presLayout.height / EMU).toFixed(1)));
        console.log("| tableProps.x .................................... = ".concat(typeof tableProps.x === "number" ? (tableProps.x / EMU).toFixed(1) : tableProps.x));
        console.log("| tableProps.y .................................... = ".concat(typeof tableProps.y === "number" ? (tableProps.y / EMU).toFixed(1) : tableProps.y));
        console.log("| tableProps.w .................................... = ".concat(typeof tableProps.w === "number" ? (tableProps.w / EMU).toFixed(1) : tableProps.w));
        console.log("| tableProps.h .................................... = ".concat(typeof tableProps.h === "number" ? (tableProps.h / EMU).toFixed(1) : tableProps.h));
        console.log("| tableProps.slideMargin .......................... = ".concat(tableProps.slideMargin ? String(tableProps.slideMargin) : ""));
        console.log("| tableProps.margin ............................... = ".concat(String(tableProps.margin)));
        console.log("| tableProps.colW ................................. = ".concat(String(tableProps.colW)));
        console.log("| tableProps.autoPageSlideStartY .................. = ".concat(tableProps.autoPageSlideStartY));
        console.log("| tableProps.autoPageCharWeight ................... = ".concat(tableProps.autoPageCharWeight));
        console.log("|-- CALCULATIONS -------------------------------------------------------|");
        console.log("| tablePropX ...................................... = ".concat(tablePropX / EMU));
        console.log("| tablePropY ...................................... = ".concat(tablePropY / EMU));
        console.log("| tablePropW ...................................... = ".concat(tablePropW / EMU));
        console.log("| tablePropH ...................................... = ".concat(tablePropH / EMU));
        console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
      }
      {
        if (!tableProps.slideMargin && tableProps.slideMargin !== 0)
          tableProps.slideMargin = DEF_SLIDE_MARGIN_IN[0];
        if (masterSlide && typeof masterSlide._margin !== "undefined") {
          if (Array.isArray(masterSlide._margin))
            arrInchMargins = masterSlide._margin;
          else if (!isNaN(Number(masterSlide._margin))) {
            arrInchMargins = [Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin)];
          }
        } else if (tableProps.slideMargin || tableProps.slideMargin === 0) {
          if (Array.isArray(tableProps.slideMargin))
            arrInchMargins = tableProps.slideMargin;
          else if (!isNaN(tableProps.slideMargin))
            arrInchMargins = [tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin];
        }
        if (tableProps.verbose)
          console.log("| arrInchMargins .................................. = [".concat(arrInchMargins.join(", "), "]"));
      }
      {
        var firstRow = tableRows[0] || [];
        firstRow.forEach(function(cell) {
          if (!cell)
            cell = { _type: SLIDE_OBJECT_TYPES.tablecell };
          var cellOpts = cell.options || null;
          numCols += Number((cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? cellOpts.colspan : 1);
        });
        if (tableProps.verbose)
          console.log("| numCols ......................................... = ".concat(numCols));
      }
      if (!tablePropW && tableProps.colW) {
        tableCalcW = Array.isArray(tableProps.colW) ? tableProps.colW.reduce(function(p, n) {
          return p + n;
        }) * EMU : tableProps.colW * numCols || 0;
        if (tableProps.verbose)
          console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
      }
      {
        emuSlideTabW = tableCalcW || inch2Emu((tablePropX ? tablePropX / EMU : arrInchMargins[1]) + arrInchMargins[3]);
        if (tableProps.verbose)
          console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
      }
      if (!tableProps.colW || !Array.isArray(tableProps.colW)) {
        if (tableProps.colW && !isNaN(Number(tableProps.colW))) {
          var arrColW_1 = [];
          var firstRow = tableRows[0] || [];
          firstRow.forEach(function() {
            return arrColW_1.push(tableProps.colW);
          });
          tableProps.colW = [];
          arrColW_1.forEach(function(val) {
            if (Array.isArray(tableProps.colW))
              tableProps.colW.push(val);
          });
        } else {
          tableProps.colW = [];
          for (var iCol = 0; iCol < numCols; iCol++) {
            tableProps.colW.push(emuSlideTabW / EMU / numCols);
          }
        }
      }
      var newTableRowSlide = { rows: [] };
      tableRows.forEach(function(row, iRow) {
        var rowCellLines = [];
        var maxCellMarTopEmu = 0;
        var maxCellMarBtmEmu = 0;
        var currTableRow = [];
        row.forEach(function(cell) {
          var _a, _b, _c, _d;
          currTableRow.push({
            _type: SLIDE_OBJECT_TYPES.tablecell,
            text: [],
            options: cell.options
          });
          if (cell.options.margin && cell.options.margin[0] >= 1) {
            if (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.margin) && cell.options.margin[0] && valToPts(cell.options.margin[0]) > maxCellMarTopEmu)
              maxCellMarTopEmu = valToPts(cell.options.margin[0]);
            else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && valToPts(tableProps.margin[0]) > maxCellMarTopEmu)
              maxCellMarTopEmu = valToPts(tableProps.margin[0]);
            if (((_b = cell.options) === null || _b === void 0 ? void 0 : _b.margin) && cell.options.margin[2] && valToPts(cell.options.margin[2]) > maxCellMarBtmEmu)
              maxCellMarBtmEmu = valToPts(cell.options.margin[2]);
            else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && valToPts(tableProps.margin[2]) > maxCellMarBtmEmu)
              maxCellMarBtmEmu = valToPts(tableProps.margin[2]);
          } else {
            if (((_c = cell.options) === null || _c === void 0 ? void 0 : _c.margin) && cell.options.margin[0] && inch2Emu(cell.options.margin[0]) > maxCellMarTopEmu)
              maxCellMarTopEmu = inch2Emu(cell.options.margin[0]);
            else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && inch2Emu(tableProps.margin[0]) > maxCellMarTopEmu)
              maxCellMarTopEmu = inch2Emu(tableProps.margin[0]);
            if (((_d = cell.options) === null || _d === void 0 ? void 0 : _d.margin) && cell.options.margin[2] && inch2Emu(cell.options.margin[2]) > maxCellMarBtmEmu)
              maxCellMarBtmEmu = inch2Emu(cell.options.margin[2]);
            else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && inch2Emu(tableProps.margin[2]) > maxCellMarBtmEmu)
              maxCellMarBtmEmu = inch2Emu(tableProps.margin[2]);
          }
        });
        calcSlideTabH();
        emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
        if (tableProps.verbose && iRow === 0)
          console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
        row.forEach(function(cell, iCell) {
          var _a;
          var newCell = {
            _type: SLIDE_OBJECT_TYPES.tablecell,
            _lines: null,
            _lineHeight: inch2Emu((((_a = cell.options) === null || _a === void 0 ? void 0 : _a.fontSize) ? cell.options.fontSize : tableProps.fontSize ? tableProps.fontSize : DEF_FONT_SIZE) * (LINEH_MODIFIER + (tableProps.autoPageLineWeight ? tableProps.autoPageLineWeight : 0)) / 100),
            text: [],
            options: cell.options
          };
          if (newCell.options.rowspan)
            newCell._lineHeight = 0;
          newCell.options.autoPageCharWeight = tableProps.autoPageCharWeight ? tableProps.autoPageCharWeight : null;
          var totalColW = tableProps.colW[iCell];
          if (cell.options.colspan && Array.isArray(tableProps.colW)) {
            totalColW = tableProps.colW.filter(function(_cell, idx) {
              return idx >= iCell && idx < idx + cell.options.colspan;
            }).reduce(function(prev, curr) {
              return prev + curr;
            });
          }
          newCell._lines = parseTextToLines(cell, totalColW, false);
          rowCellLines.push(newCell);
        });
        if (tableProps.verbose)
          console.log("\n| SLIDE [".concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: START..."));
        var currCellIdx = 0;
        var emuLineMaxH = 0;
        var isDone = false;
        while (!isDone) {
          var srcCell = rowCellLines[currCellIdx];
          var tgtCell = currTableRow[currCellIdx];
          rowCellLines.forEach(function(cell) {
            if (cell._lineHeight >= emuLineMaxH)
              emuLineMaxH = cell._lineHeight;
          });
          if (emuTabCurrH + emuLineMaxH > emuSlideTabH) {
            if (tableProps.verbose) {
              console.log("\n|-----------------------------------------------------------------------|");
              console.log("|-- NEW SLIDE CREATED (currTabH+currLineH > maxH) => ".concat((emuTabCurrH / EMU).toFixed(2), " + ").concat((srcCell._lineHeight / EMU).toFixed(2), " > ").concat(emuSlideTabH / EMU));
              console.log("|-----------------------------------------------------------------------|\n\n");
            }
            if (currTableRow.length > 0 && currTableRow.map(function(cell) {
              return cell.text.length;
            }).reduce(function(p, n) {
              return p + n;
            }) > 0)
              newTableRowSlide.rows.push(currTableRow);
            tableRowSlides.push(newTableRowSlide);
            var newRows = [];
            newTableRowSlide = { rows: newRows };
            currTableRow = [];
            row.forEach(function(cell) {
              return currTableRow.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: [], options: cell.options });
            });
            calcSlideTabH();
            emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
            if (tableProps.verbose)
              console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
            emuTabCurrH = 0;
            if ((tableProps.addHeaderToEach || tableProps.autoPageRepeatHeader) && tableProps._arrObjTabHeadRows) {
              tableProps._arrObjTabHeadRows.forEach(function(row2) {
                var newHeadRow = [];
                var maxLineHeight = 0;
                row2.forEach(function(cell) {
                  newHeadRow.push(cell);
                  if (cell._lineHeight > maxLineHeight)
                    maxLineHeight = cell._lineHeight;
                });
                newTableRowSlide.rows.push(newHeadRow);
                emuTabCurrH += maxLineHeight;
              });
            }
            tgtCell = currTableRow[currCellIdx];
          }
          var currLine = srcCell._lines.shift();
          if (Array.isArray(tgtCell.text)) {
            if (currLine)
              tgtCell.text = tgtCell.text.concat(currLine);
            else if (tgtCell.text.length === 0)
              tgtCell.text = tgtCell.text.concat({ _type: SLIDE_OBJECT_TYPES.tablecell, text: "" });
          }
          if (currCellIdx === rowCellLines.length - 1)
            emuTabCurrH += emuLineMaxH;
          currCellIdx = currCellIdx < rowCellLines.length - 1 ? currCellIdx + 1 : 0;
          var brent = rowCellLines.map(function(cell) {
            return cell._lines.length;
          }).reduce(function(prev, next) {
            return prev + next;
          });
          if (brent === 0)
            isDone = true;
        }
        if (currTableRow.length > 0)
          newTableRowSlide.rows.push(currTableRow);
        if (tableProps.verbose) {
          console.log("- SLIDE [".concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: ...COMPLETE ...... emuTabCurrH = ").concat((emuTabCurrH / EMU).toFixed(2), " ( emuSlideTabH = ").concat((emuSlideTabH / EMU).toFixed(2), " )"));
        }
      });
      tableRowSlides.push(newTableRowSlide);
      if (tableProps.verbose) {
        console.log("\n|================================================|");
        console.log("| FINAL: tableRowSlides.length = ".concat(tableRowSlides.length));
        tableRowSlides.forEach(function(slide) {
          return console.log(slide);
        });
        console.log("|================================================|\n\n");
      }
      return tableRowSlides;
    }
    function genTableToSlides(pptx, tabEleId, options, masterSlide) {
      if (options === void 0) {
        options = {};
      }
      var opts = options || {};
      opts.slideMargin = opts.slideMargin || opts.slideMargin === 0 ? opts.slideMargin : 0.5;
      var emuSlideTabW = opts.w || pptx.presLayout.width;
      var arrObjTabHeadRows = [];
      var arrObjTabBodyRows = [];
      var arrObjTabFootRows = [];
      var arrColW = [];
      var arrTabColW = [];
      var arrInchMargins = [0.5, 0.5, 0.5, 0.5];
      var intTabW = 0;
      if (!document.getElementById(tabEleId))
        throw new Error('tableToSlides: Table ID "' + tabEleId + '" does not exist!');
      if (masterSlide === null || masterSlide === void 0 ? void 0 : masterSlide._margin) {
        if (Array.isArray(masterSlide._margin))
          arrInchMargins = masterSlide._margin;
        else if (!isNaN(masterSlide._margin))
          arrInchMargins = [masterSlide._margin, masterSlide._margin, masterSlide._margin, masterSlide._margin];
        opts.slideMargin = arrInchMargins;
      } else if (opts === null || opts === void 0 ? void 0 : opts.slideMargin) {
        if (Array.isArray(opts.slideMargin))
          arrInchMargins = opts.slideMargin;
        else if (!isNaN(opts.slideMargin))
          arrInchMargins = [opts.slideMargin, opts.slideMargin, opts.slideMargin, opts.slideMargin];
      }
      emuSlideTabW = (opts.w ? inch2Emu(opts.w) : pptx.presLayout.width) - inch2Emu(arrInchMargins[1] + arrInchMargins[3]);
      if (opts.verbose) {
        console.log("[[VERBOSE MODE]]");
        console.log("|-- `tableToSlides` ----------------------------------------------------|");
        console.log("| tableProps.h .................................... = ".concat(opts.h));
        console.log("| tableProps.w .................................... = ".concat(opts.w));
        console.log("| pptx.presLayout.width ........................... = ".concat((pptx.presLayout.width / EMU).toFixed(1)));
        console.log("| pptx.presLayout.height .......................... = ".concat((pptx.presLayout.height / EMU).toFixed(1)));
        console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
      }
      var firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child th"));
      if (firstRowCells.length === 0)
        firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child td"));
      firstRowCells.forEach(function(cell) {
        if (cell.getAttribute("colspan")) {
          for (var idxc = 0; idxc < Number(cell.getAttribute("colspan")); idxc++) {
            arrTabColW.push(Math.round(cell.offsetWidth / Number(cell.getAttribute("colspan"))));
          }
        } else {
          arrTabColW.push(cell.offsetWidth);
        }
      });
      arrTabColW.forEach(function(colW) {
        intTabW += colW;
      });
      arrTabColW.forEach(function(colW, idxW) {
        var intCalcWidth = Number((Number(emuSlideTabW) * (colW / intTabW * 100) / 100 / EMU).toFixed(2));
        var intMinWidth = 0;
        var colSelectorMin = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
        if (colSelectorMin)
          intMinWidth = Number(colSelectorMin.getAttribute("data-pptx-min-width"));
        var colSelectorSet = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
        if (colSelectorSet)
          intMinWidth = Number(colSelectorSet.getAttribute("data-pptx-width"));
        arrColW.push(intMinWidth > intCalcWidth ? intMinWidth : intCalcWidth);
      });
      if (opts.verbose) {
        console.log("| arrColW ......................................... = [".concat(arrColW.join(", "), "]"));
      }
      var tableParts = ["thead", "tbody", "tfoot"];
      tableParts.forEach(function(part) {
        document.querySelectorAll("#".concat(tabEleId, " ").concat(part, " tr")).forEach(function(row) {
          var arrObjTabCells = [];
          Array.from(row.cells).forEach(function(cell) {
            var arrRGB1 = window.getComputedStyle(cell).getPropertyValue("color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
            var arrRGB2 = window.getComputedStyle(cell).getPropertyValue("background-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
            if (
              // NOTE: (ISSUE#57): Default for unstyled tables is black bkgd, so use white instead
              window.getComputedStyle(cell).getPropertyValue("background-color") === "rgba(0, 0, 0, 0)" || window.getComputedStyle(cell).getPropertyValue("transparent")
            ) {
              arrRGB2 = ["255", "255", "255"];
            }
            var cellOpts = {
              align: null,
              bold: !!(window.getComputedStyle(cell).getPropertyValue("font-weight") === "bold" || Number(window.getComputedStyle(cell).getPropertyValue("font-weight")) >= 500),
              border: null,
              color: rgbToHex(Number(arrRGB1[0]), Number(arrRGB1[1]), Number(arrRGB1[2])),
              fill: { color: rgbToHex(Number(arrRGB2[0]), Number(arrRGB2[1]), Number(arrRGB2[2])) },
              fontFace: (window.getComputedStyle(cell).getPropertyValue("font-family") || "").split(",")[0].replace(/"/g, "").replace("inherit", "").replace("initial", "") || null,
              fontSize: Number(window.getComputedStyle(cell).getPropertyValue("font-size").replace(/[a-z]/gi, "")),
              margin: null,
              colspan: Number(cell.getAttribute("colspan")) || null,
              rowspan: Number(cell.getAttribute("rowspan")) || null,
              valign: null
            };
            if (["left", "center", "right", "start", "end"].includes(window.getComputedStyle(cell).getPropertyValue("text-align"))) {
              var align = window.getComputedStyle(cell).getPropertyValue("text-align").replace("start", "left").replace("end", "right");
              cellOpts.align = align === "center" ? "center" : align === "left" ? "left" : align === "right" ? "right" : null;
            }
            if (["top", "middle", "bottom"].includes(window.getComputedStyle(cell).getPropertyValue("vertical-align"))) {
              var valign = window.getComputedStyle(cell).getPropertyValue("vertical-align");
              cellOpts.valign = valign === "top" ? "top" : valign === "middle" ? "middle" : valign === "bottom" ? "bottom" : null;
            }
            if (window.getComputedStyle(cell).getPropertyValue("padding-left")) {
              cellOpts.margin = [0, 0, 0, 0];
              var sidesPad = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
              sidesPad.forEach(function(val, idxs) {
                cellOpts.margin[idxs] = Math.round(Number(window.getComputedStyle(cell).getPropertyValue(val).replace(/\D/gi, "")));
              });
            }
            if (window.getComputedStyle(cell).getPropertyValue("border-top-width") || window.getComputedStyle(cell).getPropertyValue("border-right-width") || window.getComputedStyle(cell).getPropertyValue("border-bottom-width") || window.getComputedStyle(cell).getPropertyValue("border-left-width")) {
              cellOpts.border = [null, null, null, null];
              var sidesBor = ["top", "right", "bottom", "left"];
              sidesBor.forEach(function(val, idxb) {
                var intBorderW = Math.round(Number(window.getComputedStyle(cell).getPropertyValue("border-" + val + "-width").replace("px", "")));
                var arrRGB = [];
                arrRGB = window.getComputedStyle(cell).getPropertyValue("border-" + val + "-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
                var strBorderC = rgbToHex(Number(arrRGB[0]), Number(arrRGB[1]), Number(arrRGB[2]));
                cellOpts.border[idxb] = { pt: intBorderW, color: strBorderC };
              });
            }
            arrObjTabCells.push({
              _type: SLIDE_OBJECT_TYPES.tablecell,
              text: cell.innerText,
              options: cellOpts
            });
          });
          switch (part) {
            case "thead":
              arrObjTabHeadRows.push(arrObjTabCells);
              break;
            case "tbody":
              arrObjTabBodyRows.push(arrObjTabCells);
              break;
            case "tfoot":
              arrObjTabFootRows.push(arrObjTabCells);
              break;
            default:
              console.log("table parsing: unexpected table part: ".concat(part));
              break;
          }
        });
      });
      opts._arrObjTabHeadRows = arrObjTabHeadRows || null;
      opts.colW = arrColW;
      getSlidesForTableRows(__spreadArray(__spreadArray(__spreadArray([], arrObjTabHeadRows, true), arrObjTabBodyRows, true), arrObjTabFootRows, true), opts, pptx.presLayout, masterSlide).forEach(function(slide, idxTr) {
        var newSlide = pptx.addSlide({ masterName: opts.masterSlideName || null });
        if (idxTr === 0)
          opts.y = opts.y || arrInchMargins[0];
        if (idxTr > 0)
          opts.y = opts.autoPageSlideStartY || opts.newSlideStartY || arrInchMargins[0];
        if (opts.verbose)
          console.log("| opts.autoPageSlideStartY: ".concat(opts.autoPageSlideStartY, " / arrInchMargins[0]: ").concat(arrInchMargins[0], " => opts.y = ").concat(opts.y));
        newSlide.addTable(slide.rows, { x: opts.x || arrInchMargins[3], y: opts.y, w: Number(emuSlideTabW) / EMU, colW: arrColW, autoPage: false });
        if (opts.addImage) {
          opts.addImage.options = opts.addImage.options || {};
          if (!opts.addImage.image || !opts.addImage.image.path && !opts.addImage.image.data) {
            console.warn("Warning: tableToSlides.addImage requires either `path` or `data`");
          } else {
            newSlide.addImage({
              path: opts.addImage.image.path,
              data: opts.addImage.image.data,
              x: opts.addImage.options.x,
              y: opts.addImage.options.y,
              w: opts.addImage.options.w,
              h: opts.addImage.options.h
            });
          }
        }
        if (opts.addShape)
          newSlide.addShape(opts.addShape.shapeName, opts.addShape.options || {});
        if (opts.addTable)
          newSlide.addTable(opts.addTable.rows, opts.addTable.options || {});
        if (opts.addText)
          newSlide.addText(opts.addText.text, opts.addText.options || {});
      });
    }
    var _chartCounter = 0;
    function createSlideMaster(props, target) {
      if (props.bkgd)
        target.bkgd = props.bkgd;
      if (props.objects && Array.isArray(props.objects) && props.objects.length > 0) {
        props.objects.forEach(function(object, idx) {
          var key = Object.keys(object)[0];
          var tgt = target;
          if (MASTER_OBJECTS[key] && key === "chart")
            addChartDefinition(tgt, object[key].type, object[key].data, object[key].opts);
          else if (MASTER_OBJECTS[key] && key === "image")
            addImageDefinition(tgt, object[key]);
          else if (MASTER_OBJECTS[key] && key === "line")
            addShapeDefinition(tgt, SHAPE_TYPE.LINE, object[key]);
          else if (MASTER_OBJECTS[key] && key === "rect")
            addShapeDefinition(tgt, SHAPE_TYPE.RECTANGLE, object[key]);
          else if (MASTER_OBJECTS[key] && key === "text")
            addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, false);
          else if (MASTER_OBJECTS[key] && key === "placeholder") {
            object[key].options.placeholder = object[key].options.name;
            delete object[key].options.name;
            object[key].options._placeholderType = object[key].options.type;
            delete object[key].options.type;
            object[key].options._placeholderIdx = 100 + idx;
            addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, true);
          }
        });
      }
      if (props.slideNumber && typeof props.slideNumber === "object")
        target._slideNumberProps = props.slideNumber;
    }
    function addChartDefinition(target, type, data, opt) {
      var _a;
      function correctGridLineOptions(glOpts) {
        if (!glOpts || glOpts.style === "none")
          return;
        if (glOpts.size !== void 0 && (isNaN(Number(glOpts.size)) || glOpts.size <= 0)) {
          console.warn("Warning: chart.gridLine.size must be greater than 0.");
          delete glOpts.size;
        }
        if (glOpts.style && !["solid", "dash", "dot"].includes(glOpts.style)) {
          console.warn("Warning: chart.gridLine.style options: `solid`, `dash`, `dot`.");
          delete glOpts.style;
        }
        if (glOpts.cap && !["flat", "square", "round"].includes(glOpts.cap)) {
          console.warn("Warning: chart.gridLine.cap options: `flat`, `square`, `round`.");
          delete glOpts.cap;
        }
      }
      var chartId = ++_chartCounter;
      var resultObject = {
        _type: null,
        text: null,
        options: null,
        chartRid: null
      };
      var tmpOpt = null;
      var tmpData = [];
      if (Array.isArray(type)) {
        type.forEach(function(obj) {
          tmpData = tmpData.concat(obj.data);
        });
        tmpOpt = data || opt;
      } else {
        tmpData = data;
        tmpOpt = opt;
      }
      tmpData.forEach(function(item, i) {
        item._dataIndex = i;
        if (item.labels !== void 0 && !Array.isArray(item.labels[0])) {
          item.labels = [item.labels];
        }
      });
      var options = tmpOpt && typeof tmpOpt === "object" ? tmpOpt : {};
      options._type = type;
      options.x = typeof options.x !== "undefined" && options.x != null && !isNaN(Number(options.x)) ? options.x : 1;
      options.y = typeof options.y !== "undefined" && options.y != null && !isNaN(Number(options.y)) ? options.y : 1;
      options.w = options.w || "50%";
      options.h = options.h || "50%";
      options.objectName = options.objectName ? encodeXmlEntities(options.objectName) : "Chart ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.chart;
      }).length);
      if (!["bar", "col"].includes(options.barDir || ""))
        options.barDir = "col";
      if (options._type === CHART_TYPE.AREA) {
        if (!["stacked", "standard", "percentStacked"].includes(options.barGrouping || ""))
          options.barGrouping = "standard";
      }
      if (options._type === CHART_TYPE.BAR) {
        if (!["clustered", "stacked", "percentStacked"].includes(options.barGrouping || ""))
          options.barGrouping = "clustered";
      }
      if (options._type === CHART_TYPE.BAR3D) {
        if (!["clustered", "stacked", "standard", "percentStacked"].includes(options.barGrouping || ""))
          options.barGrouping = "standard";
      }
      if ((_a = options.barGrouping) === null || _a === void 0 ? void 0 : _a.includes("tacked")) {
        if (!options.barGapWidthPct)
          options.barGapWidthPct = 50;
      }
      if (options.dataLabelPosition) {
        if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.DOUGHNUT || options._type === CHART_TYPE.RADAR) {
          delete options.dataLabelPosition;
        }
        if (options._type === CHART_TYPE.PIE) {
          if (!["bestFit", "ctr", "inEnd", "outEnd"].includes(options.dataLabelPosition))
            delete options.dataLabelPosition;
        }
        if (options._type === CHART_TYPE.BUBBLE || options._type === CHART_TYPE.BUBBLE3D || options._type === CHART_TYPE.LINE || options._type === CHART_TYPE.SCATTER) {
          if (!["b", "ctr", "l", "r", "t"].includes(options.dataLabelPosition))
            delete options.dataLabelPosition;
        }
        if (options._type === CHART_TYPE.BAR) {
          if (!["stacked", "percentStacked"].includes(options.barGrouping || "")) {
            if (!["ctr", "inBase", "inEnd"].includes(options.dataLabelPosition))
              delete options.dataLabelPosition;
          }
          if (!["clustered"].includes(options.barGrouping || "")) {
            if (!["ctr", "inBase", "inEnd", "outEnd"].includes(options.dataLabelPosition))
              delete options.dataLabelPosition;
          }
        }
      }
      options.dataLabelBkgrdColors = options.dataLabelBkgrdColors || !options.dataLabelBkgrdColors ? options.dataLabelBkgrdColors : false;
      if (!["b", "l", "r", "t", "tr"].includes(options.legendPos || ""))
        options.legendPos = "r";
      if (!["cone", "coneToMax", "box", "cylinder", "pyramid", "pyramidToMax"].includes(options.bar3DShape || ""))
        options.bar3DShape = "box";
      if (!["circle", "dash", "diamond", "dot", "none", "square", "triangle"].includes(options.lineDataSymbol || ""))
        options.lineDataSymbol = "circle";
      if (!["gap", "span"].includes(options.displayBlanksAs || ""))
        options.displayBlanksAs = "span";
      if (!["standard", "marker", "filled"].includes(options.radarStyle || ""))
        options.radarStyle = "standard";
      options.lineDataSymbolSize = options.lineDataSymbolSize && !isNaN(options.lineDataSymbolSize) ? options.lineDataSymbolSize : 6;
      options.lineDataSymbolLineSize = options.lineDataSymbolLineSize && !isNaN(options.lineDataSymbolLineSize) ? valToPts(options.lineDataSymbolLineSize) : valToPts(0.75);
      if (options.layout) {
        ["x", "y", "w", "h"].forEach(function(key) {
          var val = options.layout[key];
          if (isNaN(Number(val)) || val < 0 || val > 1) {
            console.warn("Warning: chart.layout." + key + " can only be 0-1");
            delete options.layout[key];
          }
        });
      }
      options.catGridLine = options.catGridLine || (options._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : { style: "none" });
      options.valGridLine = options.valGridLine || (options._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : {});
      options.serGridLine = options.serGridLine || (options._type === CHART_TYPE.SCATTER ? { color: "D9D9D9", size: 1 } : { style: "none" });
      correctGridLineOptions(options.catGridLine);
      correctGridLineOptions(options.valGridLine);
      correctGridLineOptions(options.serGridLine);
      correctShadowOptions(options.shadow);
      options.showDataTable = options.showDataTable || !options.showDataTable ? options.showDataTable : false;
      options.showDataTableHorzBorder = options.showDataTableHorzBorder || !options.showDataTableHorzBorder ? options.showDataTableHorzBorder : true;
      options.showDataTableVertBorder = options.showDataTableVertBorder || !options.showDataTableVertBorder ? options.showDataTableVertBorder : true;
      options.showDataTableOutline = options.showDataTableOutline || !options.showDataTableOutline ? options.showDataTableOutline : true;
      options.showDataTableKeys = options.showDataTableKeys || !options.showDataTableKeys ? options.showDataTableKeys : true;
      options.showLabel = options.showLabel || !options.showLabel ? options.showLabel : false;
      options.showLegend = options.showLegend || !options.showLegend ? options.showLegend : false;
      options.showPercent = options.showPercent || !options.showPercent ? options.showPercent : true;
      options.showTitle = options.showTitle || !options.showTitle ? options.showTitle : false;
      options.showValue = options.showValue || !options.showValue ? options.showValue : false;
      options.showLeaderLines = options.showLeaderLines || !options.showLeaderLines ? options.showLeaderLines : false;
      options.catAxisLineShow = typeof options.catAxisLineShow !== "undefined" ? options.catAxisLineShow : true;
      options.valAxisLineShow = typeof options.valAxisLineShow !== "undefined" ? options.valAxisLineShow : true;
      options.serAxisLineShow = typeof options.serAxisLineShow !== "undefined" ? options.serAxisLineShow : true;
      options.v3DRotX = !isNaN(options.v3DRotX) && options.v3DRotX >= -90 && options.v3DRotX <= 90 ? options.v3DRotX : 30;
      options.v3DRotY = !isNaN(options.v3DRotY) && options.v3DRotY >= 0 && options.v3DRotY <= 360 ? options.v3DRotY : 30;
      options.v3DRAngAx = options.v3DRAngAx || !options.v3DRAngAx ? options.v3DRAngAx : true;
      options.v3DPerspective = !isNaN(options.v3DPerspective) && options.v3DPerspective >= 0 && options.v3DPerspective <= 240 ? options.v3DPerspective : 30;
      options.barGapWidthPct = !isNaN(options.barGapWidthPct) && options.barGapWidthPct >= 0 && options.barGapWidthPct <= 1e3 ? options.barGapWidthPct : 150;
      options.barGapDepthPct = !isNaN(options.barGapDepthPct) && options.barGapDepthPct >= 0 && options.barGapDepthPct <= 1e3 ? options.barGapDepthPct : 150;
      options.chartColors = Array.isArray(options.chartColors) ? options.chartColors : options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT ? PIECHART_COLORS : BARCHART_COLORS;
      options.chartColorsOpacity = options.chartColorsOpacity && !isNaN(options.chartColorsOpacity) ? options.chartColorsOpacity : null;
      options.border = options.border && typeof options.border === "object" ? options.border : null;
      if (options.border && (!options.border.pt || isNaN(options.border.pt)))
        options.border.pt = DEF_CHART_BORDER.pt;
      if (options.border && (!options.border.color || typeof options.border.color !== "string"))
        options.border.color = DEF_CHART_BORDER.color;
      options.plotArea = options.plotArea || {};
      options.plotArea.border = options.plotArea.border && typeof options.plotArea.border === "object" ? options.plotArea.border : null;
      if (options.plotArea.border && (!options.plotArea.border.pt || isNaN(options.plotArea.border.pt)))
        options.plotArea.border.pt = DEF_CHART_BORDER.pt;
      if (options.plotArea.border && (!options.plotArea.border.color || typeof options.plotArea.border.color !== "string")) {
        options.plotArea.border.color = DEF_CHART_BORDER.color;
      }
      if (options.border)
        options.plotArea.border = options.border;
      options.plotArea.fill = options.plotArea.fill || { color: null, transparency: null };
      if (options.fill)
        options.plotArea.fill.color = options.fill;
      options.chartArea = options.chartArea || {};
      options.chartArea.border = options.chartArea.border && typeof options.chartArea.border === "object" ? options.chartArea.border : null;
      if (options.chartArea.border) {
        options.chartArea.border = {
          color: options.chartArea.border.color || DEF_CHART_BORDER.color,
          pt: options.chartArea.border.pt || DEF_CHART_BORDER.pt
        };
      }
      options.chartArea.roundedCorners = typeof options.chartArea.roundedCorners === "boolean" ? options.chartArea.roundedCorners : true;
      options.dataBorder = options.dataBorder && typeof options.dataBorder === "object" ? options.dataBorder : null;
      if (options.dataBorder && (!options.dataBorder.pt || isNaN(options.dataBorder.pt)))
        options.dataBorder.pt = 0.75;
      if (options.dataBorder && (!options.dataBorder.color || typeof options.dataBorder.color !== "string" || options.dataBorder.color.length !== 6)) {
        options.dataBorder.color = "F9F9F9";
      }
      if (!options.dataLabelFormatCode && options._type === CHART_TYPE.SCATTER)
        options.dataLabelFormatCode = "General";
      if (!options.dataLabelFormatCode && (options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT)) {
        options.dataLabelFormatCode = options.showPercent ? "0%" : "General";
      }
      options.dataLabelFormatCode = options.dataLabelFormatCode && typeof options.dataLabelFormatCode === "string" ? options.dataLabelFormatCode : "#,##0";
      if (!options.dataLabelFormatScatter && options._type === CHART_TYPE.SCATTER)
        options.dataLabelFormatScatter = "custom";
      options.lineSize = typeof options.lineSize === "number" ? options.lineSize : 2;
      options.valAxisMajorUnit = typeof options.valAxisMajorUnit === "number" ? options.valAxisMajorUnit : null;
      if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.LINE) {
        options.catAxisMultiLevelLabels = !!options.catAxisMultiLevelLabels;
      } else {
        delete options.catAxisMultiLevelLabels;
      }
      resultObject._type = "chart";
      resultObject.options = options;
      resultObject.chartRid = getNewRelId(target);
      target._relsChart.push({
        rId: getNewRelId(target),
        data: tmpData,
        opts: options,
        type: options._type,
        globalId: chartId,
        fileName: "chart".concat(chartId, ".xml"),
        Target: "/ppt/charts/chart".concat(chartId, ".xml")
      });
      target._slideObjects.push(resultObject);
      return resultObject;
    }
    function addImageDefinition(target, opt) {
      var newObject = {
        _type: null,
        text: null,
        options: null,
        image: null,
        imageRid: null,
        hyperlink: null
      };
      var intPosX = opt.x || 0;
      var intPosY = opt.y || 0;
      var intWidth = opt.w || 0;
      var intHeight = opt.h || 0;
      var sizing = opt.sizing || null;
      var objHyperlink = opt.hyperlink || "";
      var strImageData = opt.data || "";
      var strImagePath = opt.path || "";
      var imageRelId = getNewRelId(target);
      var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Image ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.image;
      }).length);
      if (!strImagePath && !strImageData) {
        console.error("ERROR: addImage() requires either 'data' or 'path' parameter!");
        return null;
      } else if (strImagePath && typeof strImagePath !== "string") {
        console.error("ERROR: addImage() 'path' should be a string, ex: {path:'/img/sample.png'} - you sent ".concat(String(strImagePath)));
        return null;
      } else if (strImageData && typeof strImageData !== "string") {
        console.error("ERROR: addImage() 'data' should be a string, ex: {data:'image/png;base64,NMP[...]'} - you sent ".concat(String(strImageData)));
        return null;
      } else if (strImageData && typeof strImageData === "string" && !strImageData.toLowerCase().includes("base64,")) {
        console.error("ERROR: Image `data` value lacks a base64 header! Ex: 'image/png;base64,NMP[...]')");
        return null;
      }
      var strImgExtn = (strImagePath.substring(strImagePath.lastIndexOf("/") + 1).split("?")[0].split(".").pop().split("#")[0] || "png").toLowerCase();
      if (strImageData && /image\/(\w+);/.exec(strImageData) && /image\/(\w+);/.exec(strImageData).length > 0) {
        strImgExtn = /image\/(\w+);/.exec(strImageData)[1];
      } else if (strImageData === null || strImageData === void 0 ? void 0 : strImageData.toLowerCase().includes("image/svg+xml")) {
        strImgExtn = "svg";
      }
      newObject._type = SLIDE_OBJECT_TYPES.image;
      newObject.image = strImagePath || "preencoded.png";
      newObject.options = {
        x: intPosX || 0,
        y: intPosY || 0,
        w: intWidth || 1,
        h: intHeight || 1,
        altText: opt.altText || "",
        rounding: typeof opt.rounding === "boolean" ? opt.rounding : false,
        sizing,
        placeholder: opt.placeholder,
        rotate: opt.rotate || 0,
        flipV: opt.flipV || false,
        flipH: opt.flipH || false,
        transparency: opt.transparency || 0,
        objectName,
        shadow: correctShadowOptions(opt.shadow)
      };
      if (strImgExtn === "svg") {
        target._relsMedia.push({
          path: strImagePath || strImageData + "png",
          type: "image/png",
          extn: "png",
          data: strImageData || "",
          rId: imageRelId,
          Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png"),
          isSvgPng: true,
          svgSize: { w: getSmartParseNumber(newObject.options.w, "X", target._presLayout), h: getSmartParseNumber(newObject.options.h, "Y", target._presLayout) }
        });
        newObject.imageRid = imageRelId;
        target._relsMedia.push({
          path: strImagePath || strImageData,
          type: "image/svg+xml",
          extn: strImgExtn,
          data: strImageData || "",
          rId: imageRelId + 1,
          Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
        });
        newObject.imageRid = imageRelId + 1;
      } else {
        var dupeItem = target._relsMedia.filter(function(item) {
          return item.path && item.path === strImagePath && item.type === "image/" + strImgExtn && !item.isDuplicate;
        })[0];
        target._relsMedia.push({
          path: strImagePath || "preencoded." + strImgExtn,
          type: "image/" + strImgExtn,
          extn: strImgExtn,
          data: strImageData || "",
          rId: imageRelId,
          isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
          Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
        });
        newObject.imageRid = imageRelId;
      }
      if (typeof objHyperlink === "object") {
        if (!objHyperlink.url && !objHyperlink.slide)
          throw new Error("ERROR: `hyperlink` option requires either: `url` or `slide`");
        else {
          imageRelId++;
          target._rels.push({
            type: SLIDE_OBJECT_TYPES.hyperlink,
            data: objHyperlink.slide ? "slide" : "dummy",
            rId: imageRelId,
            Target: objHyperlink.url || objHyperlink.slide.toString()
          });
          objHyperlink._rId = imageRelId;
          newObject.hyperlink = objHyperlink;
        }
      }
      target._slideObjects.push(newObject);
    }
    function addMediaDefinition(target, opt) {
      var intPosX = opt.x || 0;
      var intPosY = opt.y || 0;
      var intSizeX = opt.w || 2;
      var intSizeY = opt.h || 2;
      var strData = opt.data || "";
      var strLink = opt.link || "";
      var strPath = opt.path || "";
      var strType = opt.type || "audio";
      var strExtn = "";
      var strCover = opt.cover || IMG_PLAYBTN;
      var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Media ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.media;
      }).length);
      var slideData = { _type: SLIDE_OBJECT_TYPES.media };
      if (!strPath && !strData && strType !== "online") {
        throw new Error("addMedia() error: either `data` or `path` are required!");
      } else if (strData && !strData.toLowerCase().includes("base64,")) {
        throw new Error("addMedia() error: `data` value lacks a base64 header! Ex: 'video/mpeg;base64,NMP[...]')");
      } else if (strCover && !strCover.toLowerCase().includes("base64,")) {
        throw new Error("addMedia() error: `cover` value lacks a base64 header! Ex: 'data:image/png;base64,iV[...]')");
      }
      if (strType === "online" && !strLink) {
        throw new Error("addMedia() error: online videos require `link` value");
      }
      strExtn = opt.extn || (strData ? strData.split(";")[0].split("/")[1] : strPath.split(".").pop()) || "mp3";
      slideData.mtype = strType;
      slideData.media = strPath || "preencoded.mov";
      slideData.options = {};
      slideData.options.x = intPosX;
      slideData.options.y = intPosY;
      slideData.options.w = intSizeX;
      slideData.options.h = intSizeY;
      slideData.options.objectName = objectName;
      if (strType === "online") {
        var relId1 = getNewRelId(target);
        target._relsMedia.push({
          path: strPath || "preencoded" + strExtn,
          data: "dummy",
          type: "online",
          extn: strExtn,
          rId: relId1,
          Target: strLink
        });
        slideData.mediaRid = relId1;
        target._relsMedia.push({
          path: "preencoded.png",
          data: strCover,
          type: "image/png",
          extn: "png",
          rId: getNewRelId(target),
          Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png")
        });
      } else {
        var dupeItem = target._relsMedia.filter(function(item) {
          return item.path && item.path === strPath && item.type === strType + "/" + strExtn && !item.isDuplicate;
        })[0];
        var relId1 = getNewRelId(target);
        target._relsMedia.push({
          path: strPath || "preencoded" + strExtn,
          type: strType + "/" + strExtn,
          extn: strExtn,
          data: strData || "",
          rId: relId1,
          isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
          Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strExtn)
        });
        slideData.mediaRid = relId1;
        target._relsMedia.push({
          path: strPath || "preencoded" + strExtn,
          type: strType + "/" + strExtn,
          extn: strExtn,
          data: strData || "",
          rId: getNewRelId(target),
          isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
          Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 0, ".").concat(strExtn)
        });
        target._relsMedia.push({
          path: "preencoded.png",
          type: "image/png",
          extn: "png",
          data: strCover,
          rId: getNewRelId(target),
          Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png")
        });
      }
      target._slideObjects.push(slideData);
    }
    function addNotesDefinition(target, notes) {
      target._slideObjects.push({
        _type: SLIDE_OBJECT_TYPES.notes,
        text: [{ text: notes }]
      });
    }
    function addShapeDefinition(target, shapeName, opts) {
      var options = typeof opts === "object" ? opts : {};
      options.line = options.line || { type: "none" };
      var newObject = {
        _type: SLIDE_OBJECT_TYPES.text,
        shape: shapeName || SHAPE_TYPE.RECTANGLE,
        options,
        text: null
      };
      if (!shapeName)
        throw new Error("Missing/Invalid shape parameter! Example: `addShape(pptxgen.shapes.LINE, {x:1, y:1, w:1, h:1});`");
      var newLineOpts = {
        type: options.line.type || "solid",
        color: options.line.color || DEF_SHAPE_LINE_COLOR,
        transparency: options.line.transparency || 0,
        width: options.line.width || 1,
        dashType: options.line.dashType || "solid",
        beginArrowType: options.line.beginArrowType || null,
        endArrowType: options.line.endArrowType || null
      };
      if (typeof options.line === "object" && options.line.type !== "none")
        options.line = newLineOpts;
      options.x = options.x || (options.x === 0 ? 0 : 1);
      options.y = options.y || (options.y === 0 ? 0 : 1);
      options.w = options.w || (options.w === 0 ? 0 : 1);
      options.h = options.h || (options.h === 0 ? 0 : 1);
      options.objectName = options.objectName ? encodeXmlEntities(options.objectName) : "Shape ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.text;
      }).length);
      if (typeof options.line === "string") {
        var tmpOpts = newLineOpts;
        tmpOpts.color = String(options.line);
        options.line = tmpOpts;
      }
      if (typeof options.lineSize === "number")
        options.line.width = options.lineSize;
      if (typeof options.lineDash === "string")
        options.line.dashType = options.lineDash;
      if (typeof options.lineHead === "string")
        options.line.beginArrowType = options.lineHead;
      if (typeof options.lineTail === "string")
        options.line.endArrowType = options.lineTail;
      createHyperlinkRels(target, newObject);
      target._slideObjects.push(newObject);
    }
    function addTableDefinition(target, tableRows, options, slideLayout, presLayout, addSlide, getSlide) {
      var slides = [target];
      var opt = options && typeof options === "object" ? options : {};
      opt.objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Table ".concat(target._slideObjects.filter(function(obj) {
        return obj._type === SLIDE_OBJECT_TYPES.table;
      }).length);
      {
        if (tableRows === null || tableRows.length === 0 || !Array.isArray(tableRows)) {
          throw new Error("addTable: Array expected! EX: 'slide.addTable( [rows], {options} );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)");
        }
        if (!tableRows[0] || !Array.isArray(tableRows[0])) {
          throw new Error("addTable: 'rows' should be an array of cells! EX: 'slide.addTable( [ ['A'], ['B'], {text:'C',options:{align:'center'}} ] );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)");
        }
      }
      var arrRows = [];
      tableRows.forEach(function(row) {
        var newRow = [];
        if (Array.isArray(row)) {
          row.forEach(function(cell) {
            var newCell = {
              _type: SLIDE_OBJECT_TYPES.tablecell,
              text: "",
              options: typeof cell === "object" && cell.options ? cell.options : {}
            };
            if (typeof cell === "string" || typeof cell === "number")
              newCell.text = cell.toString();
            else if (cell.text) {
              if (typeof cell.text === "string" || typeof cell.text === "number")
                newCell.text = cell.text.toString();
              else if (cell.text)
                newCell.text = cell.text;
              if (cell.options && typeof cell.options === "object")
                newCell.options = cell.options;
            }
            newCell.options.border = newCell.options.border || opt.border || [{ type: "none" }, { type: "none" }, { type: "none" }, { type: "none" }];
            var cellBorder = newCell.options.border;
            if (!Array.isArray(cellBorder) && typeof cellBorder === "object")
              newCell.options.border = [cellBorder, cellBorder, cellBorder, cellBorder];
            if (!newCell.options.border[0])
              newCell.options.border[0] = { type: "none" };
            if (!newCell.options.border[1])
              newCell.options.border[1] = { type: "none" };
            if (!newCell.options.border[2])
              newCell.options.border[2] = { type: "none" };
            if (!newCell.options.border[3])
              newCell.options.border[3] = { type: "none" };
            var arrSides = [0, 1, 2, 3];
            arrSides.forEach(function(idx) {
              newCell.options.border[idx] = {
                type: newCell.options.border[idx].type || DEF_CELL_BORDER.type,
                color: newCell.options.border[idx].color || DEF_CELL_BORDER.color,
                pt: typeof newCell.options.border[idx].pt === "number" ? newCell.options.border[idx].pt : DEF_CELL_BORDER.pt
              };
            });
            newRow.push(newCell);
          });
        } else {
          console.log("addTable: tableRows has a bad row. A row should be an array of cells. You provided:");
          console.log(row);
        }
        arrRows.push(newRow);
      });
      opt.x = getSmartParseNumber(opt.x || (opt.x === 0 ? 0 : EMU / 2), "X", presLayout);
      opt.y = getSmartParseNumber(opt.y || (opt.y === 0 ? 0 : EMU / 2), "Y", presLayout);
      if (opt.h)
        opt.h = getSmartParseNumber(opt.h, "Y", presLayout);
      opt.fontSize = opt.fontSize || DEF_FONT_SIZE;
      opt.margin = opt.margin === 0 || opt.margin ? opt.margin : DEF_CELL_MARGIN_IN;
      if (typeof opt.margin === "number")
        opt.margin = [Number(opt.margin), Number(opt.margin), Number(opt.margin), Number(opt.margin)];
      if (!opt.color)
        opt.color = opt.color || DEF_FONT_COLOR;
      if (typeof opt.border === "string") {
        console.warn("addTable `border` option must be an object. Ex: `{border: {type:'none'}}`");
        opt.border = null;
      } else if (Array.isArray(opt.border)) {
        [0, 1, 2, 3].forEach(function(idx) {
          opt.border[idx] = opt.border[idx] ? { type: opt.border[idx].type || DEF_CELL_BORDER.type, color: opt.border[idx].color || DEF_CELL_BORDER.color, pt: opt.border[idx].pt || DEF_CELL_BORDER.pt } : { type: "none" };
        });
      }
      opt.autoPage = typeof opt.autoPage === "boolean" ? opt.autoPage : false;
      opt.autoPageRepeatHeader = typeof opt.autoPageRepeatHeader === "boolean" ? opt.autoPageRepeatHeader : false;
      opt.autoPageHeaderRows = typeof opt.autoPageHeaderRows !== "undefined" && !isNaN(Number(opt.autoPageHeaderRows)) ? Number(opt.autoPageHeaderRows) : 1;
      opt.autoPageLineWeight = typeof opt.autoPageLineWeight !== "undefined" && !isNaN(Number(opt.autoPageLineWeight)) ? Number(opt.autoPageLineWeight) : 0;
      if (opt.autoPageLineWeight) {
        if (opt.autoPageLineWeight > 1)
          opt.autoPageLineWeight = 1;
        else if (opt.autoPageLineWeight < -1)
          opt.autoPageLineWeight = -1;
      }
      var arrTableMargin = DEF_SLIDE_MARGIN_IN;
      if (slideLayout && typeof slideLayout._margin !== "undefined") {
        if (Array.isArray(slideLayout._margin))
          arrTableMargin = slideLayout._margin;
        else if (!isNaN(Number(slideLayout._margin))) {
          arrTableMargin = [Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin)];
        }
      }
      if (opt.colW) {
        var firstRowColCnt = arrRows[0].reduce(function(totalLen, c) {
          var _a;
          if (((_a = c === null || c === void 0 ? void 0 : c.options) === null || _a === void 0 ? void 0 : _a.colspan) && typeof c.options.colspan === "number") {
            totalLen += c.options.colspan;
          } else {
            totalLen += 1;
          }
          return totalLen;
        }, 0);
        if (typeof opt.colW === "string" || typeof opt.colW === "number") {
          opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
          opt.colW = null;
        } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length === 1 && firstRowColCnt > 1) {
          opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
          opt.colW = null;
        } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length !== firstRowColCnt) {
          console.warn("addTable: mismatch: (colW.length != data.length) Therefore, defaulting to evenly distributed col widths.");
          opt.colW = null;
        }
      } else if (opt.w) {
        opt.w = getSmartParseNumber(opt.w, "X", presLayout);
      } else {
        opt.w = Math.floor(presLayout._sizeW / EMU - arrTableMargin[1] - arrTableMargin[3]);
      }
      if (opt.x && opt.x < 20)
        opt.x = inch2Emu(opt.x);
      if (opt.y && opt.y < 20)
        opt.y = inch2Emu(opt.y);
      if (opt.w && opt.w < 20)
        opt.w = inch2Emu(opt.w);
      if (opt.h && opt.h < 20)
        opt.h = inch2Emu(opt.h);
      arrRows.forEach(function(row) {
        row.forEach(function(cell, idy) {
          if (typeof cell === "number" || typeof cell === "string") {
            row[idy] = { _type: SLIDE_OBJECT_TYPES.tablecell, text: String(row[idy]), options: opt };
          } else if (typeof cell === "object") {
            if (typeof cell.text === "number")
              row[idy].text = row[idy].text.toString();
            else if (typeof cell.text === "undefined" || cell.text === null)
              row[idy].text = "";
            row[idy].options = cell.options || {};
            row[idy]._type = SLIDE_OBJECT_TYPES.tablecell;
          }
        });
      });
      var newAutoPagedSlides = [];
      if (opt && !opt.autoPage) {
        createHyperlinkRels(target, arrRows);
        target._slideObjects.push({
          _type: SLIDE_OBJECT_TYPES.table,
          arrTabRows: arrRows,
          options: Object.assign({}, opt)
        });
      } else {
        if (opt.autoPageRepeatHeader)
          opt._arrObjTabHeadRows = arrRows.filter(function(_row, idx) {
            return idx < opt.autoPageHeaderRows;
          });
        getSlidesForTableRows(arrRows, opt, presLayout, slideLayout).forEach(function(slide, idx) {
          if (!getSlide(target._slideNum + idx))
            slides.push(addSlide({ masterName: (slideLayout === null || slideLayout === void 0 ? void 0 : slideLayout._name) || null }));
          if (idx > 0)
            opt.y = inch2Emu(opt.autoPageSlideStartY || opt.newSlideStartY || arrTableMargin[0]);
          {
            var newSlide = getSlide(target._slideNum + idx);
            opt.autoPage = false;
            createHyperlinkRels(newSlide, slide.rows);
            newSlide.addTable(slide.rows, Object.assign({}, opt));
            if (idx > 0)
              newAutoPagedSlides.push(newSlide);
          }
        });
      }
      return newAutoPagedSlides;
    }
    function addTextDefinition(target, text, opts, isPlaceholder) {
      var newObject = {
        _type: isPlaceholder ? SLIDE_OBJECT_TYPES.placeholder : SLIDE_OBJECT_TYPES.text,
        shape: (opts === null || opts === void 0 ? void 0 : opts.shape) || SHAPE_TYPE.RECTANGLE,
        text: !text || text.length === 0 ? [{ text: "", options: null }] : text,
        options: opts || {}
      };
      function cleanOpts(itemOpts) {
        {
          if (!itemOpts.placeholder) {
            itemOpts.color = itemOpts.color || newObject.options.color || target.color || DEF_FONT_COLOR;
          }
          if (itemOpts.placeholder || isPlaceholder) {
            itemOpts.bullet = itemOpts.bullet || false;
          }
          if (itemOpts.placeholder && target._slideLayout && target._slideLayout._slideObjects) {
            var placeHold = target._slideLayout._slideObjects.filter(function(item) {
              return item._type === "placeholder" && item.options && item.options.placeholder && item.options.placeholder === itemOpts.placeholder;
            })[0];
            if (placeHold === null || placeHold === void 0 ? void 0 : placeHold.options)
              itemOpts = __assign(__assign({}, itemOpts), placeHold.options);
          }
          itemOpts.objectName = itemOpts.objectName ? encodeXmlEntities(itemOpts.objectName) : "Text ".concat(target._slideObjects.filter(function(obj) {
            return obj._type === SLIDE_OBJECT_TYPES.text;
          }).length);
          if (itemOpts.shape === SHAPE_TYPE.LINE) {
            var newLineOpts = {
              type: itemOpts.line.type || "solid",
              color: itemOpts.line.color || DEF_SHAPE_LINE_COLOR,
              transparency: itemOpts.line.transparency || 0,
              width: itemOpts.line.width || 1,
              dashType: itemOpts.line.dashType || "solid",
              beginArrowType: itemOpts.line.beginArrowType || null,
              endArrowType: itemOpts.line.endArrowType || null
            };
            if (typeof itemOpts.line === "object")
              itemOpts.line = newLineOpts;
            if (typeof itemOpts.line === "string") {
              var tmpOpts = newLineOpts;
              if (typeof itemOpts.line === "string")
                tmpOpts.color = itemOpts.line;
              itemOpts.line = tmpOpts;
            }
            if (typeof itemOpts.lineSize === "number")
              itemOpts.line.width = itemOpts.lineSize;
            if (typeof itemOpts.lineDash === "string")
              itemOpts.line.dashType = itemOpts.lineDash;
            if (typeof itemOpts.lineHead === "string")
              itemOpts.line.beginArrowType = itemOpts.lineHead;
            if (typeof itemOpts.lineTail === "string")
              itemOpts.line.endArrowType = itemOpts.lineTail;
          }
          itemOpts.line = itemOpts.line || {};
          itemOpts.lineSpacing = itemOpts.lineSpacing && !isNaN(itemOpts.lineSpacing) ? itemOpts.lineSpacing : null;
          itemOpts.lineSpacingMultiple = itemOpts.lineSpacingMultiple && !isNaN(itemOpts.lineSpacingMultiple) ? itemOpts.lineSpacingMultiple : null;
          itemOpts._bodyProp = itemOpts._bodyProp || {};
          itemOpts._bodyProp.autoFit = itemOpts.autoFit || false;
          itemOpts._bodyProp.anchor = !itemOpts.placeholder ? TEXT_VALIGN.ctr : null;
          itemOpts._bodyProp.vert = itemOpts.vert || null;
          itemOpts._bodyProp.wrap = typeof itemOpts.wrap === "boolean" ? itemOpts.wrap : true;
          if (itemOpts.inset && !isNaN(Number(itemOpts.inset)) || itemOpts.inset === 0) {
            itemOpts._bodyProp.lIns = inch2Emu(itemOpts.inset);
            itemOpts._bodyProp.rIns = inch2Emu(itemOpts.inset);
            itemOpts._bodyProp.tIns = inch2Emu(itemOpts.inset);
            itemOpts._bodyProp.bIns = inch2Emu(itemOpts.inset);
          }
          if (typeof itemOpts.underline === "boolean" && itemOpts.underline === true)
            itemOpts.underline = { style: "sng" };
        }
        {
          if ((itemOpts.align || "").toLowerCase().indexOf("c") === 0)
            itemOpts._bodyProp.align = TEXT_HALIGN.center;
          else if ((itemOpts.align || "").toLowerCase().indexOf("l") === 0)
            itemOpts._bodyProp.align = TEXT_HALIGN.left;
          else if ((itemOpts.align || "").toLowerCase().indexOf("r") === 0)
            itemOpts._bodyProp.align = TEXT_HALIGN.right;
          else if ((itemOpts.align || "").toLowerCase().indexOf("j") === 0)
            itemOpts._bodyProp.align = TEXT_HALIGN.justify;
          if ((itemOpts.valign || "").toLowerCase().indexOf("b") === 0)
            itemOpts._bodyProp.anchor = TEXT_VALIGN.b;
          else if ((itemOpts.valign || "").toLowerCase().indexOf("m") === 0)
            itemOpts._bodyProp.anchor = TEXT_VALIGN.ctr;
          else if ((itemOpts.valign || "").toLowerCase().indexOf("t") === 0)
            itemOpts._bodyProp.anchor = TEXT_VALIGN.t;
        }
        correctShadowOptions(itemOpts.shadow);
        return itemOpts;
      }
      newObject.options = cleanOpts(newObject.options);
      newObject.text.forEach(function(item) {
        return item.options = cleanOpts(item.options || {});
      });
      createHyperlinkRels(target, newObject.text || "");
      target._slideObjects.push(newObject);
    }
    function addPlaceholdersToSlideLayouts(slide) {
      (slide._slideLayout._slideObjects || []).forEach(function(slideLayoutObj) {
        if (slideLayoutObj._type === SLIDE_OBJECT_TYPES.placeholder) {
          if (slide._slideObjects.filter(function(slideObj) {
            return slideObj.options && slideObj.options.placeholder === slideLayoutObj.options.placeholder;
          }).length === 0) {
            addTextDefinition(slide, [{ text: "" }], slideLayoutObj.options, false);
          }
        }
      });
    }
    function addBackgroundDefinition(props, target) {
      var _a;
      if (target.bkgd) {
        if (!target.background)
          target.background = {};
        if (typeof target.bkgd === "string")
          target.background.color = target.bkgd;
        else {
          if (target.bkgd.data)
            target.background.data = target.bkgd.data;
          if (target.bkgd.path)
            target.background.path = target.bkgd.path;
          if (target.bkgd.src)
            target.background.path = target.bkgd.src;
        }
      }
      if ((_a = target.background) === null || _a === void 0 ? void 0 : _a.fill)
        target.background.color = target.background.fill;
      if (props && (props.path || props.data)) {
        props.path = props.path || "preencoded.png";
        var strImgExtn = (props.path.split(".").pop() || "png").split("?")[0];
        if (strImgExtn === "jpg")
          strImgExtn = "jpeg";
        target._relsMedia = target._relsMedia || [];
        var intRels = target._relsMedia.length + 1;
        target._relsMedia.push({
          path: props.path,
          type: SLIDE_OBJECT_TYPES.image,
          extn: strImgExtn,
          data: props.data || null,
          rId: intRels,
          Target: "../media/".concat((target._name || "").replace(/\s+/gi, "-"), "-image-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn)
        });
        target._bkgdImgRid = intRels;
      }
    }
    function createHyperlinkRels(target, text) {
      var textObjs = [];
      if (typeof text === "string" || typeof text === "number")
        return;
      else if (Array.isArray(text))
        textObjs = text;
      else if (typeof text === "object")
        textObjs = [text];
      textObjs.forEach(function(text2) {
        if (Array.isArray(text2)) {
          createHyperlinkRels(target, text2);
        } else if (Array.isArray(text2.text)) {
          createHyperlinkRels(target, text2.text);
        } else if (text2 && typeof text2 === "object" && text2.options && text2.options.hyperlink && !text2.options.hyperlink._rId) {
          if (typeof text2.options.hyperlink !== "object")
            console.log("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink: {url:'https://github.com'}` ");
          else if (!text2.options.hyperlink.url && !text2.options.hyperlink.slide)
            console.log("ERROR: 'hyperlink requires either: `url` or `slide`'");
          else {
            var relId = getNewRelId(target);
            target._rels.push({
              type: SLIDE_OBJECT_TYPES.hyperlink,
              data: text2.options.hyperlink.slide ? "slide" : "dummy",
              rId: relId,
              Target: encodeXmlEntities(text2.options.hyperlink.url) || text2.options.hyperlink.slide.toString()
            });
            text2.options.hyperlink._rId = relId;
          }
        }
      });
    }
    var Slide = (
      /** @class */
      function() {
        function Slide2(params) {
          var _a;
          this.addSlide = params.addSlide;
          this.getSlide = params.getSlide;
          this._name = "Slide ".concat(params.slideNumber);
          this._presLayout = params.presLayout;
          this._rId = params.slideRId;
          this._rels = [];
          this._relsChart = [];
          this._relsMedia = [];
          this._setSlideNum = params.setSlideNum;
          this._slideId = params.slideId;
          this._slideLayout = params.slideLayout || null;
          this._slideNum = params.slideNumber;
          this._slideObjects = [];
          this._slideNumberProps = ((_a = this._slideLayout) === null || _a === void 0 ? void 0 : _a._slideNumberProps) ? this._slideLayout._slideNumberProps : null;
        }
        Object.defineProperty(Slide2.prototype, "bkgd", {
          get: function() {
            return this._bkgd;
          },
          set: function(value) {
            this._bkgd = value;
            if (!this._background || !this._background.color) {
              if (!this._background)
                this._background = {};
              if (typeof value === "string")
                this._background.color = value;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Slide2.prototype, "background", {
          get: function() {
            return this._background;
          },
          set: function(props) {
            this._background = props;
            if (props)
              addBackgroundDefinition(props, this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Slide2.prototype, "color", {
          get: function() {
            return this._color;
          },
          set: function(value) {
            this._color = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Slide2.prototype, "hidden", {
          get: function() {
            return this._hidden;
          },
          set: function(value) {
            this._hidden = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Slide2.prototype, "slideNumber", {
          get: function() {
            return this._slideNumberProps;
          },
          /**
           * @type {SlideNumberProps}
           */
          set: function(value) {
            this._slideNumberProps = value;
            this._setSlideNum(value);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Slide2.prototype, "newAutoPagedSlides", {
          get: function() {
            return this._newAutoPagedSlides;
          },
          enumerable: false,
          configurable: true
        });
        Slide2.prototype.addChart = function(type, data, options) {
          var optionsWithType = options || {};
          optionsWithType._type = type;
          addChartDefinition(this, type, data, options);
          return this;
        };
        Slide2.prototype.addImage = function(options) {
          addImageDefinition(this, options);
          return this;
        };
        Slide2.prototype.addMedia = function(options) {
          addMediaDefinition(this, options);
          return this;
        };
        Slide2.prototype.addNotes = function(notes) {
          addNotesDefinition(this, notes);
          return this;
        };
        Slide2.prototype.addShape = function(shapeName, options) {
          addShapeDefinition(this, shapeName, options);
          return this;
        };
        Slide2.prototype.addTable = function(tableRows, options) {
          this._newAutoPagedSlides = addTableDefinition(this, tableRows, options, this._slideLayout, this._presLayout, this.addSlide, this.getSlide);
          return this;
        };
        Slide2.prototype.addText = function(text, options) {
          var textParam = typeof text === "string" || typeof text === "number" ? [{ text, options }] : text;
          addTextDefinition(this, textParam, options, false);
          return this;
        };
        return Slide2;
      }()
    );
    function createExcelWorksheet(chartObject, zip) {
      return __awaiter(this, void 0, void 0, function() {
        var data;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              data = chartObject.data;
              return [4, new Promise(function(resolve, reject) {
                var _a2, _b;
                var zipExcel = new JSZip__default["default"]();
                var intBubbleCols = (data.length - 1) * 2 + 1;
                var IS_MULTI_CAT_AXES = ((_b = (_a2 = data[0]) === null || _a2 === void 0 ? void 0 : _a2.labels) === null || _b === void 0 ? void 0 : _b.length) > 1;
                zipExcel.folder("_rels");
                zipExcel.folder("docProps");
                zipExcel.folder("xl/_rels");
                zipExcel.folder("xl/tables");
                zipExcel.folder("xl/theme");
                zipExcel.folder("xl/worksheets");
                zipExcel.folder("xl/worksheets/_rels");
                {
                  zipExcel.file("[Content_Types].xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>  <Default Extension="xml" ContentType="application/xml"/>  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>  <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>  <Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>\n');
                  zipExcel.file("_rels/.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>\n');
                  zipExcel.file("docProps/app.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Macintosh Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>\n');
                  zipExcel.file("docProps/core.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>PptxGenJS</dc:creator><cp:lastModifiedBy>PptxGenJS</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">' + (/* @__PURE__ */ new Date()).toISOString() + '</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">' + (/* @__PURE__ */ new Date()).toISOString() + "</dcterms:modified></cp:coreProperties>");
                  zipExcel.file("xl/_rels/workbook.xml.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>');
                  zipExcel.file("xl/styles.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="1"><numFmt numFmtId="0" formatCode="General"/></numFmts><fonts count="4"><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="10"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="18"/><color indexed="8"/><name val="Arial"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><dxfs count="0"/><tableStyles count="0"/><colors><indexedColors><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ffff0000"/><rgbColor rgb="ff00ff00"/><rgbColor rgb="ff0000ff"/><rgbColor rgb="ffffff00"/><rgbColor rgb="ffff00ff"/><rgbColor rgb="ff00ffff"/><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ff878787"/><rgbColor rgb="fff9f9f9"/></indexedColors></colors></styleSheet>\n');
                  zipExcel.file("xl/theme/theme1.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic Light"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="DengXian Light"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="DengXian"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>');
                  zipExcel.file("xl/workbook.xml", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="7" lowestEdited="6" rupBuild="10507"/><workbookPr/><bookViews><workbookView xWindow="0" yWindow="500" windowWidth="20960" windowHeight="15960"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="0" concurrentCalc="0"/></workbook>\n');
                  zipExcel.file("xl/worksheets/_rels/sheet1.xml.rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>\n');
                }
                {
                  var strSharedStrings_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                    strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(intBubbleCols, '" uniqueCount="').concat(intBubbleCols, '">');
                  } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                    strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(data.length, '" uniqueCount="').concat(data.length, '">');
                  } else if (IS_MULTI_CAT_AXES) {
                    var totCount_1 = data.length;
                    data[0].labels.forEach(function(arrLabel) {
                      return totCount_1 += arrLabel.filter(function(label) {
                        return label && label !== "";
                      }).length;
                    });
                    strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(totCount_1, '" uniqueCount="').concat(totCount_1, '">');
                    strSharedStrings_1 += "<si><t/></si>";
                  } else {
                    var totCount = data.length + data[0].labels.length * data[0].labels[0].length + data[0].labels.length;
                    var unqCount = data.length + data[0].labels.length * data[0].labels[0].length + 1;
                    strSharedStrings_1 += '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="'.concat(totCount, '" uniqueCount="').concat(unqCount, '">');
                    strSharedStrings_1 += '<si><t xml:space="preserve"></t></si>';
                  }
                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                    data.forEach(function(objData, idx2) {
                      if (idx2 === 0)
                        strSharedStrings_1 += "<si><t>X-Axis</t></si>";
                      else {
                        strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(objData.name || "Y-Axis".concat(idx2)), "</t></si>");
                        strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities("Size".concat(idx2)), "</t></si>");
                      }
                    });
                  } else {
                    data.forEach(function(objData) {
                      strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities((objData.name || " ").replace("X-Axis", "X-Values")), "</t></si>");
                    });
                  }
                  if (chartObject.opts._type !== CHART_TYPE.BUBBLE && chartObject.opts._type !== CHART_TYPE.BUBBLE3D && chartObject.opts._type !== CHART_TYPE.SCATTER) {
                    data[0].labels.slice().reverse().forEach(function(labelsGroup) {
                      labelsGroup.filter(function(label) {
                        return label && label !== "";
                      }).forEach(function(label) {
                        strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(label), "</t></si>");
                      });
                    });
                  }
                  strSharedStrings_1 += "</sst>\n";
                  zipExcel.file("xl/sharedStrings.xml", strSharedStrings_1);
                }
                {
                  var strTableXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                    strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(intBubbleCols)).concat(intBubbleCols, '" totalsRowShown="0">');
                    strTableXml_1 += '<tableColumns count="'.concat(intBubbleCols, '">');
                    var idxColLtr_1 = 1;
                    data.forEach(function(obj, idx2) {
                      if (idx2 === 0) {
                        strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="X-Values"/>');
                      } else {
                        strTableXml_1 += '<tableColumn id="'.concat(idx2 + idxColLtr_1, '" name="').concat(obj.name, '"/>');
                        idxColLtr_1++;
                        strTableXml_1 += '<tableColumn id="'.concat(idx2 + idxColLtr_1, '" name="Size').concat(idx2, '"/>');
                      }
                    });
                  } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                    strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(data.length)).concat(data[0].values.length + 1, '" totalsRowShown="0">');
                    strTableXml_1 += '<tableColumns count="'.concat(data.length, '">');
                    data.forEach(function(_obj, idx2) {
                      strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="').concat(idx2 === 0 ? "X-Values" : "Y-Value ").concat(idx2, '"/>');
                    });
                  } else {
                    strTableXml_1 += '<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:'.concat(getExcelColName(data.length + data[0].labels.length)).concat(data[0].labels[0].length + 1, `'" totalsRowShown="0">`);
                    strTableXml_1 += '<tableColumns count="'.concat(data.length + data[0].labels.length, '">');
                    data[0].labels.forEach(function(_labelsGroup, idx2) {
                      strTableXml_1 += '<tableColumn id="'.concat(idx2 + 1, '" name="Column').concat(idx2 + 1, '"/>');
                    });
                    data.forEach(function(obj, idx2) {
                      strTableXml_1 += '<tableColumn id="'.concat(idx2 + data[0].labels.length + 1, '" name="').concat(encodeXmlEntities(obj.name), '"/>');
                    });
                  }
                  strTableXml_1 += "</tableColumns>";
                  strTableXml_1 += '<tableStyleInfo showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>';
                  strTableXml_1 += "</table>";
                  zipExcel.file("xl/tables/table1.xml", strTableXml_1);
                }
                {
                  var strSheetXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                  strSheetXml_1 += '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                    strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(intBubbleCols)).concat(data[0].values.length + 1, '"/>');
                  } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                    strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(data.length)).concat(data[0].values.length + 1, '"/>');
                  } else {
                    strSheetXml_1 += '<dimension ref="A1:'.concat(getExcelColName(data.length + 1)).concat(data[0].values.length + 1, '"/>');
                  }
                  strSheetXml_1 += '<sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection activeCell="B1" sqref="B1"/></sheetView></sheetViews>';
                  strSheetXml_1 += '<sheetFormatPr baseColWidth="10" defaultRowHeight="16"/>';
                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                    strSheetXml_1 += "<sheetData>";
                    strSheetXml_1 += '<row r="1" spans="1:'.concat(intBubbleCols, '">');
                    strSheetXml_1 += '<c r="A1" t="s"><v>0</v></c>';
                    for (var idx = 1; idx < intBubbleCols; idx++) {
                      strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>').concat(idx, "</v></c>");
                    }
                    strSheetXml_1 += "</row>";
                    data[0].values.forEach(function(val, idx2) {
                      strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(intBubbleCols, '">');
                      strSheetXml_1 += '<c r="A'.concat(idx2 + 2, '"><v>').concat(val, "</v></c>");
                      var idxColLtr = 2;
                      for (var idy = 1; idy < data.length; idy++) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idxColLtr)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || "", "</v></c>");
                        idxColLtr++;
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idxColLtr)).concat(idx2 + 2, '"><v>').concat(data[idy].sizes[idx2] || "", "</v></c>");
                        idxColLtr++;
                      }
                      strSheetXml_1 += "</row>";
                    });
                  } else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                    strSheetXml_1 += "<sheetData>";
                    strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length, '">');
                    for (var idx = 0; idx < data.length; idx++) {
                      strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>').concat(idx, "</v></c>");
                    }
                    strSheetXml_1 += "</row>";
                    data[0].values.forEach(function(val, idx2) {
                      strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(data.length, '">');
                      strSheetXml_1 += '<c r="A'.concat(idx2 + 2, '"><v>').concat(val, "</v></c>");
                      for (var idy = 1; idy < data.length; idy++) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || data[idy].values[idx2] === 0 ? data[idy].values[idx2] : "", "</v></c>");
                      }
                      strSheetXml_1 += "</row>";
                    });
                  } else {
                    strSheetXml_1 += "<sheetData>";
                    if (!IS_MULTI_CAT_AXES) {
                      strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length + data[0].labels.length, '">');
                      data[0].labels.forEach(function(_labelsGroup, idx2) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idx2 + 1), '1" t="s"><v>0</v></c>');
                      });
                      for (var idx = 0; idx < data.length; idx++) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1 + data[0].labels.length), '1" t="s"><v>').concat(idx + 1, "</v></c>");
                      }
                      strSheetXml_1 += "</row>";
                      data[0].labels[0].forEach(function(_cat, idx2) {
                        strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(data.length + data[0].labels.length, '">');
                        for (var idx22 = data[0].labels.length - 1; idx22 >= 0; idx22--) {
                          strSheetXml_1 += '<c r="'.concat(getExcelColName(data[0].labels.length - idx22)).concat(idx2 + 2, '" t="s">');
                          strSheetXml_1 += "<v>".concat(data.length + idx2 + 1, "</v>");
                          strSheetXml_1 += "</c>";
                        }
                        for (var idy = 0; idy < data.length; idy++) {
                          strSheetXml_1 += '<c r="'.concat(getExcelColName(data[0].labels.length + idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || "", "</v></c>");
                        }
                        strSheetXml_1 += "</row>";
                      });
                    } else {
                      strSheetXml_1 += '<row r="1" spans="1:'.concat(data.length + data[0].labels.length, '">');
                      for (var idx = 0; idx < data[0].labels.length; idx++) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + 1), '1" t="s"><v>0</v></c>');
                      }
                      for (var idx = data[0].labels.length - 1; idx < data.length + data[0].labels.length - 1; idx++) {
                        strSheetXml_1 += '<c r="'.concat(getExcelColName(idx + data[0].labels.length), '1" t="s"><v>').concat(idx, "</v></c>");
                      }
                      strSheetXml_1 += "</row>";
                      var TOT_SER = data.length;
                      var TOT_CAT = data[0].labels[0].length;
                      var TOT_LVL = data[0].labels.length;
                      var _loop_1 = function(idx2) {
                        strSheetXml_1 += '<row r="'.concat(idx2 + 2, '" spans="1:').concat(TOT_SER + TOT_LVL, '">');
                        var totLabels = TOT_SER;
                        var revLabelGroups = data[0].labels.slice().reverse();
                        revLabelGroups.forEach(function(labelsGroup, idy2) {
                          var colLabel = labelsGroup[idx2];
                          if (colLabel) {
                            var totGrpLbls = idy2 === 0 ? 1 : revLabelGroups[idy2 - 1].filter(function(label) {
                              return label && label !== "";
                            }).length;
                            totLabels += totGrpLbls;
                            strSheetXml_1 += '<c r="'.concat(getExcelColName(idx2 + 1 + idy2)).concat(idx2 + 2, '" t="s"><v>').concat(totLabels, "</v></c>");
                          }
                        });
                        for (var idy = 0; idy < TOT_SER; idy++) {
                          strSheetXml_1 += '<c r="'.concat(getExcelColName(TOT_LVL + idy + 1)).concat(idx2 + 2, '"><v>').concat(data[idy].values[idx2] || 0, "</v></c>");
                        }
                        strSheetXml_1 += "</row>";
                      };
                      for (var idx = 0; idx < TOT_CAT; idx++) {
                        _loop_1(idx);
                      }
                    }
                  }
                  strSheetXml_1 += "</sheetData>";
                  strSheetXml_1 += '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>';
                  strSheetXml_1 += "</worksheet>\n";
                  zipExcel.file("xl/worksheets/sheet1.xml", strSheetXml_1);
                }
                zipExcel.generateAsync({ type: "base64" }).then(function(content) {
                  zip.file("ppt/embeddings/Microsoft_Excel_Worksheet".concat(chartObject.globalId, ".xlsx"), content, { base64: true });
                  zip.file("ppt/charts/_rels/" + chartObject.fileName + ".rels", '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' + '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/package" Target="../embeddings/Microsoft_Excel_Worksheet'.concat(chartObject.globalId, '.xlsx"/>') + "</Relationships>");
                  zip.file("ppt/charts/".concat(chartObject.fileName), makeXmlCharts(chartObject));
                  resolve("");
                }).catch(function(strErr) {
                  reject(strErr);
                });
              })];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    function makeXmlCharts(rel) {
      var _a, _b, _c, _d;
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
      var usesSecondaryValAxis = false;
      {
        strXml += '<c:chartSpace xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">';
        strXml += '<c:date1904 val="0"/>';
        strXml += '<c:roundedCorners val="'.concat(rel.opts.chartArea.roundedCorners ? "1" : "0", '"/>');
        strXml += "<c:chart>";
        if (rel.opts.showTitle) {
          strXml += genXmlTitle({
            title: rel.opts.title || "Chart Title",
            color: rel.opts.titleColor,
            fontFace: rel.opts.titleFontFace,
            fontSize: rel.opts.titleFontSize || DEF_FONT_TITLE_SIZE,
            titleAlign: rel.opts.titleAlign,
            titleBold: rel.opts.titleBold,
            titlePos: rel.opts.titlePos,
            titleRotate: rel.opts.titleRotate
          }, rel.opts.x, rel.opts.y);
          strXml += '<c:autoTitleDeleted val="0"/>';
        } else {
          strXml += '<c:autoTitleDeleted val="1"/>';
        }
        if (rel.opts._type === CHART_TYPE.BAR3D) {
          strXml += '<c:view3D><c:rotX val="'.concat(rel.opts.v3DRotX, '"/><c:rotY val="').concat(rel.opts.v3DRotY, '"/><c:rAngAx val="').concat(!rel.opts.v3DRAngAx ? 0 : 1, '"/><c:perspective val="').concat(rel.opts.v3DPerspective, '"/></c:view3D>');
        }
        strXml += "<c:plotArea>";
        if (rel.opts.layout) {
          strXml += "<c:layout>";
          strXml += " <c:manualLayout>";
          strXml += '  <c:layoutTarget val="inner" />';
          strXml += '  <c:xMode val="edge" />';
          strXml += '  <c:yMode val="edge" />';
          strXml += '  <c:x val="' + (rel.opts.layout.x || 0) + '" />';
          strXml += '  <c:y val="' + (rel.opts.layout.y || 0) + '" />';
          strXml += '  <c:w val="' + (rel.opts.layout.w || 1) + '" />';
          strXml += '  <c:h val="' + (rel.opts.layout.h || 1) + '" />';
          strXml += " </c:manualLayout>";
          strXml += "</c:layout>";
        } else {
          strXml += "<c:layout/>";
        }
      }
      if (Array.isArray(rel.opts._type)) {
        rel.opts._type.forEach(function(type) {
          var options = __assign(__assign({}, rel.opts), type.options);
          var valAxisId = options.secondaryValAxis ? AXIS_ID_VALUE_SECONDARY : AXIS_ID_VALUE_PRIMARY;
          var catAxisId = options.secondaryCatAxis ? AXIS_ID_CATEGORY_SECONDARY : AXIS_ID_CATEGORY_PRIMARY;
          usesSecondaryValAxis = usesSecondaryValAxis || options.secondaryValAxis;
          strXml += makeChartType(type.type, type.data, options, valAxisId, catAxisId);
        });
      } else {
        strXml += makeChartType(rel.opts._type, rel.data, rel.opts, AXIS_ID_VALUE_PRIMARY, AXIS_ID_CATEGORY_PRIMARY);
      }
      if (rel.opts._type !== CHART_TYPE.PIE && rel.opts._type !== CHART_TYPE.DOUGHNUT) {
        if (rel.opts.valAxes && rel.opts.valAxes.length > 1 && !usesSecondaryValAxis) {
          throw new Error("Secondary axis must be used by one of the multiple charts");
        }
        if (rel.opts.catAxes) {
          if (!rel.opts.valAxes || rel.opts.valAxes.length !== rel.opts.catAxes.length) {
            throw new Error("There must be the same number of value and category axes.");
          }
          strXml += makeCatAxis(__assign(__assign({}, rel.opts), rel.opts.catAxes[0]), AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
        } else {
          strXml += makeCatAxis(rel.opts, AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
        }
        if (rel.opts.valAxes) {
          strXml += makeValAxis(__assign(__assign({}, rel.opts), rel.opts.valAxes[0]), AXIS_ID_VALUE_PRIMARY);
          if (rel.opts.valAxes[1]) {
            strXml += makeValAxis(__assign(__assign({}, rel.opts), rel.opts.valAxes[1]), AXIS_ID_VALUE_SECONDARY);
          }
        } else {
          strXml += makeValAxis(rel.opts, AXIS_ID_VALUE_PRIMARY);
          if (rel.opts._type === CHART_TYPE.BAR3D) {
            strXml += makeSerAxis(rel.opts, AXIS_ID_SERIES_PRIMARY, AXIS_ID_VALUE_PRIMARY);
          }
        }
        if (((_a = rel.opts) === null || _a === void 0 ? void 0 : _a.catAxes) && ((_b = rel.opts) === null || _b === void 0 ? void 0 : _b.catAxes[1])) {
          strXml += makeCatAxis(__assign(__assign({}, rel.opts), rel.opts.catAxes[1]), AXIS_ID_CATEGORY_SECONDARY, AXIS_ID_VALUE_SECONDARY);
        }
      }
      {
        if (rel.opts.showDataTable) {
          strXml += "<c:dTable>";
          strXml += '  <c:showHorzBorder val="'.concat(!rel.opts.showDataTableHorzBorder ? 0 : 1, '"/>');
          strXml += '  <c:showVertBorder val="'.concat(!rel.opts.showDataTableVertBorder ? 0 : 1, '"/>');
          strXml += '  <c:showOutline    val="'.concat(!rel.opts.showDataTableOutline ? 0 : 1, '"/>');
          strXml += '  <c:showKeys       val="'.concat(!rel.opts.showDataTableKeys ? 0 : 1, '"/>');
          strXml += "  <c:spPr>";
          strXml += "    <a:noFill/>";
          strXml += '    <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="tx1"><a:lumMod val="15000"/><a:lumOff val="85000"/></a:schemeClr></a:solidFill><a:round/></a:ln>';
          strXml += "    <a:effectLst/>";
          strXml += "  </c:spPr>";
          strXml += "  <c:txPr>";
          strXml += '   <a:bodyPr rot="0" spcFirstLastPara="1" vertOverflow="ellipsis" vert="horz" wrap="square" anchor="ctr" anchorCtr="1"/>';
          strXml += "   <a:lstStyle/>";
          strXml += "   <a:p>";
          strXml += '     <a:pPr rtl="0">';
          strXml += '       <a:defRPr sz="'.concat(Math.round((rel.opts.dataTableFontSize || DEF_FONT_SIZE) * 100), '" b="0" i="0" u="none" strike="noStrike" kern="1200" baseline="0">');
          strXml += '         <a:solidFill><a:schemeClr val="tx1"><a:lumMod val="65000"/><a:lumOff val="35000"/></a:schemeClr></a:solidFill>';
          strXml += '         <a:latin typeface="+mn-lt"/>';
          strXml += '         <a:ea typeface="+mn-ea"/>';
          strXml += '         <a:cs typeface="+mn-cs"/>';
          strXml += "       </a:defRPr>";
          strXml += "     </a:pPr>";
          strXml += '    <a:endParaRPr lang="en-US"/>';
          strXml += "   </a:p>";
          strXml += " </c:txPr>";
          strXml += "</c:dTable>";
        }
        strXml += "  <c:spPr>";
        strXml += ((_c = rel.opts.plotArea.fill) === null || _c === void 0 ? void 0 : _c.color) ? genXmlColorSelection(rel.opts.plotArea.fill) : "<a:noFill/>";
        strXml += rel.opts.plotArea.border ? '<a:ln w="'.concat(valToPts(rel.opts.plotArea.border.pt), '" cap="flat">').concat(genXmlColorSelection(rel.opts.plotArea.border.color), "</a:ln>") : "<a:ln><a:noFill/></a:ln>";
        strXml += "    <a:effectLst/>";
        strXml += "  </c:spPr>";
        strXml += "</c:plotArea>";
        if (rel.opts.showLegend) {
          strXml += "<c:legend>";
          strXml += '<c:legendPos val="' + rel.opts.legendPos + '"/>';
          strXml += '<c:overlay val="0"/>';
          if (rel.opts.legendFontFace || rel.opts.legendFontSize || rel.opts.legendColor) {
            strXml += "<c:txPr>";
            strXml += "  <a:bodyPr/>";
            strXml += "  <a:lstStyle/>";
            strXml += "  <a:p>";
            strXml += "    <a:pPr>";
            strXml += rel.opts.legendFontSize ? '<a:defRPr sz="'.concat(Math.round(Number(rel.opts.legendFontSize) * 100), '">') : "<a:defRPr>";
            if (rel.opts.legendColor)
              strXml += genXmlColorSelection(rel.opts.legendColor);
            if (rel.opts.legendFontFace)
              strXml += '<a:latin typeface="' + rel.opts.legendFontFace + '"/>';
            if (rel.opts.legendFontFace)
              strXml += '<a:cs    typeface="' + rel.opts.legendFontFace + '"/>';
            strXml += "      </a:defRPr>";
            strXml += "    </a:pPr>";
            strXml += '    <a:endParaRPr lang="en-US"/>';
            strXml += "  </a:p>";
            strXml += "</c:txPr>";
          }
          strXml += "</c:legend>";
        }
      }
      strXml += '  <c:plotVisOnly val="1"/>';
      strXml += '  <c:dispBlanksAs val="' + rel.opts.displayBlanksAs + '"/>';
      if (rel.opts._type === CHART_TYPE.SCATTER)
        strXml += '<c:showDLblsOverMax val="1"/>';
      strXml += "</c:chart>";
      strXml += "<c:spPr>";
      strXml += ((_d = rel.opts.chartArea.fill) === null || _d === void 0 ? void 0 : _d.color) ? genXmlColorSelection(rel.opts.chartArea.fill) : "<a:noFill/>";
      strXml += rel.opts.chartArea.border ? '<a:ln w="'.concat(valToPts(rel.opts.chartArea.border.pt), '" cap="flat">').concat(genXmlColorSelection(rel.opts.chartArea.border.color), "</a:ln>") : "<a:ln><a:noFill/></a:ln>";
      strXml += "  <a:effectLst/>";
      strXml += "</c:spPr>";
      strXml += '<c:externalData r:id="rId1"><c:autoUpdate val="0"/></c:externalData>';
      strXml += "</c:chartSpace>";
      return strXml;
    }
    function makeChartType(chartType, data, opts, valAxisId, catAxisId, isMultiTypeChart) {
      var colorIndex = -1;
      var idxColLtr = 1;
      var optsChartData = null;
      var strXml = "";
      switch (chartType) {
        case CHART_TYPE.AREA:
        case CHART_TYPE.BAR:
        case CHART_TYPE.BAR3D:
        case CHART_TYPE.LINE:
        case CHART_TYPE.RADAR:
          strXml += "<c:".concat(chartType, "Chart>");
          if (chartType === CHART_TYPE.AREA && opts.barGrouping === "stacked") {
            strXml += '<c:grouping val="' + opts.barGrouping + '"/>';
          }
          if (chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) {
            strXml += '<c:barDir val="' + opts.barDir + '"/>';
            strXml += '<c:grouping val="' + (opts.barGrouping || "clustered") + '"/>';
          }
          if (chartType === CHART_TYPE.RADAR) {
            strXml += '<c:radarStyle val="' + opts.radarStyle + '"/>';
          }
          strXml += '<c:varyColors val="0"/>';
          data.forEach(function(obj) {
            var _a;
            colorIndex++;
            strXml += "<c:ser>";
            strXml += '  <c:idx val="'.concat(obj._dataIndex, '"/><c:order val="').concat(obj._dataIndex, '"/>');
            strXml += "  <c:tx>";
            strXml += "    <c:strRef>";
            strXml += "      <c:f>Sheet1!$" + getExcelColName(obj._dataIndex + obj.labels.length + 1) + "$1</c:f>";
            strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
            strXml += "    </c:strRef>";
            strXml += "  </c:tx>";
            var seriesColor = opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null;
            strXml += "  <c:spPr>";
            if (seriesColor === "transparent") {
              strXml += "<a:noFill/>";
            } else if (opts.chartColorsOpacity) {
              strXml += "<a:solidFill>" + createColorElement(seriesColor, '<a:alpha val="'.concat(Math.round(opts.chartColorsOpacity * 1e3), '"/>')) + "</a:solidFill>";
            } else {
              strXml += "<a:solidFill>" + createColorElement(seriesColor) + "</a:solidFill>";
            }
            if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
              if (opts.lineSize === 0) {
                strXml += "<a:ln><a:noFill/></a:ln>";
              } else {
                strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(seriesColor), "</a:solidFill>");
                strXml += '<a:prstDash val="' + (opts.lineDash || "solid") + '"/><a:round/></a:ln>';
              }
            } else if (opts.dataBorder) {
              strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            strXml += "  </c:spPr>";
            strXml += '  <c:invertIfNegative val="0"/>';
            if (chartType !== CHART_TYPE.RADAR) {
              strXml += "<c:dLbls>";
              strXml += '<c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
              if (opts.dataLabelBkgrdColors)
                strXml += "<c:spPr><a:solidFill>".concat(createColorElement(seriesColor), "</a:solidFill></c:spPr>");
              strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
              strXml += '<a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
              strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
              strXml += '<a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
              strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
              if (opts.dataLabelPosition)
                strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
              strXml += '<c:showLegendKey val="0"/>';
              strXml += '<c:showVal val="'.concat(opts.showValue ? "1" : "0", '"/>');
              strXml += '<c:showCatName val="0"/><c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>');
              strXml += '<c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
              strXml += "</c:dLbls>";
            }
            if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
              strXml += "<c:marker>";
              strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
              if (opts.lineDataSymbolSize)
                strXml += '<c:size val="'.concat(opts.lineDataSymbolSize, '"/>');
              strXml += "  <c:spPr>";
              strXml += "    <a:solidFill>".concat(createColorElement(opts.chartColors[obj._dataIndex + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : obj._dataIndex]), "</a:solidFill>");
              strXml += '    <a:ln w="'.concat(opts.lineDataSymbolLineSize, '" cap="flat"><a:solidFill>').concat(createColorElement(opts.lineDataSymbolLineColor || seriesColor), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
              strXml += "    <a:effectLst/>";
              strXml += "  </c:spPr>";
              strXml += "</c:marker>";
            }
            if ((chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) && data.length === 1 && (opts.chartColors && opts.chartColors !== BARCHART_COLORS && opts.chartColors.length > 1 || ((_a = opts.invertedColors) === null || _a === void 0 ? void 0 : _a.length))) {
              obj.values.forEach(function(value, index) {
                var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
                strXml += "  <c:dPt>";
                strXml += '    <c:idx val="'.concat(index, '"/>');
                strXml += '      <c:invertIfNegative val="0"/>';
                strXml += '    <c:bubble3D val="0"/>';
                strXml += "    <c:spPr>";
                if (opts.lineSize === 0) {
                  strXml += "<a:ln><a:noFill/></a:ln>";
                } else if (chartType === CHART_TYPE.BAR) {
                  strXml += "<a:solidFill>";
                  strXml += '  <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                  strXml += "</a:solidFill>";
                } else {
                  strXml += "<a:ln>";
                  strXml += "  <a:solidFill>";
                  strXml += '   <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                  strXml += "  </a:solidFill>";
                  strXml += "</a:ln>";
                }
                strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                strXml += "    </c:spPr>";
                strXml += "  </c:dPt>";
              });
            }
            {
              strXml += "<c:cat>";
              if (opts.catLabelFormatCode) {
                strXml += "  <c:numRef>";
                strXml += "    <c:f>Sheet1!$A$2:$A$".concat(obj.labels[0].length + 1, "</c:f>");
                strXml += "    <c:numCache>";
                strXml += "      <c:formatCode>" + (opts.catLabelFormatCode || "General") + "</c:formatCode>";
                strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
                obj.labels[0].forEach(function(label, idx) {
                  return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
                });
                strXml += "    </c:numCache>";
                strXml += "  </c:numRef>";
              } else {
                strXml += "  <c:multiLvlStrRef>";
                strXml += "    <c:f>Sheet1!$A$2:$".concat(getExcelColName(obj.labels.length), "$").concat(obj.labels[0].length + 1, "</c:f>");
                strXml += "    <c:multiLvlStrCache>";
                strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
                obj.labels.forEach(function(labelsGroup) {
                  strXml += "<c:lvl>";
                  labelsGroup.forEach(function(label, idx) {
                    return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
                  });
                  strXml += "</c:lvl>";
                });
                strXml += "    </c:multiLvlStrCache>";
                strXml += "  </c:multiLvlStrRef>";
              }
              strXml += "</c:cat>";
            }
            {
              strXml += "<c:val>";
              strXml += "  <c:numRef>";
              strXml += "<c:f>Sheet1!$".concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$2:$").concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$").concat(obj.labels[0].length + 1, "</c:f>");
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>" + (opts.valLabelFormatCode || opts.dataTableFormatCode || "General") + "</c:formatCode>";
              strXml += '      <c:ptCount val="'.concat(obj.labels[0].length, '"/>');
              obj.values.forEach(function(value, idx) {
                return strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
              });
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
              strXml += "</c:val>";
            }
            if (chartType === CHART_TYPE.LINE)
              strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
            strXml += "</c:ser>";
          });
          {
            strXml += "  <c:dLbls>";
            strXml += '    <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
            strXml += "    <c:txPr>";
            strXml += "      <a:bodyPr/>";
            strXml += "      <a:lstStyle/>";
            strXml += "      <a:p><a:pPr>";
            strXml += '        <a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
            strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
            strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
            strXml += "        </a:defRPr>";
            strXml += "      </a:pPr></a:p>";
            strXml += "    </c:txPr>";
            if (opts.dataLabelPosition)
              strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
            strXml += '    <c:showLegendKey val="0"/>';
            strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
            strXml += '    <c:showCatName val="0"/>';
            strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
            strXml += '    <c:showPercent val="0"/>';
            strXml += '    <c:showBubbleSize val="0"/>';
            strXml += '    <c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
            strXml += "  </c:dLbls>";
          }
          if (chartType === CHART_TYPE.BAR) {
            strXml += '  <c:gapWidth val="'.concat(opts.barGapWidthPct, '"/>');
            strXml += '  <c:overlap val="'.concat((opts.barGrouping || "").includes("tacked") ? 100 : opts.barOverlapPct ? opts.barOverlapPct : 0, '"/>');
          } else if (chartType === CHART_TYPE.BAR3D) {
            strXml += '  <c:gapWidth val="'.concat(opts.barGapWidthPct, '"/>');
            strXml += '  <c:gapDepth val="'.concat(opts.barGapDepthPct, '"/>');
            strXml += '  <c:shape val="' + opts.bar3DShape + '"/>';
          } else if (chartType === CHART_TYPE.LINE) {
            strXml += '  <c:marker val="1"/>';
          }
          strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/><c:axId val="').concat(AXIS_ID_SERIES_PRIMARY, '"/>');
          strXml += "</c:".concat(chartType, "Chart>");
          break;
        case CHART_TYPE.SCATTER:
          strXml += "<c:" + chartType + "Chart>";
          strXml += '<c:scatterStyle val="lineMarker"/>';
          strXml += '<c:varyColors val="0"/>';
          colorIndex = -1;
          data.filter(function(_obj, idx) {
            return idx > 0;
          }).forEach(function(obj, idx) {
            colorIndex++;
            strXml += "<c:ser>";
            strXml += '  <c:idx val="'.concat(idx, '"/>');
            strXml += '  <c:order val="'.concat(idx, '"/>');
            strXml += "  <c:tx>";
            strXml += "    <c:strRef>";
            strXml += "      <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$1</c:f>");
            strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
            strXml += "    </c:strRef>";
            strXml += "  </c:tx>";
            strXml += "  <c:spPr>";
            {
              var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
              if (tmpSerColor === "transparent") {
                strXml += "<a:noFill/>";
              } else if (opts.chartColorsOpacity) {
                strXml += "<a:solidFill>" + createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1e3).toString() + '"/>') + "</a:solidFill>";
              } else {
                strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
              }
              if (opts.lineSize === 0) {
                strXml += "<a:ln><a:noFill/></a:ln>";
              } else {
                strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="').concat(createLineCap(opts.lineCap), '"><a:solidFill>').concat(createColorElement(tmpSerColor), "</a:solidFill>");
                strXml += '<a:prstDash val="'.concat(opts.lineDash || "solid", '"/><a:round/></a:ln>');
              }
              strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            }
            strXml += "  </c:spPr>";
            {
              strXml += "<c:marker>";
              strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
              if (opts.lineDataSymbolSize) {
                strXml += '<c:size val="'.concat(opts.lineDataSymbolSize, '"/>');
              }
              strXml += "<c:spPr>";
              strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
              strXml += '<a:ln w="'.concat(opts.lineDataSymbolLineSize, '" cap="flat"><a:solidFill>').concat(createColorElement(opts.lineDataSymbolLineColor || opts.chartColors[colorIndex % opts.chartColors.length]), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
              strXml += "<a:effectLst/>";
              strXml += "</c:spPr>";
              strXml += "</c:marker>";
            }
            if (opts.showLabel) {
              var chartUuid_1 = getUuid("-xxxx-xxxx-xxxx-xxxxxxxxxxxx");
              if (obj.labels[0] && (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY")) {
                strXml += "<c:dLbls>";
                obj.labels[0].forEach(function(label, idx2) {
                  if (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY") {
                    strXml += "  <c:dLbl>";
                    strXml += '    <c:idx val="'.concat(idx2, '"/>');
                    strXml += "    <c:tx>";
                    strXml += "      <c:rich>";
                    strXml += "            <a:bodyPr>";
                    strXml += "                <a:spAutoFit/>";
                    strXml += "            </a:bodyPr>";
                    strXml += "            <a:lstStyle/>";
                    strXml += "            <a:p>";
                    strXml += "                <a:pPr>";
                    strXml += "                    <a:defRPr/>";
                    strXml += "                </a:pPr>";
                    strXml += "              <a:r>";
                    strXml += '                    <a:rPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                    strXml += "                    <a:t>" + encodeXmlEntities(label) + "</a:t>";
                    strXml += "              </a:r>";
                    if (opts.dataLabelFormatScatter === "customXY" && !/^ *$/.test(label)) {
                      strXml += "              <a:r>";
                      strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                      strXml += "                  <a:t> (</a:t>";
                      strXml += "              </a:r>";
                      strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="XVALUE">';
                      strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                      strXml += "                  <a:pPr>";
                      strXml += "                      <a:defRPr/>";
                      strXml += "                  </a:pPr>";
                      strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "</a:t>";
                      strXml += "              </a:fld>";
                      strXml += "              <a:r>";
                      strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                      strXml += "                  <a:t>, </a:t>";
                      strXml += "              </a:r>";
                      strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="YVALUE">';
                      strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                      strXml += "                  <a:pPr>";
                      strXml += "                      <a:defRPr/>";
                      strXml += "                  </a:pPr>";
                      strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "]</a:t>";
                      strXml += "              </a:fld>";
                      strXml += "              <a:r>";
                      strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                      strXml += "                  <a:t>)</a:t>";
                      strXml += "              </a:r>";
                      strXml += '              <a:endParaRPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                    }
                    strXml += "            </a:p>";
                    strXml += "      </c:rich>";
                    strXml += "    </c:tx>";
                    strXml += "    <c:spPr>";
                    strXml += "        <a:noFill/>";
                    strXml += "        <a:ln>";
                    strXml += "            <a:noFill/>";
                    strXml += "        </a:ln>";
                    strXml += "        <a:effectLst/>";
                    strXml += "    </c:spPr>";
                    if (opts.dataLabelPosition)
                      strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                    strXml += '    <c:showLegendKey val="0"/>';
                    strXml += '    <c:showVal val="0"/>';
                    strXml += '    <c:showCatName val="0"/>';
                    strXml += '    <c:showSerName val="0"/>';
                    strXml += '    <c:showPercent val="0"/>';
                    strXml += '    <c:showBubbleSize val="0"/>';
                    strXml += '       <c:showLeaderLines val="1"/>';
                    strXml += "    <c:extLst>";
                    strXml += '      <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart"/>';
                    strXml += '      <c:ext uri="{C3380CC4-5D6E-409C-BE32-E72D297353CC}" xmlns:c16="http://schemas.microsoft.com/office/drawing/2014/chart">';
                    strXml += '            <c16:uniqueId val="{'.concat("00000000".substring(0, 8 - (idx2 + 1).toString().length).toString()).concat(idx2 + 1).concat(chartUuid_1, '}"/>');
                    strXml += "      </c:ext>";
                    strXml += "        </c:extLst>";
                    strXml += "</c:dLbl>";
                  }
                });
                strXml += "</c:dLbls>";
              }
              if (opts.dataLabelFormatScatter === "XY") {
                strXml += "<c:dLbls>";
                strXml += "    <c:spPr>";
                strXml += "        <a:noFill/>";
                strXml += "        <a:ln>";
                strXml += "            <a:noFill/>";
                strXml += "        </a:ln>";
                strXml += "          <a:effectLst/>";
                strXml += "    </c:spPr>";
                strXml += "    <c:txPr>";
                strXml += "        <a:bodyPr>";
                strXml += "            <a:spAutoFit/>";
                strXml += "        </a:bodyPr>";
                strXml += "        <a:lstStyle/>";
                strXml += "        <a:p>";
                strXml += "            <a:pPr>";
                strXml += "                <a:defRPr/>";
                strXml += "            </a:pPr>";
                strXml += '            <a:endParaRPr lang="en-US"/>';
                strXml += "        </a:p>";
                strXml += "    </c:txPr>";
                if (opts.dataLabelPosition)
                  strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                strXml += '    <c:showLegendKey val="0"/>';
                strXml += ' <c:showVal val="'.concat(opts.showLabel ? "1" : "0", '"/>');
                strXml += ' <c:showCatName val="'.concat(opts.showLabel ? "1" : "0", '"/>');
                strXml += ' <c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/>');
                strXml += '    <c:showPercent val="0"/>';
                strXml += '    <c:showBubbleSize val="0"/>';
                strXml += "    <c:extLst>";
                strXml += '        <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
                strXml += '            <c15:showLeaderLines val="1"/>';
                strXml += "        </c:ext>";
                strXml += "    </c:extLst>";
                strXml += "</c:dLbls>";
              }
            }
            if (data.length === 1 && opts.chartColors !== BARCHART_COLORS) {
              obj.values.forEach(function(value, index) {
                var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
                strXml += "  <c:dPt>";
                strXml += '    <c:idx val="'.concat(index, '"/>');
                strXml += '      <c:invertIfNegative val="0"/>';
                strXml += '    <c:bubble3D val="0"/>';
                strXml += "    <c:spPr>";
                if (opts.lineSize === 0) {
                  strXml += "<a:ln><a:noFill/></a:ln>";
                } else {
                  strXml += "<a:solidFill>";
                  strXml += ' <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                  strXml += "</a:solidFill>";
                }
                strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                strXml += "    </c:spPr>";
                strXml += "  </c:dPt>";
              });
            }
            {
              strXml += "<c:xVal>";
              strXml += "  <c:numRef>";
              strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>General</c:formatCode>";
              strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
              data[0].values.forEach(function(value, idx2) {
                strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
              });
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
              strXml += "</c:xVal>";
              strXml += "<c:yVal>";
              strXml += "  <c:numRef>";
              strXml += "    <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$2:$").concat(getExcelColName(idx + 2), "$").concat(data[0].values.length + 1, "</c:f>");
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>General</c:formatCode>";
              strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
              data[0].values.forEach(function(_value, idx2) {
                strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : "", "</c:v></c:pt>");
              });
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
              strXml += "</c:yVal>";
            }
            strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
            strXml += "</c:ser>";
          });
          {
            strXml += "  <c:dLbls>";
            strXml += '    <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
            strXml += "    <c:txPr>";
            strXml += "      <a:bodyPr/>";
            strXml += "      <a:lstStyle/>";
            strXml += "      <a:p><a:pPr>";
            strXml += '        <a:defRPr b="'.concat(opts.dataLabelFontBold ? "1" : "0", '" i="').concat(opts.dataLabelFontItalic ? "1" : "0", '" strike="noStrike" sz="').concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
            strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
            strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
            strXml += "        </a:defRPr>";
            strXml += "      </a:pPr></a:p>";
            strXml += "    </c:txPr>";
            if (opts.dataLabelPosition)
              strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
            strXml += '    <c:showLegendKey val="0"/>';
            strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
            strXml += '    <c:showCatName val="0"/>';
            strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
            strXml += '    <c:showPercent val="0"/>';
            strXml += '    <c:showBubbleSize val="0"/>';
            strXml += "  </c:dLbls>";
          }
          strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/>');
          strXml += "</c:" + chartType + "Chart>";
          break;
        case CHART_TYPE.BUBBLE:
        case CHART_TYPE.BUBBLE3D:
          strXml += "<c:bubbleChart>";
          strXml += '<c:varyColors val="0"/>';
          colorIndex = -1;
          data.filter(function(_obj, idx) {
            return idx > 0;
          }).forEach(function(obj, idx) {
            colorIndex++;
            strXml += "<c:ser>";
            strXml += '  <c:idx val="'.concat(idx, '"/>');
            strXml += '  <c:order val="'.concat(idx, '"/>');
            strXml += "  <c:tx>";
            strXml += "    <c:strRef>";
            strXml += "      <c:f>Sheet1!$" + getExcelColName(idxColLtr + 1) + "$1</c:f>";
            strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
            strXml += "    </c:strRef>";
            strXml += "  </c:tx>";
            {
              strXml += "<c:spPr>";
              var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
              if (tmpSerColor === "transparent") {
                strXml += "<a:noFill/>";
              } else if (opts.chartColorsOpacity) {
                strXml += "<a:solidFill>".concat(createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1e3).toString() + '"/>'), "</a:solidFill>");
              } else {
                strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
              }
              if (opts.lineSize === 0) {
                strXml += "<a:ln><a:noFill/></a:ln>";
              } else if (opts.dataBorder) {
                strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="flat"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
              } else {
                strXml += '<a:ln w="'.concat(valToPts(opts.lineSize), '" cap="flat"><a:solidFill>').concat(createColorElement(tmpSerColor), "</a:solidFill>");
                strXml += '<a:prstDash val="'.concat(opts.lineDash || "solid", '"/><a:round/></a:ln>');
              }
              strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
              strXml += "</c:spPr>";
            }
            {
              strXml += "<c:xVal>";
              strXml += "  <c:numRef>";
              strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>General</c:formatCode>";
              strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
              data[0].values.forEach(function(value, idx2) {
                strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
              });
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
              strXml += "</c:xVal>";
              strXml += "<c:yVal>";
              strXml += "  <c:numRef>";
              strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(data[0].values.length + 1, "</c:f>");
              idxColLtr++;
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>General</c:formatCode>";
              strXml += '      <c:ptCount val="'.concat(data[0].values.length, '"/>');
              data[0].values.forEach(function(_value, idx2) {
                strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : "", "</c:v></c:pt>");
              });
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
              strXml += "</c:yVal>";
            }
            strXml += "  <c:bubbleSize>";
            strXml += "    <c:numRef>";
            strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(obj.sizes.length + 1, "</c:f>");
            idxColLtr++;
            strXml += "      <c:numCache>";
            strXml += "        <c:formatCode>General</c:formatCode>";
            strXml += '           <c:ptCount val="'.concat(obj.sizes.length, '"/>');
            obj.sizes.forEach(function(value, idx2) {
              strXml += '<c:pt idx="'.concat(idx2, '"><c:v>').concat(value || "", "</c:v></c:pt>");
            });
            strXml += "      </c:numCache>";
            strXml += "    </c:numRef>";
            strXml += "  </c:bubbleSize>";
            strXml += '  <c:bubble3D val="' + (chartType === CHART_TYPE.BUBBLE3D ? "1" : "0") + '"/>';
            strXml += "</c:ser>";
          });
          {
            strXml += "<c:dLbls>";
            strXml += '<c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
            strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
            strXml += '<a:defRPr b="'.concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" strike="noStrike" sz="').concat(Math.round(Math.round(opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" u="none">');
            strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
            strXml += '<a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
            strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
            if (opts.dataLabelPosition)
              strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
            strXml += '<c:showLegendKey val="0"/>';
            strXml += '<c:showVal val="'.concat(opts.showValue ? "1" : "0", '"/>');
            strXml += '<c:showCatName val="0"/><c:showSerName val="'.concat(opts.showSerName ? "1" : "0", '"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>');
            strXml += "<c:extLst>";
            strXml += '  <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
            strXml += '    <c15:showLeaderLines val="' + (opts.showLeaderLines ? "1" : "0") + '"/>';
            strXml += "  </c:ext>";
            strXml += "</c:extLst>";
            strXml += "</c:dLbls>";
          }
          strXml += '<c:axId val="'.concat(catAxisId, '"/><c:axId val="').concat(valAxisId, '"/>');
          strXml += "</c:bubbleChart>";
          break;
        case CHART_TYPE.DOUGHNUT:
        case CHART_TYPE.PIE:
          optsChartData = data[0];
          strXml += "<c:" + chartType + "Chart>";
          strXml += '  <c:varyColors val="1"/>';
          strXml += "<c:ser>";
          strXml += '  <c:idx val="0"/>';
          strXml += '  <c:order val="0"/>';
          strXml += "  <c:tx>";
          strXml += "    <c:strRef>";
          strXml += "      <c:f>Sheet1!$B$1</c:f>";
          strXml += "      <c:strCache>";
          strXml += '        <c:ptCount val="1"/>';
          strXml += '        <c:pt idx="0"><c:v>' + encodeXmlEntities(optsChartData.name) + "</c:v></c:pt>";
          strXml += "      </c:strCache>";
          strXml += "    </c:strRef>";
          strXml += "  </c:tx>";
          strXml += "  <c:spPr>";
          strXml += '    <a:solidFill><a:schemeClr val="accent1"/></a:solidFill>';
          strXml += '    <a:ln w="9525" cap="flat"><a:solidFill><a:srgbClr val="F9F9F9"/></a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>';
          if (opts.dataNoEffects) {
            strXml += "<a:effectLst/>";
          } else {
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
          }
          strXml += "  </c:spPr>";
          optsChartData.labels[0].forEach(function(_label, idx) {
            strXml += "<c:dPt>";
            strXml += ' <c:idx val="'.concat(idx, '"/>');
            strXml += ' <c:bubble3D val="0"/>';
            strXml += " <c:spPr>";
            strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
            if (opts.dataBorder) {
              strXml += '<a:ln w="'.concat(valToPts(opts.dataBorder.pt), '" cap="flat"><a:solidFill>').concat(createColorElement(opts.dataBorder.color), '</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>');
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            strXml += "  </c:spPr>";
            strXml += "</c:dPt>";
          });
          strXml += "<c:dLbls>";
          optsChartData.labels[0].forEach(function(_label, idx) {
            strXml += "<c:dLbl>";
            strXml += ' <c:idx val="'.concat(idx, '"/>');
            strXml += '  <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
            strXml += "  <c:spPr/><c:txPr>";
            strXml += "   <a:bodyPr/><a:lstStyle/>";
            strXml += "   <a:p><a:pPr>";
            strXml += '   <a:defRPr sz="'.concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.dataLabelFontBold ? 1 : 0, '" i="').concat(opts.dataLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
            strXml += "    <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
            strXml += '    <a:latin typeface="'.concat(opts.dataLabelFontFace || "Arial", '"/>');
            strXml += "   </a:defRPr>";
            strXml += "      </a:pPr></a:p>";
            strXml += "    </c:txPr>";
            if (chartType === CHART_TYPE.PIE && opts.dataLabelPosition)
              strXml += '<c:dLblPos val="'.concat(opts.dataLabelPosition, '"/>');
            strXml += '    <c:showLegendKey val="0"/>';
            strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
            strXml += '    <c:showCatName val="' + (opts.showLabel ? "1" : "0") + '"/>';
            strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
            strXml += '    <c:showPercent val="' + (opts.showPercent ? "1" : "0") + '"/>';
            strXml += '    <c:showBubbleSize val="0"/>';
            strXml += "  </c:dLbl>";
          });
          strXml += ' <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.dataLabelFormatCode) || "General", '" sourceLinked="0"/>');
          strXml += "    <c:txPr>";
          strXml += "      <a:bodyPr/>";
          strXml += "      <a:lstStyle/>";
          strXml += "      <a:p>";
          strXml += "        <a:pPr>";
          strXml += '          <a:defRPr sz="1800" b="'.concat(opts.dataLabelFontBold ? "1" : "0", '" i="').concat(opts.dataLabelFontItalic ? "1" : "0", '" u="none" strike="noStrike">');
          strXml += '            <a:solidFill><a:srgbClr val="000000"/></a:solidFill><a:latin typeface="Arial"/>';
          strXml += "          </a:defRPr>";
          strXml += "        </a:pPr>";
          strXml += "      </a:p>";
          strXml += "    </c:txPr>";
          strXml += chartType === CHART_TYPE.PIE ? '<c:dLblPos val="ctr"/>' : "";
          strXml += '    <c:showLegendKey val="0"/>';
          strXml += '    <c:showVal val="0"/>';
          strXml += '    <c:showCatName val="1"/>';
          strXml += '    <c:showSerName val="0"/>';
          strXml += '    <c:showPercent val="1"/>';
          strXml += '    <c:showBubbleSize val="0"/>';
          strXml += ' <c:showLeaderLines val="'.concat(opts.showLeaderLines ? "1" : "0", '"/>');
          strXml += "</c:dLbls>";
          strXml += "<c:cat>";
          strXml += "  <c:strRef>";
          strXml += "    <c:f>Sheet1!$A$2:$A$".concat(optsChartData.labels[0].length + 1, "</c:f>");
          strXml += "    <c:strCache>";
          strXml += '         <c:ptCount val="'.concat(optsChartData.labels[0].length, '"/>');
          optsChartData.labels[0].forEach(function(label, idx) {
            strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(encodeXmlEntities(label), "</c:v></c:pt>");
          });
          strXml += "    </c:strCache>";
          strXml += "  </c:strRef>";
          strXml += "</c:cat>";
          strXml += "  <c:val>";
          strXml += "    <c:numRef>";
          strXml += "      <c:f>Sheet1!$B$2:$B$".concat(optsChartData.labels[0].length + 1, "</c:f>");
          strXml += "      <c:numCache>";
          strXml += '           <c:ptCount val="'.concat(optsChartData.labels[0].length, '"/>');
          optsChartData.values.forEach(function(value, idx) {
            strXml += '<c:pt idx="'.concat(idx, '"><c:v>').concat(value || value === 0 ? value : "", "</c:v></c:pt>");
          });
          strXml += "      </c:numCache>";
          strXml += "    </c:numRef>";
          strXml += "  </c:val>";
          strXml += "  </c:ser>";
          strXml += '  <c:firstSliceAng val="'.concat(opts.firstSliceAng ? Math.round(opts.firstSliceAng) : 0, '"/>');
          if (chartType === CHART_TYPE.DOUGHNUT)
            strXml += '<c:holeSize val="'.concat(typeof opts.holeSize === "number" ? opts.holeSize : "50", '"/>');
          strXml += "</c:" + chartType + "Chart>";
          break;
        default:
          strXml += "";
          break;
      }
      return strXml;
    }
    function makeCatAxis(opts, axisId, valAxisId) {
      var strXml = "";
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
        strXml += "<c:valAx>";
      } else {
        strXml += "<c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
      }
      strXml += '  <c:axId val="' + axisId + '"/>';
      strXml += "  <c:scaling>";
      strXml += '<c:orientation val="' + (opts.catAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
      if (opts.catAxisMaxVal || opts.catAxisMaxVal === 0)
        strXml += '<c:max val="'.concat(opts.catAxisMaxVal, '"/>');
      if (opts.catAxisMinVal || opts.catAxisMinVal === 0)
        strXml += '<c:min val="'.concat(opts.catAxisMinVal, '"/>');
      strXml += "</c:scaling>";
      strXml += '  <c:delete val="' + (opts.catAxisHidden ? "1" : "0") + '"/>';
      strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
      strXml += opts.catGridLine.style !== "none" ? createGridLineElement(opts.catGridLine) : "";
      if (opts.showCatAxisTitle) {
        strXml += genXmlTitle({
          color: opts.catAxisTitleColor,
          fontFace: opts.catAxisTitleFontFace,
          fontSize: opts.catAxisTitleFontSize,
          titleRotate: opts.catAxisTitleRotate,
          title: opts.catAxisTitle || "Axis Title"
        });
      }
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
        strXml += '  <c:numFmt formatCode="' + (opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General") + '" sourceLinked="1"/>';
      } else {
        strXml += '  <c:numFmt formatCode="' + (encodeXmlEntities(opts.catLabelFormatCode) || "General") + '" sourceLinked="1"/>';
      }
      if (opts._type === CHART_TYPE.SCATTER) {
        strXml += '  <c:majorTickMark val="none"/>';
        strXml += '  <c:minorTickMark val="none"/>';
        strXml += '  <c:tickLblPos val="nextTo"/>';
      } else {
        strXml += '  <c:majorTickMark val="' + (opts.catAxisMajorTickMark || "out") + '"/>';
        strXml += '  <c:minorTickMark val="' + (opts.catAxisMinorTickMark || "none") + '"/>';
        strXml += '  <c:tickLblPos val="' + (opts.catAxisLabelPos || (opts.barDir === "col" ? "low" : "nextTo")) + '"/>';
      }
      strXml += "  <c:spPr>";
      strXml += '    <a:ln w="'.concat(opts.catAxisLineSize ? valToPts(opts.catAxisLineSize) : ONEPT, '" cap="flat">');
      strXml += !opts.catAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.catAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
      strXml += '      <a:prstDash val="' + (opts.catAxisLineStyle || "solid") + '"/>';
      strXml += "      <a:round/>";
      strXml += "    </a:ln>";
      strXml += "  </c:spPr>";
      strXml += "  <c:txPr>";
      if (opts.catAxisLabelRotate) {
        strXml += '<a:bodyPr rot="'.concat(convertRotationDegrees(opts.catAxisLabelRotate), '"/>');
      } else {
        strXml += "<a:bodyPr/>";
      }
      strXml += "    <a:lstStyle/>";
      strXml += "    <a:p>";
      strXml += "    <a:pPr>";
      strXml += '      <a:defRPr sz="'.concat(Math.round((opts.catAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.catAxisLabelFontBold ? 1 : 0, '" i="').concat(opts.catAxisLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
      strXml += "      <a:solidFill>" + createColorElement(opts.catAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
      strXml += '      <a:latin typeface="' + (opts.catAxisLabelFontFace || "Arial") + '"/>';
      strXml += "   </a:defRPr>";
      strXml += "  </a:pPr>";
      strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
      strXml += "  </a:p>";
      strXml += " </c:txPr>";
      strXml += ' <c:crossAx val="' + valAxisId + '"/>';
      strXml += " <c:".concat(typeof opts.valAxisCrossesAt === "number" ? "crossesAt" : "crosses", ' val="').concat(opts.valAxisCrossesAt || "autoZero", '"/>');
      strXml += ' <c:auto val="1"/>';
      strXml += ' <c:lblAlgn val="ctr"/>';
      strXml += ' <c:noMultiLvlLbl val="'.concat(opts.catAxisMultiLevelLabels ? 0 : 1, '"/>');
      if (opts.catAxisLabelFrequency)
        strXml += ' <c:tickLblSkip val="' + opts.catAxisLabelFrequency + '"/>';
      if (opts.catLabelFormatCode || opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
        if (opts.catLabelFormatCode) {
          ["catAxisBaseTimeUnit", "catAxisMajorTimeUnit", "catAxisMinorTimeUnit"].forEach(function(opt) {
            if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opts[opt].toLowerCase()))) {
              console.warn('"'.concat(opt, `" must be one of: 'days','months','years' !`));
              opts[opt] = null;
            }
          });
          if (opts.catAxisBaseTimeUnit)
            strXml += '<c:baseTimeUnit val="' + opts.catAxisBaseTimeUnit.toLowerCase() + '"/>';
          if (opts.catAxisMajorTimeUnit)
            strXml += '<c:majorTimeUnit val="' + opts.catAxisMajorTimeUnit.toLowerCase() + '"/>';
          if (opts.catAxisMinorTimeUnit)
            strXml += '<c:minorTimeUnit val="' + opts.catAxisMinorTimeUnit.toLowerCase() + '"/>';
        }
        if (opts.catAxisMajorUnit)
          strXml += '<c:majorUnit val="'.concat(opts.catAxisMajorUnit, '"/>');
        if (opts.catAxisMinorUnit)
          strXml += '<c:minorUnit val="'.concat(opts.catAxisMinorUnit, '"/>');
      }
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
        strXml += "</c:valAx>";
      } else {
        strXml += "</c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
      }
      return strXml;
    }
    function makeValAxis(opts, valAxisId) {
      var axisPos = valAxisId === AXIS_ID_VALUE_PRIMARY ? opts.barDir === "col" ? "l" : "b" : opts.barDir !== "col" ? "r" : "t";
      if (valAxisId === AXIS_ID_VALUE_SECONDARY)
        axisPos = "r";
      var crossAxId = valAxisId === AXIS_ID_VALUE_PRIMARY ? AXIS_ID_CATEGORY_PRIMARY : AXIS_ID_CATEGORY_SECONDARY;
      var strXml = "";
      strXml += "<c:valAx>";
      strXml += '  <c:axId val="' + valAxisId + '"/>';
      strXml += "  <c:scaling>";
      if (opts.valAxisLogScaleBase)
        strXml += '<c:logBase val="'.concat(opts.valAxisLogScaleBase, '"/>');
      strXml += '<c:orientation val="' + (opts.valAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
      if (opts.valAxisMaxVal || opts.valAxisMaxVal === 0)
        strXml += '<c:max val="'.concat(opts.valAxisMaxVal, '"/>');
      if (opts.valAxisMinVal || opts.valAxisMinVal === 0)
        strXml += '<c:min val="'.concat(opts.valAxisMinVal, '"/>');
      strXml += "  </c:scaling>";
      strXml += '  <c:delete val="'.concat(opts.valAxisHidden ? 1 : 0, '"/>');
      strXml += '  <c:axPos val="' + axisPos + '"/>';
      if (opts.valGridLine.style !== "none")
        strXml += createGridLineElement(opts.valGridLine);
      if (opts.showValAxisTitle) {
        strXml += genXmlTitle({
          color: opts.valAxisTitleColor,
          fontFace: opts.valAxisTitleFontFace,
          fontSize: opts.valAxisTitleFontSize,
          titleRotate: opts.valAxisTitleRotate,
          title: opts.valAxisTitle || "Axis Title"
        });
      }
      strXml += '<c:numFmt formatCode="'.concat(opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General", '" sourceLinked="0"/>');
      if (opts._type === CHART_TYPE.SCATTER) {
        strXml += '  <c:majorTickMark val="none"/>';
        strXml += '  <c:minorTickMark val="none"/>';
        strXml += '  <c:tickLblPos val="nextTo"/>';
      } else {
        strXml += ' <c:majorTickMark val="' + (opts.valAxisMajorTickMark || "out") + '"/>';
        strXml += ' <c:minorTickMark val="' + (opts.valAxisMinorTickMark || "none") + '"/>';
        strXml += ' <c:tickLblPos val="' + (opts.valAxisLabelPos || (opts.barDir === "col" ? "nextTo" : "low")) + '"/>';
      }
      strXml += " <c:spPr>";
      strXml += '   <a:ln w="'.concat(opts.valAxisLineSize ? valToPts(opts.valAxisLineSize) : ONEPT, '" cap="flat">');
      strXml += !opts.valAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.valAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
      strXml += '     <a:prstDash val="' + (opts.valAxisLineStyle || "solid") + '"/>';
      strXml += "     <a:round/>";
      strXml += "   </a:ln>";
      strXml += " </c:spPr>";
      strXml += " <c:txPr>";
      strXml += "  <a:bodyPr".concat(opts.valAxisLabelRotate ? ' rot="' + convertRotationDegrees(opts.valAxisLabelRotate).toString() + '"' : "", "/>");
      strXml += "  <a:lstStyle/>";
      strXml += "  <a:p>";
      strXml += "    <a:pPr>";
      strXml += '      <a:defRPr sz="'.concat(Math.round((opts.valAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.valAxisLabelFontBold ? 1 : 0, '" i="').concat(opts.valAxisLabelFontItalic ? 1 : 0, '" u="none" strike="noStrike">');
      strXml += "        <a:solidFill>" + createColorElement(opts.valAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
      strXml += '        <a:latin typeface="' + (opts.valAxisLabelFontFace || "Arial") + '"/>';
      strXml += "      </a:defRPr>";
      strXml += "    </a:pPr>";
      strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
      strXml += "  </a:p>";
      strXml += " </c:txPr>";
      strXml += ' <c:crossAx val="' + crossAxId + '"/>';
      if (typeof opts.catAxisCrossesAt === "number") {
        strXml += ' <c:crossesAt val="'.concat(opts.catAxisCrossesAt, '"/>');
      } else if (typeof opts.catAxisCrossesAt === "string") {
        strXml += ' <c:crosses val="' + opts.catAxisCrossesAt + '"/>';
      } else {
        var isRight = axisPos === "r" || axisPos === "t";
        var crosses = isRight ? "max" : "autoZero";
        strXml += ' <c:crosses val="' + crosses + '"/>';
      }
      strXml += ' <c:crossBetween val="' + (opts._type === CHART_TYPE.SCATTER || !!(Array.isArray(opts._type) && opts._type.filter(function(type) {
        return type.type === CHART_TYPE.AREA;
      }).length > 0) ? "midCat" : "between") + '"/>';
      if (opts.valAxisMajorUnit)
        strXml += ' <c:majorUnit val="'.concat(opts.valAxisMajorUnit, '"/>');
      if (opts.valAxisDisplayUnit) {
        strXml += '<c:dispUnits><c:builtInUnit val="'.concat(opts.valAxisDisplayUnit, '"/>').concat(opts.valAxisDisplayUnitLabel ? "<c:dispUnitsLbl/>" : "", "</c:dispUnits>");
      }
      strXml += "</c:valAx>";
      return strXml;
    }
    function makeSerAxis(opts, axisId, valAxisId) {
      var strXml = "";
      strXml += "<c:serAx>";
      strXml += '  <c:axId val="' + axisId + '"/>';
      strXml += '  <c:scaling><c:orientation val="' + (opts.serAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/></c:scaling>';
      strXml += '  <c:delete val="' + (opts.serAxisHidden ? "1" : "0") + '"/>';
      strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
      strXml += opts.serGridLine.style !== "none" ? createGridLineElement(opts.serGridLine) : "";
      if (opts.showSerAxisTitle) {
        strXml += genXmlTitle({
          color: opts.serAxisTitleColor,
          fontFace: opts.serAxisTitleFontFace,
          fontSize: opts.serAxisTitleFontSize,
          titleRotate: opts.serAxisTitleRotate,
          title: opts.serAxisTitle || "Axis Title"
        });
      }
      strXml += '  <c:numFmt formatCode="'.concat(encodeXmlEntities(opts.serLabelFormatCode) || "General", '" sourceLinked="0"/>');
      strXml += '  <c:majorTickMark val="out"/>';
      strXml += '  <c:minorTickMark val="none"/>';
      strXml += '  <c:tickLblPos val="'.concat(opts.serAxisLabelPos || opts.barDir === "col" ? "low" : "nextTo", '"/>');
      strXml += "  <c:spPr>";
      strXml += '    <a:ln w="12700" cap="flat">';
      strXml += !opts.serAxisLineShow ? "<a:noFill/>" : "<a:solidFill>".concat(createColorElement(opts.serAxisLineColor || DEF_CHART_GRIDLINE.color), "</a:solidFill>");
      strXml += '      <a:prstDash val="solid"/>';
      strXml += "      <a:round/>";
      strXml += "    </a:ln>";
      strXml += "  </c:spPr>";
      strXml += "  <c:txPr>";
      strXml += "    <a:bodyPr/>";
      strXml += "    <a:lstStyle/>";
      strXml += "    <a:p>";
      strXml += "    <a:pPr>";
      strXml += '    <a:defRPr sz="'.concat(Math.round((opts.serAxisLabelFontSize || DEF_FONT_SIZE) * 100), '" b="').concat(opts.serAxisLabelFontBold ? "1" : "0", '" i="').concat(opts.serAxisLabelFontItalic ? "1" : "0", '" u="none" strike="noStrike">');
      strXml += "      <a:solidFill>".concat(createColorElement(opts.serAxisLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
      strXml += '      <a:latin typeface="'.concat(opts.serAxisLabelFontFace || "Arial", '"/>');
      strXml += "   </a:defRPr>";
      strXml += "  </a:pPr>";
      strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
      strXml += "  </a:p>";
      strXml += " </c:txPr>";
      strXml += ' <c:crossAx val="' + valAxisId + '"/>';
      strXml += ' <c:crosses val="autoZero"/>';
      if (opts.serAxisLabelFrequency)
        strXml += ' <c:tickLblSkip val="' + opts.serAxisLabelFrequency + '"/>';
      if (opts.serLabelFormatCode) {
        ["serAxisBaseTimeUnit", "serAxisMajorTimeUnit", "serAxisMinorTimeUnit"].forEach(function(opt) {
          if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opt.toLowerCase()))) {
            console.warn('"'.concat(opt, `" must be one of: 'days','months','years' !`));
            opts[opt] = null;
          }
        });
        if (opts.serAxisBaseTimeUnit)
          strXml += ' <c:baseTimeUnit  val="'.concat(opts.serAxisBaseTimeUnit.toLowerCase(), '"/>');
        if (opts.serAxisMajorTimeUnit)
          strXml += ' <c:majorTimeUnit val="'.concat(opts.serAxisMajorTimeUnit.toLowerCase(), '"/>');
        if (opts.serAxisMinorTimeUnit)
          strXml += ' <c:minorTimeUnit val="'.concat(opts.serAxisMinorTimeUnit.toLowerCase(), '"/>');
        if (opts.serAxisMajorUnit)
          strXml += ' <c:majorUnit val="'.concat(opts.serAxisMajorUnit, '"/>');
        if (opts.serAxisMinorUnit)
          strXml += ' <c:minorUnit val="'.concat(opts.serAxisMinorUnit, '"/>');
      }
      strXml += "</c:serAx>";
      return strXml;
    }
    function genXmlTitle(opts, chartX, chartY) {
      var align = opts.titleAlign === "left" || opts.titleAlign === "right" ? '<a:pPr algn="'.concat(opts.titleAlign.substring(0, 1), '">') : "<a:pPr>";
      var rotate = opts.titleRotate ? '<a:bodyPr rot="'.concat(convertRotationDegrees(opts.titleRotate), '"/>') : "<a:bodyPr/>";
      var sizeAttr = opts.fontSize ? 'sz="'.concat(Math.round(opts.fontSize * 100), '"') : "";
      var titleBold = opts.titleBold ? 1 : 0;
      var layout = "<c:layout/>";
      if (opts.titlePos && typeof opts.titlePos.x === "number" && typeof opts.titlePos.y === "number") {
        var totalX = opts.titlePos.x + chartX;
        var totalY = opts.titlePos.y + chartY;
        var valX = totalX === 0 ? 0 : totalX * (totalX / 5) / 10;
        if (valX >= 1)
          valX = valX / 10;
        if (valX >= 0.1)
          valX = valX / 10;
        var valY = totalY === 0 ? 0 : totalY * (totalY / 5) / 10;
        if (valY >= 1)
          valY = valY / 10;
        if (valY >= 0.1)
          valY = valY / 10;
        layout = '<c:layout><c:manualLayout><c:xMode val="edge"/><c:yMode val="edge"/><c:x val="'.concat(valX, '"/><c:y val="').concat(valY, '"/></c:manualLayout></c:layout>');
      }
      return "<c:title>\n      <c:tx>\n        <c:rich>\n          ".concat(rotate, "\n          <a:lstStyle/>\n          <a:p>\n            ").concat(align, "\n            <a:defRPr ").concat(sizeAttr, ' b="').concat(titleBold, '" i="0" u="none" strike="noStrike">\n              <a:solidFill>').concat(createColorElement(opts.color || DEF_FONT_COLOR), '</a:solidFill>\n              <a:latin typeface="').concat(opts.fontFace || "Arial", '"/>\n            </a:defRPr>\n          </a:pPr>\n          <a:r>\n            <a:rPr ').concat(sizeAttr, ' b="').concat(titleBold, '" i="0" u="none" strike="noStrike">\n              <a:solidFill>').concat(createColorElement(opts.color || DEF_FONT_COLOR), '</a:solidFill>\n              <a:latin typeface="').concat(opts.fontFace || "Arial", '"/>\n            </a:rPr>\n            <a:t>').concat(encodeXmlEntities(opts.title) || "", "</a:t>\n          </a:r>\n        </a:p>\n        </c:rich>\n      </c:tx>\n      ").concat(layout, '\n      <c:overlay val="0"/>\n    </c:title>');
    }
    function getExcelColName(colIndex) {
      var colStr = "";
      var colIdx = colIndex - 1;
      if (colIdx <= 25) {
        colStr = LETTERS[colIdx];
      } else {
        colStr = "".concat(LETTERS[Math.floor(colIdx / LETTERS.length - 1)]).concat(LETTERS[colIdx % LETTERS.length]);
      }
      return colStr;
    }
    function createShadowElement(options, defaults) {
      if (!options) {
        return "<a:effectLst/>";
      } else if (typeof options !== "object") {
        console.warn("`shadow` options must be an object. Ex: `{shadow: {type:'none'}}`");
        return "<a:effectLst/>";
      }
      var strXml = "<a:effectLst>";
      var opts = __assign(__assign({}, defaults), options);
      var type = opts.type || "outer";
      var blur = valToPts(opts.blur);
      var offset = valToPts(opts.offset);
      var angle = Math.round(opts.angle * 6e4);
      var color = opts.color;
      var opacity = Math.round(opts.opacity * 1e5);
      var rotShape = opts.rotateWithShape ? 1 : 0;
      strXml += "<a:".concat(type, 'Shdw sx="100000" sy="100000" kx="0" ky="0"  algn="bl" blurRad="').concat(blur, '" rotWithShape="').concat(rotShape, '" dist="').concat(offset, '" dir="').concat(angle, '">');
      strXml += '<a:srgbClr val="'.concat(color, '">');
      strXml += '<a:alpha val="'.concat(opacity, '"/></a:srgbClr>');
      strXml += "</a:".concat(type, "Shdw>");
      strXml += "</a:effectLst>";
      return strXml;
    }
    function createGridLineElement(glOpts) {
      var strXml = "<c:majorGridlines>";
      strXml += " <c:spPr>";
      strXml += '  <a:ln w="'.concat(valToPts(glOpts.size || DEF_CHART_GRIDLINE.size), '" cap="').concat(createLineCap(glOpts.cap || DEF_CHART_GRIDLINE.cap), '">');
      strXml += '  <a:solidFill><a:srgbClr val="' + (glOpts.color || DEF_CHART_GRIDLINE.color) + '"/></a:solidFill>';
      strXml += '   <a:prstDash val="' + (glOpts.style || DEF_CHART_GRIDLINE.style) + '"/><a:round/>';
      strXml += "  </a:ln>";
      strXml += " </c:spPr>";
      strXml += "</c:majorGridlines>";
      return strXml;
    }
    function createLineCap(lineCap) {
      if (!lineCap || lineCap === "flat") {
        return "flat";
      } else if (lineCap === "square") {
        return "sq";
      } else if (lineCap === "round") {
        return "rnd";
      } else {
        var neverLineCap = lineCap;
        throw new Error("Invalid chart line cap: ".concat(neverLineCap));
      }
    }
    function encodeSlideMediaRels(layout) {
      var fs2 = typeof require !== "undefined" && typeof window === "undefined" ? require("fs") : null;
      var https = typeof require !== "undefined" && typeof window === "undefined" ? require("https") : null;
      var imageProms = [];
      var candidateRels = layout._relsMedia.filter(function(rel) {
        return rel.type !== "online" && !rel.data && (!rel.path || rel.path && !rel.path.includes("preencoded"));
      });
      var unqPaths = [];
      candidateRels.forEach(function(rel) {
        if (!unqPaths.includes(rel.path)) {
          rel.isDuplicate = false;
          unqPaths.push(rel.path);
        } else {
          rel.isDuplicate = true;
        }
      });
      candidateRels.filter(function(rel) {
        return !rel.isDuplicate;
      }).forEach(function(rel) {
        imageProms.push(new Promise(function(resolve, reject) {
          if (fs2 && rel.path.indexOf("http") !== 0) {
            try {
              var bitmap = fs2.readFileSync(rel.path);
              rel.data = Buffer.from(bitmap).toString("base64");
              candidateRels.filter(function(dupe) {
                return dupe.isDuplicate && dupe.path === rel.path;
              }).forEach(function(dupe) {
                return dupe.data = rel.data;
              });
              resolve("done");
            } catch (ex) {
              rel.data = IMG_BROKEN;
              candidateRels.filter(function(dupe) {
                return dupe.isDuplicate && dupe.path === rel.path;
              }).forEach(function(dupe) {
                return dupe.data = rel.data;
              });
              reject(new Error('ERROR: Unable to read media: "'.concat(rel.path, '"\n').concat(String(ex))));
            }
          } else if (fs2 && https && rel.path.indexOf("http") === 0) {
            https.get(rel.path, function(res) {
              var rawData = "";
              res.setEncoding("binary");
              res.on("data", function(chunk) {
                return rawData += chunk;
              });
              res.on("end", function() {
                rel.data = Buffer.from(rawData, "binary").toString("base64");
                candidateRels.filter(function(dupe) {
                  return dupe.isDuplicate && dupe.path === rel.path;
                }).forEach(function(dupe) {
                  return dupe.data = rel.data;
                });
                resolve("done");
              });
              res.on("error", function(_ex) {
                rel.data = IMG_BROKEN;
                candidateRels.filter(function(dupe) {
                  return dupe.isDuplicate && dupe.path === rel.path;
                }).forEach(function(dupe) {
                  return dupe.data = rel.data;
                });
                reject(new Error("ERROR! Unable to load image (https.get): ".concat(rel.path)));
              });
            });
          } else {
            var xhr_1 = new XMLHttpRequest();
            xhr_1.onload = function() {
              var reader = new FileReader();
              reader.onloadend = function() {
                rel.data = reader.result;
                candidateRels.filter(function(dupe) {
                  return dupe.isDuplicate && dupe.path === rel.path;
                }).forEach(function(dupe) {
                  return dupe.data = rel.data;
                });
                if (!rel.isSvgPng) {
                  resolve("done");
                } else {
                  createSvgPngPreview(rel).then(function() {
                    resolve("done");
                  }).catch(function(ex) {
                    reject(ex);
                  });
                }
              };
              reader.readAsDataURL(xhr_1.response);
            };
            xhr_1.onerror = function(ex) {
              rel.data = IMG_BROKEN;
              candidateRels.filter(function(dupe) {
                return dupe.isDuplicate && dupe.path === rel.path;
              }).forEach(function(dupe) {
                return dupe.data = rel.data;
              });
              reject(new Error("ERROR! Unable to load image (xhr.onerror): ".concat(rel.path)));
            };
            xhr_1.open("GET", rel.path);
            xhr_1.responseType = "blob";
            xhr_1.send();
          }
        }));
      });
      layout._relsMedia.filter(function(rel) {
        return rel.isSvgPng && rel.data;
      }).forEach(function(rel) {
        if (fs2) {
          rel.data = IMG_BROKEN;
          imageProms.push(Promise.resolve().then(function() {
            return "done";
          }));
        } else {
          imageProms.push(createSvgPngPreview(rel));
        }
      });
      return imageProms;
    }
    function createSvgPngPreview(rel) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, new Promise(function(resolve, reject) {
                var image = new Image();
                image.onload = function() {
                  if (image.width + image.height === 0) {
                    image.onerror("h/w=0");
                  }
                  var canvas = document.createElement("CANVAS");
                  var ctx = canvas.getContext("2d");
                  canvas.width = image.width;
                  canvas.height = image.height;
                  ctx.drawImage(image, 0, 0);
                  try {
                    rel.data = canvas.toDataURL(rel.type);
                    resolve("done");
                  } catch (ex) {
                    image.onerror(ex);
                  }
                  canvas = null;
                };
                image.onerror = function(ex) {
                  rel.data = IMG_BROKEN;
                  reject(new Error("ERROR! Unable to load image (image.onerror): ".concat(rel.path)));
                };
                image.src = typeof rel.data === "string" ? rel.data : IMG_BROKEN;
              })];
            case 1:
              return [2, _a.sent()];
          }
        });
      });
    }
    var ImageSizingXml = {
      cover: function(imgSize, boxDim) {
        var imgRatio = imgSize.h / imgSize.w;
        var boxRatio = boxDim.h / boxDim.w;
        var isBoxBased = boxRatio > imgRatio;
        var width = isBoxBased ? boxDim.h / imgRatio : boxDim.w;
        var height = isBoxBased ? boxDim.h : boxDim.w * imgRatio;
        var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
        var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
        return '<a:srcRect l="'.concat(hzPerc, '" r="').concat(hzPerc, '" t="').concat(vzPerc, '" b="').concat(vzPerc, '"/><a:stretch/>');
      },
      contain: function(imgSize, boxDim) {
        var imgRatio = imgSize.h / imgSize.w;
        var boxRatio = boxDim.h / boxDim.w;
        var widthBased = boxRatio > imgRatio;
        var width = widthBased ? boxDim.w : boxDim.h / imgRatio;
        var height = widthBased ? boxDim.w * imgRatio : boxDim.h;
        var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
        var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
        return '<a:srcRect l="'.concat(hzPerc, '" r="').concat(hzPerc, '" t="').concat(vzPerc, '" b="').concat(vzPerc, '"/><a:stretch/>');
      },
      crop: function(imgSize, boxDim) {
        var l = boxDim.x;
        var r = imgSize.w - (boxDim.x + boxDim.w);
        var t = boxDim.y;
        var b = imgSize.h - (boxDim.y + boxDim.h);
        var lPerc = Math.round(1e5 * (l / imgSize.w));
        var rPerc = Math.round(1e5 * (r / imgSize.w));
        var tPerc = Math.round(1e5 * (t / imgSize.h));
        var bPerc = Math.round(1e5 * (b / imgSize.h));
        return '<a:srcRect l="'.concat(lPerc, '" r="').concat(rPerc, '" t="').concat(tPerc, '" b="').concat(bPerc, '"/><a:stretch/>');
      }
    };
    function slideObjectToXml(slide) {
      var _a;
      var strSlideXml = slide._name ? '<p:cSld name="' + slide._name + '">' : "<p:cSld>";
      var intTableNum = 1;
      if (slide._bkgdImgRid) {
        strSlideXml += '<p:bg><p:bgPr><a:blipFill dpi="0" rotWithShape="1"><a:blip r:embed="rId'.concat(slide._bkgdImgRid, '"><a:lum/></a:blip><a:srcRect/><a:stretch><a:fillRect/></a:stretch></a:blipFill><a:effectLst/></p:bgPr></p:bg>');
      } else if ((_a = slide.background) === null || _a === void 0 ? void 0 : _a.color) {
        strSlideXml += "<p:bg><p:bgPr>".concat(genXmlColorSelection(slide.background), "</p:bgPr></p:bg>");
      } else if (!slide.bkgd && slide._name && slide._name === DEF_PRES_LAYOUT_NAME) {
        strSlideXml += '<p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg>';
      }
      strSlideXml += "<p:spTree>";
      strSlideXml += '<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>';
      strSlideXml += '<p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/>';
      strSlideXml += '<a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr>';
      slide._slideObjects.forEach(function(slideItemObj, idx) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        var x = 0;
        var y = 0;
        var cx = getSmartParseNumber("75%", "X", slide._presLayout);
        var cy = 0;
        var placeholderObj;
        var locationAttr = "";
        var arrTabRows = null;
        var objTabOpts = null;
        var intColCnt = 0;
        var intColW = 0;
        var cellOpts = null;
        var strXml = null;
        var sizing = (_a2 = slideItemObj.options) === null || _a2 === void 0 ? void 0 : _a2.sizing;
        var rounding = (_b = slideItemObj.options) === null || _b === void 0 ? void 0 : _b.rounding;
        if (slide._slideLayout !== void 0 && slide._slideLayout._slideObjects !== void 0 && slideItemObj.options && slideItemObj.options.placeholder) {
          placeholderObj = slide._slideLayout._slideObjects.filter(function(object) {
            return object.options.placeholder === slideItemObj.options.placeholder;
          })[0];
        }
        slideItemObj.options = slideItemObj.options || {};
        if (typeof slideItemObj.options.x !== "undefined")
          x = getSmartParseNumber(slideItemObj.options.x, "X", slide._presLayout);
        if (typeof slideItemObj.options.y !== "undefined")
          y = getSmartParseNumber(slideItemObj.options.y, "Y", slide._presLayout);
        if (typeof slideItemObj.options.w !== "undefined")
          cx = getSmartParseNumber(slideItemObj.options.w, "X", slide._presLayout);
        if (typeof slideItemObj.options.h !== "undefined")
          cy = getSmartParseNumber(slideItemObj.options.h, "Y", slide._presLayout);
        var imgWidth = cx;
        var imgHeight = cy;
        if (placeholderObj) {
          if (placeholderObj.options.x || placeholderObj.options.x === 0)
            x = getSmartParseNumber(placeholderObj.options.x, "X", slide._presLayout);
          if (placeholderObj.options.y || placeholderObj.options.y === 0)
            y = getSmartParseNumber(placeholderObj.options.y, "Y", slide._presLayout);
          if (placeholderObj.options.w || placeholderObj.options.w === 0)
            cx = getSmartParseNumber(placeholderObj.options.w, "X", slide._presLayout);
          if (placeholderObj.options.h || placeholderObj.options.h === 0)
            cy = getSmartParseNumber(placeholderObj.options.h, "Y", slide._presLayout);
        }
        if (slideItemObj.options.flipH)
          locationAttr += ' flipH="1"';
        if (slideItemObj.options.flipV)
          locationAttr += ' flipV="1"';
        if (slideItemObj.options.rotate)
          locationAttr += ' rot="'.concat(convertRotationDegrees(slideItemObj.options.rotate), '"');
        switch (slideItemObj._type) {
          case SLIDE_OBJECT_TYPES.table:
            arrTabRows = slideItemObj.arrTabRows;
            objTabOpts = slideItemObj.options;
            intColCnt = 0;
            intColW = 0;
            arrTabRows[0].forEach(function(cell) {
              cellOpts = cell.options || null;
              intColCnt += (cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? Number(cellOpts.colspan) : 1;
            });
            strXml = '<p:graphicFrame><p:nvGraphicFramePr><p:cNvPr id="'.concat(intTableNum * slide._slideNum + 1, '" name="').concat(slideItemObj.options.objectName, '"/>');
            strXml += '<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp="1"/></p:cNvGraphicFramePr>  <p:nvPr><p:extLst><p:ext uri="{D42A27DB-BD31-4B8C-83A1-F6EECF244321}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1579011935"/></p:ext></p:extLst></p:nvPr></p:nvGraphicFramePr>';
            strXml += '<p:xfrm><a:off x="'.concat(x || (x === 0 ? 0 : EMU), '" y="').concat(y || (y === 0 ? 0 : EMU), '"/><a:ext cx="').concat(cx || (cx === 0 ? 0 : EMU), '" cy="').concat(cy || EMU, '"/></p:xfrm>');
            strXml += '<a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table"><a:tbl><a:tblPr/>';
            if (Array.isArray(objTabOpts.colW)) {
              strXml += "<a:tblGrid>";
              for (var col = 0; col < intColCnt; col++) {
                var w = inch2Emu(objTabOpts.colW[col]);
                if (w == null || isNaN(w)) {
                  w = (typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt;
                }
                strXml += '<a:gridCol w="'.concat(Math.round(w), '"/>');
              }
              strXml += "</a:tblGrid>";
            } else {
              intColW = objTabOpts.colW ? objTabOpts.colW : EMU;
              if (slideItemObj.options.w && !objTabOpts.colW)
                intColW = Math.round((typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt);
              strXml += "<a:tblGrid>";
              for (var colw = 0; colw < intColCnt; colw++) {
                strXml += '<a:gridCol w="'.concat(intColW, '"/>');
              }
              strXml += "</a:tblGrid>";
            }
            arrTabRows.forEach(function(cells) {
              var _a3, _b2;
              var _loop_1 = function(cIdx2) {
                var cell = cells[cIdx2];
                var colspan = (_a3 = cell.options) === null || _a3 === void 0 ? void 0 : _a3.colspan;
                var rowspan = (_b2 = cell.options) === null || _b2 === void 0 ? void 0 : _b2.rowspan;
                if (colspan && colspan > 1) {
                  var vMergeCells = new Array(colspan - 1).fill(void 0).map(function(_) {
                    return { _type: SLIDE_OBJECT_TYPES.tablecell, options: { rowspan }, _hmerge: true };
                  });
                  cells.splice.apply(cells, __spreadArray([cIdx2 + 1, 0], vMergeCells, false));
                  cIdx2 += colspan;
                } else {
                  cIdx2 += 1;
                }
                out_cIdx_1 = cIdx2;
              };
              var out_cIdx_1;
              for (var cIdx = 0; cIdx < cells.length; ) {
                _loop_1(cIdx);
                cIdx = out_cIdx_1;
              }
            });
            arrTabRows.forEach(function(cells, rIdx) {
              var nextRow = arrTabRows[rIdx + 1];
              if (!nextRow)
                return;
              cells.forEach(function(cell, cIdx) {
                var _a3, _b2;
                var rowspan = cell._rowContinue || ((_a3 = cell.options) === null || _a3 === void 0 ? void 0 : _a3.rowspan);
                var colspan = (_b2 = cell.options) === null || _b2 === void 0 ? void 0 : _b2.colspan;
                var _hmerge = cell._hmerge;
                if (rowspan && rowspan > 1) {
                  var hMergeCell = { _type: SLIDE_OBJECT_TYPES.tablecell, options: { colspan }, _rowContinue: rowspan - 1, _vmerge: true, _hmerge };
                  nextRow.splice(cIdx, 0, hMergeCell);
                }
              });
            });
            arrTabRows.forEach(function(cells, rIdx) {
              var intRowH = 0;
              if (Array.isArray(objTabOpts.rowH) && objTabOpts.rowH[rIdx])
                intRowH = inch2Emu(Number(objTabOpts.rowH[rIdx]));
              else if (objTabOpts.rowH && !isNaN(Number(objTabOpts.rowH)))
                intRowH = inch2Emu(Number(objTabOpts.rowH));
              else if (slideItemObj.options.cy || slideItemObj.options.h) {
                intRowH = Math.round((slideItemObj.options.h ? inch2Emu(slideItemObj.options.h) : typeof slideItemObj.options.cy === "number" ? slideItemObj.options.cy : 1) / arrTabRows.length);
              }
              strXml += '<a:tr h="'.concat(intRowH, '">');
              cells.forEach(function(cellObj) {
                var _a3, _b2, _c2, _d2, _e2;
                var cell = cellObj;
                var cellSpanAttrs = {
                  rowSpan: ((_a3 = cell.options) === null || _a3 === void 0 ? void 0 : _a3.rowspan) > 1 ? cell.options.rowspan : void 0,
                  gridSpan: ((_b2 = cell.options) === null || _b2 === void 0 ? void 0 : _b2.colspan) > 1 ? cell.options.colspan : void 0,
                  vMerge: cell._vmerge ? 1 : void 0,
                  hMerge: cell._hmerge ? 1 : void 0
                };
                var cellSpanAttrStr = Object.keys(cellSpanAttrs).map(function(k) {
                  return [k, cellSpanAttrs[k]];
                }).filter(function(_a4) {
                  _a4[0];
                  var v = _a4[1];
                  return !!v;
                }).map(function(_a4) {
                  var k = _a4[0], v = _a4[1];
                  return "".concat(String(k), '="').concat(String(v), '"');
                }).join(" ");
                if (cellSpanAttrStr)
                  cellSpanAttrStr = " " + cellSpanAttrStr;
                if (cell._hmerge || cell._vmerge) {
                  strXml += "<a:tc".concat(cellSpanAttrStr, "><a:tcPr/></a:tc>");
                  return;
                }
                var cellOpts2 = cell.options || {};
                cell.options = cellOpts2;
                ["align", "bold", "border", "color", "fill", "fontFace", "fontSize", "margin", "underline", "valign"].forEach(function(name) {
                  if (objTabOpts[name] && !cellOpts2[name] && cellOpts2[name] !== 0)
                    cellOpts2[name] = objTabOpts[name];
                });
                var cellValign = cellOpts2.valign ? ' anchor="'.concat(cellOpts2.valign.replace(/^c$/i, "ctr").replace(/^m$/i, "ctr").replace("center", "ctr").replace("middle", "ctr").replace("top", "t").replace("btm", "b").replace("bottom", "b"), '"') : "";
                var fillColor = ((_d2 = (_c2 = cell._optImp) === null || _c2 === void 0 ? void 0 : _c2.fill) === null || _d2 === void 0 ? void 0 : _d2.color) ? cell._optImp.fill.color : ((_e2 = cell._optImp) === null || _e2 === void 0 ? void 0 : _e2.fill) && typeof cell._optImp.fill === "string" ? cell._optImp.fill : "";
                fillColor = fillColor || cellOpts2.fill ? cellOpts2.fill : "";
                var cellFill = fillColor ? genXmlColorSelection(fillColor) : "";
                var cellMargin = cellOpts2.margin === 0 || cellOpts2.margin ? cellOpts2.margin : DEF_CELL_MARGIN_IN;
                if (!Array.isArray(cellMargin) && typeof cellMargin === "number")
                  cellMargin = [cellMargin, cellMargin, cellMargin, cellMargin];
                var cellMarginXml = "";
                if (cellMargin[0] >= 1) {
                  cellMarginXml = ' marL="'.concat(valToPts(cellMargin[3]), '" marR="').concat(valToPts(cellMargin[1]), '" marT="').concat(valToPts(cellMargin[0]), '" marB="').concat(valToPts(cellMargin[2]), '"');
                } else {
                  cellMarginXml = ' marL="'.concat(inch2Emu(cellMargin[3]), '" marR="').concat(inch2Emu(cellMargin[1]), '" marT="').concat(inch2Emu(cellMargin[0]), '" marB="').concat(inch2Emu(cellMargin[2]), '"');
                }
                strXml += "<a:tc".concat(cellSpanAttrStr, ">").concat(genXmlTextBody(cell), "<a:tcPr").concat(cellMarginXml).concat(cellValign, ">");
                if (cellOpts2.border && Array.isArray(cellOpts2.border)) {
                  [
                    { idx: 3, name: "lnL" },
                    { idx: 1, name: "lnR" },
                    { idx: 0, name: "lnT" },
                    { idx: 2, name: "lnB" }
                  ].forEach(function(obj) {
                    if (cellOpts2.border[obj.idx].type !== "none") {
                      strXml += "<a:".concat(obj.name, ' w="').concat(valToPts(cellOpts2.border[obj.idx].pt), '" cap="flat" cmpd="sng" algn="ctr">');
                      strXml += "<a:solidFill>".concat(createColorElement(cellOpts2.border[obj.idx].color), "</a:solidFill>");
                      strXml += '<a:prstDash val="'.concat(cellOpts2.border[obj.idx].type === "dash" ? "sysDash" : "solid", '"/><a:round/><a:headEnd type="none" w="med" len="med"/><a:tailEnd type="none" w="med" len="med"/>');
                      strXml += "</a:".concat(obj.name, ">");
                    } else {
                      strXml += "<a:".concat(obj.name, ' w="0" cap="flat" cmpd="sng" algn="ctr"><a:noFill/></a:').concat(obj.name, ">");
                    }
                  });
                }
                strXml += cellFill;
                strXml += "  </a:tcPr>";
                strXml += " </a:tc>";
              });
              strXml += "</a:tr>";
            });
            strXml += "      </a:tbl>";
            strXml += "    </a:graphicData>";
            strXml += "  </a:graphic>";
            strXml += "</p:graphicFrame>";
            strSlideXml += strXml;
            intTableNum++;
            break;
          case SLIDE_OBJECT_TYPES.text:
          case SLIDE_OBJECT_TYPES.placeholder:
            if (!slideItemObj.options.line && cy === 0)
              cy = EMU * 0.3;
            if (!slideItemObj.options._bodyProp)
              slideItemObj.options._bodyProp = {};
            if (slideItemObj.options.margin && Array.isArray(slideItemObj.options.margin)) {
              slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin[0] || 0);
              slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin[1] || 0);
              slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin[2] || 0);
              slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin[3] || 0);
            } else if (typeof slideItemObj.options.margin === "number") {
              slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin);
              slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin);
              slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin);
              slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin);
            }
            strSlideXml += "<p:sp>";
            strSlideXml += '<p:nvSpPr><p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '">');
            if ((_c = slideItemObj.options.hyperlink) === null || _c === void 0 ? void 0 : _c.url) {
              strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.options.hyperlink._rId, '" tooltip="').concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : "", '"/>');
            }
            if ((_d = slideItemObj.options.hyperlink) === null || _d === void 0 ? void 0 : _d.slide) {
              strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.options.hyperlink._rId, '" tooltip="').concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : "", '" action="ppaction://hlinksldjump"/>');
            }
            strSlideXml += "</p:cNvPr>";
            strSlideXml += "<p:cNvSpPr" + (((_e = slideItemObj.options) === null || _e === void 0 ? void 0 : _e.isTextBox) ? ' txBox="1"/>' : "/>");
            strSlideXml += "<p:nvPr>".concat(slideItemObj._type === "placeholder" ? genXmlPlaceholder(slideItemObj) : genXmlPlaceholder(placeholderObj), "</p:nvPr>");
            strSlideXml += "</p:nvSpPr><p:spPr>";
            strSlideXml += "<a:xfrm".concat(locationAttr, ">");
            strSlideXml += '<a:off x="'.concat(x, '" y="').concat(y, '"/>');
            strSlideXml += '<a:ext cx="'.concat(cx, '" cy="').concat(cy, '"/></a:xfrm>');
            if (slideItemObj.shape === "custGeom") {
              strSlideXml += "<a:custGeom><a:avLst />";
              strSlideXml += "<a:gdLst>";
              strSlideXml += "</a:gdLst>";
              strSlideXml += "<a:ahLst />";
              strSlideXml += "<a:cxnLst>";
              strSlideXml += "</a:cxnLst>";
              strSlideXml += '<a:rect l="l" t="t" r="r" b="b" />';
              strSlideXml += "<a:pathLst>";
              strSlideXml += '<a:path w="'.concat(cx, '" h="').concat(cy, '">');
              (_f = slideItemObj.options.points) === null || _f === void 0 ? void 0 : _f.forEach(function(point, i2) {
                if ("curve" in point) {
                  switch (point.curve.type) {
                    case "arc":
                      strSlideXml += '<a:arcTo hR="'.concat(getSmartParseNumber(point.curve.hR, "Y", slide._presLayout), '" wR="').concat(getSmartParseNumber(point.curve.wR, "X", slide._presLayout), '" stAng="').concat(convertRotationDegrees(point.curve.stAng), '" swAng="').concat(convertRotationDegrees(point.curve.swAng), '" />');
                      break;
                    case "cubic":
                      strSlideXml += '<a:cubicBezTo>\n									<a:pt x="'.concat(getSmartParseNumber(point.curve.x1, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y1, "Y", slide._presLayout), '" />\n									<a:pt x="').concat(getSmartParseNumber(point.curve.x2, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y2, "Y", slide._presLayout), '" />\n									<a:pt x="').concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" />\n									</a:cubicBezTo>');
                      break;
                    case "quadratic":
                      strSlideXml += '<a:quadBezTo>\n									<a:pt x="'.concat(getSmartParseNumber(point.curve.x1, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.curve.y1, "Y", slide._presLayout), '" />\n									<a:pt x="').concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" />\n									</a:quadBezTo>');
                      break;
                  }
                } else if ("close" in point) {
                  strSlideXml += "<a:close />";
                } else if (point.moveTo || i2 === 0) {
                  strSlideXml += '<a:moveTo><a:pt x="'.concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" /></a:moveTo>');
                } else {
                  strSlideXml += '<a:lnTo><a:pt x="'.concat(getSmartParseNumber(point.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(point.y, "Y", slide._presLayout), '" /></a:lnTo>');
                }
              });
              strSlideXml += "</a:path>";
              strSlideXml += "</a:pathLst>";
              strSlideXml += "</a:custGeom>";
            } else {
              strSlideXml += '<a:prstGeom prst="' + slideItemObj.shape + '"><a:avLst>';
              if (slideItemObj.options.rectRadius) {
                strSlideXml += '<a:gd name="adj" fmla="val '.concat(Math.round(slideItemObj.options.rectRadius * EMU * 1e5 / Math.min(cx, cy)), '"/>');
              } else if (slideItemObj.options.angleRange) {
                for (var i = 0; i < 2; i++) {
                  var angle = slideItemObj.options.angleRange[i];
                  strSlideXml += '<a:gd name="adj'.concat(i + 1, '" fmla="val ').concat(convertRotationDegrees(angle), '" />');
                }
                if (slideItemObj.options.arcThicknessRatio) {
                  strSlideXml += '<a:gd name="adj3" fmla="val '.concat(Math.round(slideItemObj.options.arcThicknessRatio * 5e4), '" />');
                }
              }
              strSlideXml += "</a:avLst></a:prstGeom>";
            }
            strSlideXml += slideItemObj.options.fill ? genXmlColorSelection(slideItemObj.options.fill) : "<a:noFill/>";
            if (slideItemObj.options.line) {
              strSlideXml += slideItemObj.options.line.width ? '<a:ln w="'.concat(valToPts(slideItemObj.options.line.width), '">') : "<a:ln>";
              if (slideItemObj.options.line.color)
                strSlideXml += genXmlColorSelection(slideItemObj.options.line);
              if (slideItemObj.options.line.dashType)
                strSlideXml += '<a:prstDash val="'.concat(slideItemObj.options.line.dashType, '"/>');
              if (slideItemObj.options.line.beginArrowType)
                strSlideXml += '<a:headEnd type="'.concat(slideItemObj.options.line.beginArrowType, '"/>');
              if (slideItemObj.options.line.endArrowType)
                strSlideXml += '<a:tailEnd type="'.concat(slideItemObj.options.line.endArrowType, '"/>');
              strSlideXml += "</a:ln>";
            }
            if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== "none") {
              slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || "outer";
              slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
              slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
              slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 6e4);
              slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 1e5);
              slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
              strSlideXml += "<a:effectLst>";
              strSlideXml += " <a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === "outer" ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : "", ' blurRad="').concat(slideItemObj.options.shadow.blur, '" dist="').concat(slideItemObj.options.shadow.offset, '" dir="').concat(slideItemObj.options.shadow.angle, '">');
              strSlideXml += ' <a:srgbClr val="'.concat(slideItemObj.options.shadow.color, '">');
              strSlideXml += ' <a:alpha val="'.concat(slideItemObj.options.shadow.opacity, '"/></a:srgbClr>');
              strSlideXml += " </a:outerShdw>";
              strSlideXml += "</a:effectLst>";
            }
            strSlideXml += "</p:spPr>";
            strSlideXml += genXmlTextBody(slideItemObj);
            strSlideXml += "</p:sp>";
            break;
          case SLIDE_OBJECT_TYPES.image:
            strSlideXml += "<p:pic>";
            strSlideXml += "  <p:nvPicPr>";
            strSlideXml += '<p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '" descr="').concat(encodeXmlEntities(slideItemObj.options.altText || slideItemObj.image), '">');
            if ((_g = slideItemObj.hyperlink) === null || _g === void 0 ? void 0 : _g.url) {
              strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.hyperlink._rId, '" tooltip="').concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : "", '"/>');
            }
            if ((_h = slideItemObj.hyperlink) === null || _h === void 0 ? void 0 : _h.slide) {
              strSlideXml += '<a:hlinkClick r:id="rId'.concat(slideItemObj.hyperlink._rId, '" tooltip="').concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : "", '" action="ppaction://hlinksldjump"/>');
            }
            strSlideXml += "    </p:cNvPr>";
            strSlideXml += '    <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
            strSlideXml += "    <p:nvPr>" + genXmlPlaceholder(placeholderObj) + "</p:nvPr>";
            strSlideXml += "  </p:nvPicPr>";
            strSlideXml += "<p:blipFill>";
            if ((slide._relsMedia || []).filter(function(rel) {
              return rel.rId === slideItemObj.imageRid;
            })[0] && (slide._relsMedia || []).filter(function(rel) {
              return rel.rId === slideItemObj.imageRid;
            })[0].extn === "svg") {
              strSlideXml += '<a:blip r:embed="rId'.concat(slideItemObj.imageRid - 1, '">');
              strSlideXml += slideItemObj.options.transparency ? ' <a:alphaModFix amt="'.concat(Math.round((100 - slideItemObj.options.transparency) * 1e3), '"/>') : "";
              strSlideXml += " <a:extLst>";
              strSlideXml += '  <a:ext uri="{96DAC541-7B7A-43D3-8B79-37D633B846F1}">';
              strSlideXml += '   <asvg:svgBlip xmlns:asvg="http://schemas.microsoft.com/office/drawing/2016/SVG/main" r:embed="rId'.concat(slideItemObj.imageRid, '"/>');
              strSlideXml += "  </a:ext>";
              strSlideXml += " </a:extLst>";
              strSlideXml += "</a:blip>";
            } else {
              strSlideXml += '<a:blip r:embed="rId'.concat(slideItemObj.imageRid, '">');
              strSlideXml += slideItemObj.options.transparency ? '<a:alphaModFix amt="'.concat(Math.round((100 - slideItemObj.options.transparency) * 1e3), '"/>') : "";
              strSlideXml += "</a:blip>";
            }
            if (sizing === null || sizing === void 0 ? void 0 : sizing.type) {
              var boxW = sizing.w ? getSmartParseNumber(sizing.w, "X", slide._presLayout) : cx;
              var boxH = sizing.h ? getSmartParseNumber(sizing.h, "Y", slide._presLayout) : cy;
              var boxX = getSmartParseNumber(sizing.x || 0, "X", slide._presLayout);
              var boxY = getSmartParseNumber(sizing.y || 0, "Y", slide._presLayout);
              strSlideXml += ImageSizingXml[sizing.type]({ w: imgWidth, h: imgHeight }, { w: boxW, h: boxH, x: boxX, y: boxY });
              imgWidth = boxW;
              imgHeight = boxH;
            } else {
              strSlideXml += "  <a:stretch><a:fillRect/></a:stretch>";
            }
            strSlideXml += "</p:blipFill>";
            strSlideXml += "<p:spPr>";
            strSlideXml += " <a:xfrm" + locationAttr + ">";
            strSlideXml += '  <a:off x="'.concat(x, '" y="').concat(y, '"/>');
            strSlideXml += '  <a:ext cx="'.concat(imgWidth, '" cy="').concat(imgHeight, '"/>');
            strSlideXml += " </a:xfrm>";
            strSlideXml += ' <a:prstGeom prst="'.concat(rounding ? "ellipse" : "rect", '"><a:avLst/></a:prstGeom>');
            if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== "none") {
              slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || "outer";
              slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
              slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
              slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 6e4);
              slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 1e5);
              slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
              strSlideXml += "<a:effectLst>";
              strSlideXml += "<a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === "outer" ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : "", ' blurRad="').concat(slideItemObj.options.shadow.blur, '" dist="').concat(slideItemObj.options.shadow.offset, '" dir="').concat(slideItemObj.options.shadow.angle, '">');
              strSlideXml += '<a:srgbClr val="'.concat(slideItemObj.options.shadow.color, '">');
              strSlideXml += '<a:alpha val="'.concat(slideItemObj.options.shadow.opacity, '"/></a:srgbClr>');
              strSlideXml += "</a:".concat(slideItemObj.options.shadow.type, "Shdw>");
              strSlideXml += "</a:effectLst>";
            }
            strSlideXml += "</p:spPr>";
            strSlideXml += "</p:pic>";
            break;
          case SLIDE_OBJECT_TYPES.media:
            if (slideItemObj.mtype === "online") {
              strSlideXml += "<p:pic>";
              strSlideXml += " <p:nvPicPr>";
              strSlideXml += '<p:cNvPr id="'.concat(slideItemObj.mediaRid + 2, '" name="').concat(slideItemObj.options.objectName, '"/>');
              strSlideXml += " <p:cNvPicPr/>";
              strSlideXml += " <p:nvPr>";
              strSlideXml += '  <a:videoFile r:link="rId'.concat(slideItemObj.mediaRid, '"/>');
              strSlideXml += " </p:nvPr>";
              strSlideXml += " </p:nvPicPr>";
              strSlideXml += ' <p:blipFill><a:blip r:embed="rId'.concat(slideItemObj.mediaRid + 1, '"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>');
              strSlideXml += " <p:spPr>";
              strSlideXml += "  <a:xfrm".concat(locationAttr, '><a:off x="').concat(x, '" y="').concat(y, '"/><a:ext cx="').concat(cx, '" cy="').concat(cy, '"/></a:xfrm>');
              strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
              strSlideXml += " </p:spPr>";
              strSlideXml += "</p:pic>";
            } else {
              strSlideXml += "<p:pic>";
              strSlideXml += " <p:nvPicPr>";
              strSlideXml += '<p:cNvPr id="'.concat(slideItemObj.mediaRid + 2, '" name="').concat(slideItemObj.options.objectName, '"><a:hlinkClick r:id="" action="ppaction://media"/></p:cNvPr>');
              strSlideXml += ' <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
              strSlideXml += " <p:nvPr>";
              strSlideXml += '  <a:videoFile r:link="rId'.concat(slideItemObj.mediaRid, '"/>');
              strSlideXml += "  <p:extLst>";
              strSlideXml += '   <p:ext uri="{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}">';
              strSlideXml += '    <p14:media xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" r:embed="rId'.concat(slideItemObj.mediaRid + 1, '"/>');
              strSlideXml += "   </p:ext>";
              strSlideXml += "  </p:extLst>";
              strSlideXml += " </p:nvPr>";
              strSlideXml += " </p:nvPicPr>";
              strSlideXml += ' <p:blipFill><a:blip r:embed="rId'.concat(slideItemObj.mediaRid + 2, '"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>');
              strSlideXml += " <p:spPr>";
              strSlideXml += "  <a:xfrm".concat(locationAttr, '><a:off x="').concat(x, '" y="').concat(y, '"/><a:ext cx="').concat(cx, '" cy="').concat(cy, '"/></a:xfrm>');
              strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
              strSlideXml += " </p:spPr>";
              strSlideXml += "</p:pic>";
            }
            break;
          case SLIDE_OBJECT_TYPES.chart:
            strSlideXml += "<p:graphicFrame>";
            strSlideXml += " <p:nvGraphicFramePr>";
            strSlideXml += '   <p:cNvPr id="'.concat(idx + 2, '" name="').concat(slideItemObj.options.objectName, '" descr="').concat(encodeXmlEntities(slideItemObj.options.altText || ""), '"/>');
            strSlideXml += "   <p:cNvGraphicFramePr/>";
            strSlideXml += "   <p:nvPr>".concat(genXmlPlaceholder(placeholderObj), "</p:nvPr>");
            strSlideXml += " </p:nvGraphicFramePr>";
            strSlideXml += ' <p:xfrm><a:off x="'.concat(x, '" y="').concat(y, '"/><a:ext cx="').concat(cx, '" cy="').concat(cy, '"/></p:xfrm>');
            strSlideXml += ' <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">';
            strSlideXml += '  <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/chart">';
            strSlideXml += '   <c:chart r:id="rId'.concat(slideItemObj.chartRid, '" xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart"/>');
            strSlideXml += "  </a:graphicData>";
            strSlideXml += " </a:graphic>";
            strSlideXml += "</p:graphicFrame>";
            break;
          default:
            strSlideXml += "";
            break;
        }
      });
      if (slide._slideNumberProps) {
        if (!slide._slideNumberProps.align)
          slide._slideNumberProps.align = "left";
        strSlideXml += "<p:sp>";
        strSlideXml += " <p:nvSpPr>";
        strSlideXml += '  <p:cNvPr id="25" name="Slide Number Placeholder 0"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr>';
        strSlideXml += '  <p:nvPr><p:ph type="sldNum" sz="quarter" idx="4294967295"/></p:nvPr>';
        strSlideXml += " </p:nvSpPr>";
        strSlideXml += " <p:spPr>";
        strSlideXml += "<a:xfrm>" + '<a:off x="'.concat(getSmartParseNumber(slide._slideNumberProps.x, "X", slide._presLayout), '" y="').concat(getSmartParseNumber(slide._slideNumberProps.y, "Y", slide._presLayout), '"/>') + '<a:ext cx="'.concat(slide._slideNumberProps.w ? getSmartParseNumber(slide._slideNumberProps.w, "X", slide._presLayout) : "800000", '" cy="').concat(slide._slideNumberProps.h ? getSmartParseNumber(slide._slideNumberProps.h, "Y", slide._presLayout) : "300000", '"/>') + '</a:xfrm> <a:prstGeom prst="rect"><a:avLst/></a:prstGeom> <a:extLst><a:ext uri="{C572A759-6A51-4108-AA02-DFA0A04FC94B}"><ma14:wrappingTextBoxFlag val="0" xmlns:ma14="http://schemas.microsoft.com/office/mac/drawingml/2011/main"/></a:ext></a:extLst></p:spPr>';
        strSlideXml += "<p:txBody>";
        strSlideXml += "<a:bodyPr";
        if (slide._slideNumberProps.margin && Array.isArray(slide._slideNumberProps.margin)) {
          strSlideXml += ' lIns="'.concat(valToPts(slide._slideNumberProps.margin[3] || 0), '"');
          strSlideXml += ' tIns="'.concat(valToPts(slide._slideNumberProps.margin[0] || 0), '"');
          strSlideXml += ' rIns="'.concat(valToPts(slide._slideNumberProps.margin[1] || 0), '"');
          strSlideXml += ' bIns="'.concat(valToPts(slide._slideNumberProps.margin[2] || 0), '"');
        } else if (typeof slide._slideNumberProps.margin === "number") {
          strSlideXml += ' lIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
          strSlideXml += ' tIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
          strSlideXml += ' rIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
          strSlideXml += ' bIns="'.concat(valToPts(slide._slideNumberProps.margin || 0), '"');
        }
        if (slide._slideNumberProps.valign) {
          strSlideXml += ' anchor="'.concat(slide._slideNumberProps.valign.replace("top", "t").replace("middle", "ctr").replace("bottom", "b"), '"');
        }
        strSlideXml += "/>";
        strSlideXml += "  <a:lstStyle><a:lvl1pPr>";
        if (slide._slideNumberProps.fontFace || slide._slideNumberProps.fontSize || slide._slideNumberProps.color) {
          strSlideXml += '<a:defRPr sz="'.concat(Math.round((slide._slideNumberProps.fontSize || 12) * 100), '">');
          if (slide._slideNumberProps.color)
            strSlideXml += genXmlColorSelection(slide._slideNumberProps.color);
          if (slide._slideNumberProps.fontFace) {
            strSlideXml += '<a:latin typeface="'.concat(slide._slideNumberProps.fontFace, '"/><a:ea typeface="').concat(slide._slideNumberProps.fontFace, '"/><a:cs typeface="').concat(slide._slideNumberProps.fontFace, '"/>');
          }
          strSlideXml += "</a:defRPr>";
        }
        strSlideXml += "</a:lvl1pPr></a:lstStyle>";
        strSlideXml += "<a:p>";
        if (slide._slideNumberProps.align.startsWith("l"))
          strSlideXml += '<a:pPr algn="l"/>';
        else if (slide._slideNumberProps.align.startsWith("c"))
          strSlideXml += '<a:pPr algn="ctr"/>';
        else if (slide._slideNumberProps.align.startsWith("r"))
          strSlideXml += '<a:pPr algn="r"/>';
        else
          strSlideXml += '<a:pPr algn="l"/>';
        strSlideXml += '<a:fld id="'.concat(SLDNUMFLDID, '" type="slidenum"><a:rPr b="').concat(slide._slideNumberProps.bold ? 1 : 0, '" lang="en-US"/>');
        strSlideXml += "<a:t>".concat(slide._slideNum, '</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p>');
        strSlideXml += "</p:txBody></p:sp>";
      }
      strSlideXml += "</p:spTree>";
      strSlideXml += "</p:cSld>";
      return strSlideXml;
    }
    function slideObjectRelationsToXml(slide, defaultRels) {
      var lastRid = 0;
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
      slide._rels.forEach(function(rel) {
        lastRid = Math.max(lastRid, rel.rId);
        if (rel.type.toLowerCase().includes("hyperlink")) {
          if (rel.data === "slide") {
            strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slide').concat(rel.Target, '.xml"/>');
          } else {
            strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="').concat(rel.Target, '" TargetMode="External"/>');
          }
        } else if (rel.type.toLowerCase().includes("notesSlide")) {
          strXml += '<Relationship Id="rId'.concat(rel.rId, '" Target="').concat(rel.Target, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide"/>');
        }
      });
      (slide._relsChart || []).forEach(function(rel) {
        lastRid = Math.max(lastRid, rel.rId);
        strXml += '<Relationship Id="rId'.concat(rel.rId, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart" Target="').concat(rel.Target, '"/>');
      });
      (slide._relsMedia || []).forEach(function(rel) {
        var relRid = rel.rId.toString();
        lastRid = Math.max(lastRid, rel.rId);
        if (rel.type.toLowerCase().includes("image")) {
          strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="' + rel.Target + '"/>';
        } else if (rel.type.toLowerCase().includes("audio")) {
          if (strXml.includes(' Target="' + rel.Target + '"')) {
            strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
          } else {
            strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio" Target="' + rel.Target + '"/>';
          }
        } else if (rel.type.toLowerCase().includes("video")) {
          if (strXml.includes(' Target="' + rel.Target + '"')) {
            strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
          } else {
            strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video" Target="' + rel.Target + '"/>';
          }
        } else if (rel.type.toLowerCase().includes("online")) {
          if (strXml.includes(' Target="' + rel.Target + '"')) {
            strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/image" Target="' + rel.Target + '"/>';
          } else {
            strXml += '<Relationship Id="rId' + relRid + '" Target="' + rel.Target + '" TargetMode="External" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video"/>';
          }
        }
      });
      defaultRels.forEach(function(rel, idx) {
        strXml += '<Relationship Id="rId'.concat(lastRid + idx + 1, '" Type="').concat(rel.type, '" Target="').concat(rel.target, '"/>');
      });
      strXml += "</Relationships>";
      return strXml;
    }
    function genXmlParagraphProperties(textObj, isDefault) {
      var _a, _b;
      var strXmlBullet = "";
      var strXmlLnSpc = "";
      var strXmlParaSpc = "";
      var strXmlTabStops = "";
      var tag = isDefault ? "a:lvl1pPr" : "a:pPr";
      var bulletMarL = valToPts(DEF_BULLET_MARGIN);
      var paragraphPropXml = "<".concat(tag).concat(textObj.options.rtlMode ? ' rtl="1" ' : "");
      {
        if (textObj.options.align) {
          switch (textObj.options.align) {
            case "left":
              paragraphPropXml += ' algn="l"';
              break;
            case "right":
              paragraphPropXml += ' algn="r"';
              break;
            case "center":
              paragraphPropXml += ' algn="ctr"';
              break;
            case "justify":
              paragraphPropXml += ' algn="just"';
              break;
            default:
              paragraphPropXml += "";
              break;
          }
        }
        if (textObj.options.lineSpacing) {
          strXmlLnSpc = '<a:lnSpc><a:spcPts val="'.concat(Math.round(textObj.options.lineSpacing * 100), '"/></a:lnSpc>');
        } else if (textObj.options.lineSpacingMultiple) {
          strXmlLnSpc = '<a:lnSpc><a:spcPct val="'.concat(Math.round(textObj.options.lineSpacingMultiple * 1e5), '"/></a:lnSpc>');
        }
        if (textObj.options.indentLevel && !isNaN(Number(textObj.options.indentLevel)) && textObj.options.indentLevel > 0) {
          paragraphPropXml += ' lvl="'.concat(textObj.options.indentLevel, '"');
        }
        if (textObj.options.paraSpaceBefore && !isNaN(Number(textObj.options.paraSpaceBefore)) && textObj.options.paraSpaceBefore > 0) {
          strXmlParaSpc += '<a:spcBef><a:spcPts val="'.concat(Math.round(textObj.options.paraSpaceBefore * 100), '"/></a:spcBef>');
        }
        if (textObj.options.paraSpaceAfter && !isNaN(Number(textObj.options.paraSpaceAfter)) && textObj.options.paraSpaceAfter > 0) {
          strXmlParaSpc += '<a:spcAft><a:spcPts val="'.concat(Math.round(textObj.options.paraSpaceAfter * 100), '"/></a:spcAft>');
        }
        if (typeof textObj.options.bullet === "object") {
          if ((_b = (_a = textObj === null || textObj === void 0 ? void 0 : textObj.options) === null || _a === void 0 ? void 0 : _a.bullet) === null || _b === void 0 ? void 0 : _b.indent)
            bulletMarL = valToPts(textObj.options.bullet.indent);
          if (textObj.options.bullet.type) {
            if (textObj.options.bullet.type.toString().toLowerCase() === "number") {
              paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
              strXmlBullet = '<a:buSzPct val="100000"/><a:buFont typeface="+mj-lt"/><a:buAutoNum type="'.concat(textObj.options.bullet.style || "arabicPeriod", '" startAt="').concat(textObj.options.bullet.numberStartAt || textObj.options.bullet.startAt || "1", '"/>');
            }
          } else if (textObj.options.bullet.characterCode) {
            var bulletCode = "&#x".concat(textObj.options.bullet.characterCode, ";");
            if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.characterCode)) {
              console.warn("Warning: `bullet.characterCode should be a 4-digit unicode charatcer (ex: 22AB)`!");
              bulletCode = BULLET_TYPES.DEFAULT;
            }
            paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
            strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
          } else if (textObj.options.bullet.code) {
            var bulletCode = "&#x".concat(textObj.options.bullet.code, ";");
            if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.code)) {
              console.warn("Warning: `bullet.code should be a 4-digit hex code (ex: 22AB)`!");
              bulletCode = BULLET_TYPES.DEFAULT;
            }
            paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
            strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
          } else {
            paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
            strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="'.concat(BULLET_TYPES.DEFAULT, '"/>');
          }
        } else if (textObj.options.bullet) {
          paragraphPropXml += ' marL="'.concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, '" indent="-').concat(bulletMarL, '"');
          strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="'.concat(BULLET_TYPES.DEFAULT, '"/>');
        } else if (!textObj.options.bullet) {
          paragraphPropXml += ' indent="0" marL="0"';
          strXmlBullet = "<a:buNone/>";
        }
        if (textObj.options.tabStops && Array.isArray(textObj.options.tabStops)) {
          var tabStopsXml = textObj.options.tabStops.map(function(stop) {
            return '<a:tab pos="'.concat(inch2Emu(stop.position || 1), '" algn="').concat(stop.alignment || "l", '"/>');
          }).join("");
          strXmlTabStops = "<a:tabLst>".concat(tabStopsXml, "</a:tabLst>");
        }
        paragraphPropXml += ">" + strXmlLnSpc + strXmlParaSpc + strXmlBullet + strXmlTabStops;
        if (isDefault)
          paragraphPropXml += genXmlTextRunProperties(textObj.options, true);
        paragraphPropXml += "</" + tag + ">";
      }
      return paragraphPropXml;
    }
    function genXmlTextRunProperties(opts, isDefault) {
      var _a;
      var runProps = "";
      var runPropsTag = isDefault ? "a:defRPr" : "a:rPr";
      runProps += "<" + runPropsTag + ' lang="' + (opts.lang ? opts.lang : "en-US") + '"' + (opts.lang ? ' altLang="en-US"' : "");
      runProps += opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "";
      runProps += (opts === null || opts === void 0 ? void 0 : opts.bold) ? ' b="'.concat(opts.bold ? "1" : "0", '"') : "";
      runProps += (opts === null || opts === void 0 ? void 0 : opts.italic) ? ' i="'.concat(opts.italic ? "1" : "0", '"') : "";
      runProps += (opts === null || opts === void 0 ? void 0 : opts.strike) ? ' strike="'.concat(typeof opts.strike === "string" ? opts.strike : "sngStrike", '"') : "";
      if (typeof opts.underline === "object" && ((_a = opts.underline) === null || _a === void 0 ? void 0 : _a.style)) {
        runProps += ' u="'.concat(opts.underline.style, '"');
      } else if (typeof opts.underline === "string") {
        runProps += ' u="'.concat(String(opts.underline), '"');
      } else if (opts.hyperlink) {
        runProps += ' u="sng"';
      }
      if (opts.baseline) {
        runProps += ' baseline="'.concat(Math.round(opts.baseline * 50), '"');
      } else if (opts.subscript) {
        runProps += ' baseline="-40000"';
      } else if (opts.superscript) {
        runProps += ' baseline="30000"';
      }
      runProps += opts.charSpacing ? ' spc="'.concat(Math.round(opts.charSpacing * 100), '" kern="0"') : "";
      runProps += ' dirty="0">';
      if (opts.color || opts.fontFace || opts.outline || typeof opts.underline === "object" && opts.underline.color) {
        if (opts.outline && typeof opts.outline === "object") {
          runProps += '<a:ln w="'.concat(valToPts(opts.outline.size || 0.75), '">').concat(genXmlColorSelection(opts.outline.color || "FFFFFF"), "</a:ln>");
        }
        if (opts.color)
          runProps += genXmlColorSelection({ color: opts.color, transparency: opts.transparency });
        if (opts.highlight)
          runProps += "<a:highlight>".concat(createColorElement(opts.highlight), "</a:highlight>");
        if (typeof opts.underline === "object" && opts.underline.color)
          runProps += "<a:uFill>".concat(genXmlColorSelection(opts.underline.color), "</a:uFill>");
        if (opts.glow)
          runProps += "<a:effectLst>".concat(createGlowElement(opts.glow, DEF_TEXT_GLOW), "</a:effectLst>");
        if (opts.fontFace) {
          runProps += '<a:latin typeface="'.concat(opts.fontFace, '" pitchFamily="34" charset="0"/><a:ea typeface="').concat(opts.fontFace, '" pitchFamily="34" charset="-122"/><a:cs typeface="').concat(opts.fontFace, '" pitchFamily="34" charset="-120"/>');
        }
      }
      if (opts.hyperlink) {
        if (typeof opts.hyperlink !== "object")
          throw new Error("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink:{url:'https://github.com'}` ");
        else if (!opts.hyperlink.url && !opts.hyperlink.slide)
          throw new Error("ERROR: 'hyperlink requires either `url` or `slide`'");
        else if (opts.hyperlink.url) {
          runProps += '<a:hlinkClick r:id="rId'.concat(opts.hyperlink._rId, '" invalidUrl="" action="" tgtFrame="" tooltip="').concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : "", '" history="1" highlightClick="0" endSnd="0"').concat(opts.color ? ">" : "/>");
        } else if (opts.hyperlink.slide) {
          runProps += '<a:hlinkClick r:id="rId'.concat(opts.hyperlink._rId, '" action="ppaction://hlinksldjump" tooltip="').concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : "", '"').concat(opts.color ? ">" : "/>");
        }
        if (opts.color) {
          runProps += " <a:extLst>";
          runProps += '  <a:ext uri="{A12FA001-AC4F-418D-AE19-62706E023703}">';
          runProps += '   <ahyp:hlinkClr xmlns:ahyp="http://schemas.microsoft.com/office/drawing/2018/hyperlinkcolor" val="tx"/>';
          runProps += "  </a:ext>";
          runProps += " </a:extLst>";
          runProps += "</a:hlinkClick>";
        }
      }
      runProps += "</".concat(runPropsTag, ">");
      return runProps;
    }
    function genXmlTextRun(textObj) {
      return textObj.text ? "<a:r>".concat(genXmlTextRunProperties(textObj.options, false), "<a:t>").concat(encodeXmlEntities(textObj.text), "</a:t></a:r>") : "";
    }
    function genXmlBodyProperties(slideObject) {
      var bodyProperties = "<a:bodyPr";
      if (slideObject && slideObject._type === SLIDE_OBJECT_TYPES.text && slideObject.options._bodyProp) {
        bodyProperties += slideObject.options._bodyProp.wrap ? ' wrap="square"' : ' wrap="none"';
        if (slideObject.options._bodyProp.lIns || slideObject.options._bodyProp.lIns === 0)
          bodyProperties += ' lIns="'.concat(slideObject.options._bodyProp.lIns, '"');
        if (slideObject.options._bodyProp.tIns || slideObject.options._bodyProp.tIns === 0)
          bodyProperties += ' tIns="'.concat(slideObject.options._bodyProp.tIns, '"');
        if (slideObject.options._bodyProp.rIns || slideObject.options._bodyProp.rIns === 0)
          bodyProperties += ' rIns="'.concat(slideObject.options._bodyProp.rIns, '"');
        if (slideObject.options._bodyProp.bIns || slideObject.options._bodyProp.bIns === 0)
          bodyProperties += ' bIns="'.concat(slideObject.options._bodyProp.bIns, '"');
        bodyProperties += ' rtlCol="0"';
        if (slideObject.options._bodyProp.anchor)
          bodyProperties += ' anchor="' + slideObject.options._bodyProp.anchor + '"';
        if (slideObject.options._bodyProp.vert)
          bodyProperties += ' vert="' + slideObject.options._bodyProp.vert + '"';
        bodyProperties += ">";
        if (slideObject.options.fit) {
          if (slideObject.options.fit === "none")
            bodyProperties += "";
          else if (slideObject.options.fit === "shrink")
            bodyProperties += "<a:normAutofit/>";
          else if (slideObject.options.fit === "resize")
            bodyProperties += "<a:spAutoFit/>";
        }
        if (slideObject.options.shrinkText)
          bodyProperties += "<a:normAutofit/>";
        bodyProperties += slideObject.options._bodyProp.autoFit ? "<a:spAutoFit/>" : "";
        bodyProperties += "</a:bodyPr>";
      } else {
        bodyProperties += ' wrap="square" rtlCol="0">';
        bodyProperties += "</a:bodyPr>";
      }
      return slideObject._type === SLIDE_OBJECT_TYPES.tablecell ? "<a:bodyPr/>" : bodyProperties;
    }
    function genXmlTextBody(slideObj) {
      var opts = slideObj.options || {};
      var tmpTextObjects = [];
      var arrTextObjects = [];
      if (opts && slideObj._type !== SLIDE_OBJECT_TYPES.tablecell && (typeof slideObj.text === "undefined" || slideObj.text === null))
        return "";
      var strSlideXml = slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? "<a:txBody>" : "<p:txBody>";
      {
        strSlideXml += genXmlBodyProperties(slideObj);
        if (opts.h === 0 && opts.line && opts.align)
          strSlideXml += '<a:lstStyle><a:lvl1pPr algn="l"/></a:lstStyle>';
        else if (slideObj._type === "placeholder")
          strSlideXml += "<a:lstStyle>".concat(genXmlParagraphProperties(slideObj, true), "</a:lstStyle>");
        else
          strSlideXml += "<a:lstStyle/>";
      }
      if (typeof slideObj.text === "string" || typeof slideObj.text === "number") {
        tmpTextObjects.push({ text: slideObj.text.toString(), options: opts || {} });
      } else if (slideObj.text && !Array.isArray(slideObj.text) && typeof slideObj.text === "object" && Object.keys(slideObj.text).includes("text")) {
        tmpTextObjects.push({ text: slideObj.text || "", options: slideObj.options || {} });
      } else if (Array.isArray(slideObj.text)) {
        tmpTextObjects = slideObj.text.map(function(item) {
          return { text: item.text, options: item.options };
        });
      }
      tmpTextObjects.forEach(function(itext, idx) {
        if (!itext.text)
          itext.text = "";
        itext.options = itext.options || opts || {};
        if (idx === 0 && itext.options && !itext.options.bullet && opts.bullet)
          itext.options.bullet = opts.bullet;
        if (typeof itext.text === "string" || typeof itext.text === "number") {
          itext.text = itext.text.toString().replace(/\r*\n/g, CRLF);
        }
        if (itext.text.includes(CRLF) && itext.text.match(/\n$/g) === null) {
          itext.text.split(CRLF).forEach(function(line) {
            itext.options.breakLine = true;
            arrTextObjects.push({ text: line, options: itext.options });
          });
        } else {
          arrTextObjects.push(itext);
        }
      });
      var arrLines = [];
      var arrTexts = [];
      arrTextObjects.forEach(function(textObj, idx) {
        if (arrTexts.length > 0 && (textObj.options.align || opts.align)) {
          if (textObj.options.align !== arrTextObjects[idx - 1].options.align) {
            arrLines.push(arrTexts);
            arrTexts = [];
          }
        } else if (arrTexts.length > 0 && textObj.options.bullet && arrTexts.length > 0) {
          arrLines.push(arrTexts);
          arrTexts = [];
          textObj.options.breakLine = false;
        }
        arrTexts.push(textObj);
        if (arrTexts.length > 0 && textObj.options.breakLine) {
          if (idx + 1 < arrTextObjects.length) {
            arrLines.push(arrTexts);
            arrTexts = [];
          }
        }
        if (idx + 1 === arrTextObjects.length)
          arrLines.push(arrTexts);
      });
      arrLines.forEach(function(line) {
        var _a;
        var reqsClosingFontSize = false;
        strSlideXml += "<a:p>";
        var paragraphPropXml = "<a:pPr ".concat(((_a = line[0].options) === null || _a === void 0 ? void 0 : _a.rtlMode) ? ' rtl="1" ' : "");
        line.forEach(function(textObj, idx) {
          textObj.options._lineIdx = idx;
          if (idx > 0 && textObj.options.softBreakBefore) {
            strSlideXml += "<a:br/>";
          }
          textObj.options.align = textObj.options.align || opts.align;
          textObj.options.lineSpacing = textObj.options.lineSpacing || opts.lineSpacing;
          textObj.options.lineSpacingMultiple = textObj.options.lineSpacingMultiple || opts.lineSpacingMultiple;
          textObj.options.indentLevel = textObj.options.indentLevel || opts.indentLevel;
          textObj.options.paraSpaceBefore = textObj.options.paraSpaceBefore || opts.paraSpaceBefore;
          textObj.options.paraSpaceAfter = textObj.options.paraSpaceAfter || opts.paraSpaceAfter;
          paragraphPropXml = genXmlParagraphProperties(textObj, false);
          strSlideXml += paragraphPropXml.replace("<a:pPr></a:pPr>", "");
          Object.entries(opts).filter(function(_a2) {
            var key = _a2[0];
            _a2[1];
            return !(textObj.options.hyperlink && key === "color");
          }).forEach(function(_a2) {
            var key = _a2[0], val = _a2[1];
            if (key !== "bullet" && !textObj.options[key])
              textObj.options[key] = val;
          });
          strSlideXml += genXmlTextRun(textObj);
          if (!textObj.text && opts.fontSize || textObj.options.fontSize) {
            reqsClosingFontSize = true;
            opts.fontSize = opts.fontSize || textObj.options.fontSize;
          }
        });
        if (slideObj._type === SLIDE_OBJECT_TYPES.tablecell && (opts.fontSize || opts.fontFace)) {
          if (opts.fontFace) {
            strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0">';
            strSlideXml += '<a:latin typeface="'.concat(opts.fontFace, '" charset="0"/>');
            strSlideXml += '<a:ea typeface="'.concat(opts.fontFace, '" charset="0"/>');
            strSlideXml += '<a:cs typeface="'.concat(opts.fontFace, '" charset="0"/>');
            strSlideXml += "</a:endParaRPr>";
          } else {
            strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0"/>';
          }
        } else if (reqsClosingFontSize) {
          strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '"') + (opts.fontSize ? ' sz="'.concat(Math.round(opts.fontSize * 100), '"') : "") + ' dirty="0"/>';
        } else {
          strSlideXml += '<a:endParaRPr lang="'.concat(opts.lang || "en-US", '" dirty="0"/>');
        }
        strSlideXml += "</a:p>";
      });
      strSlideXml += slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? "</a:txBody>" : "</p:txBody>";
      return strSlideXml;
    }
    function genXmlPlaceholder(placeholderObj) {
      var _a, _b;
      if (!placeholderObj)
        return "";
      var placeholderIdx = ((_a = placeholderObj.options) === null || _a === void 0 ? void 0 : _a._placeholderIdx) ? placeholderObj.options._placeholderIdx : "";
      var placeholderTyp = ((_b = placeholderObj.options) === null || _b === void 0 ? void 0 : _b._placeholderType) ? placeholderObj.options._placeholderType : "";
      var placeholderType = placeholderTyp && PLACEHOLDER_TYPES[placeholderTyp] ? PLACEHOLDER_TYPES[placeholderTyp].toString() : "";
      return "<p:ph\n		".concat(placeholderIdx ? ' idx="' + placeholderIdx.toString() + '"' : "", "\n		").concat(placeholderType && PLACEHOLDER_TYPES[placeholderType] ? ' type="'.concat(placeholderType, '"') : "", "\n		").concat(placeholderObj.text && placeholderObj.text.length > 0 ? ' hasCustomPrompt="1"' : "", "\n		/>");
    }
    function makeXmlContTypes(slides, slideLayouts, masterSlide) {
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml += '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
      strXml += '<Default Extension="xml" ContentType="application/xml"/>';
      strXml += '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>';
      strXml += '<Default Extension="jpeg" ContentType="image/jpeg"/>';
      strXml += '<Default Extension="jpg" ContentType="image/jpg"/>';
      strXml += '<Default Extension="svg" ContentType="image/svg+xml"/>';
      strXml += '<Default Extension="png" ContentType="image/png"/>';
      strXml += '<Default Extension="gif" ContentType="image/gif"/>';
      strXml += '<Default Extension="m4v" ContentType="video/mp4"/>';
      strXml += '<Default Extension="mp4" ContentType="video/mp4"/>';
      slides.forEach(function(slide) {
        (slide._relsMedia || []).forEach(function(rel) {
          if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !strXml.includes(rel.type)) {
            strXml += '<Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
          }
        });
      });
      strXml += '<Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>';
      strXml += '<Default Extension="xlsx" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"/>';
      strXml += '<Override PartName="/ppt/presentation.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>';
      strXml += '<Override PartName="/ppt/notesMasters/notesMaster1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml"/>';
      slides.forEach(function(slide, idx) {
        strXml += '<Override PartName="/ppt/slideMasters/slideMaster'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"/>');
        strXml += '<Override PartName="/ppt/slides/slide'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slide+xml"/>');
        slide._relsChart.forEach(function(rel) {
          strXml += '<Override PartName="'.concat(rel.Target, '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>');
        });
      });
      strXml += '<Override PartName="/ppt/presProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presProps+xml"/>';
      strXml += '<Override PartName="/ppt/viewProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml"/>';
      strXml += '<Override PartName="/ppt/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>';
      strXml += '<Override PartName="/ppt/tableStyles.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml"/>';
      slideLayouts.forEach(function(layout, idx) {
        strXml += '<Override PartName="/ppt/slideLayouts/slideLayout'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"/>');
        (layout._relsChart || []).forEach(function(rel) {
          strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
        });
      });
      slides.forEach(function(_slide, idx) {
        strXml += '<Override PartName="/ppt/notesSlides/notesSlide'.concat(idx + 1, '.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml"/>');
      });
      masterSlide._relsChart.forEach(function(rel) {
        strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
      });
      masterSlide._relsMedia.forEach(function(rel) {
        if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !strXml.includes(rel.type)) {
          strXml += ' <Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
        }
      });
      strXml += ' <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>';
      strXml += ' <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>';
      strXml += "</Types>";
      return strXml;
    }
    function makeXmlRootRels() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n		<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>\n		<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>\n		<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="ppt/presentation.xml"/>\n		</Relationships>');
    }
    function makeXmlApp(slides, company) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">\n	<TotalTime>0</TotalTime>\n	<Words>0</Words>\n	<Application>Microsoft Office PowerPoint</Application>\n	<PresentationFormat>On-screen Show (16:9)</PresentationFormat>\n	<Paragraphs>0</Paragraphs>\n	<Slides>').concat(slides.length, "</Slides>\n	<Notes>").concat(slides.length, '</Notes>\n	<HiddenSlides>0</HiddenSlides>\n	<MMClips>0</MMClips>\n	<ScaleCrop>false</ScaleCrop>\n	<HeadingPairs>\n		<vt:vector size="6" baseType="variant">\n			<vt:variant><vt:lpstr>Fonts Used</vt:lpstr></vt:variant>\n			<vt:variant><vt:i4>2</vt:i4></vt:variant>\n			<vt:variant><vt:lpstr>Theme</vt:lpstr></vt:variant>\n			<vt:variant><vt:i4>1</vt:i4></vt:variant>\n			<vt:variant><vt:lpstr>Slide Titles</vt:lpstr></vt:variant>\n			<vt:variant><vt:i4>').concat(slides.length, '</vt:i4></vt:variant>\n		</vt:vector>\n	</HeadingPairs>\n	<TitlesOfParts>\n		<vt:vector size="').concat(slides.length + 1 + 2, '" baseType="lpstr">\n			<vt:lpstr>Arial</vt:lpstr>\n			<vt:lpstr>Calibri</vt:lpstr>\n			<vt:lpstr>Office Theme</vt:lpstr>\n			').concat(slides.map(function(_slideObj, idx) {
        return "<vt:lpstr>Slide ".concat(idx + 1, "</vt:lpstr>");
      }).join(""), "\n		</vt:vector>\n	</TitlesOfParts>\n	<Company>").concat(company, "</Company>\n	<LinksUpToDate>false</LinksUpToDate>\n	<SharedDoc>false</SharedDoc>\n	<HyperlinksChanged>false</HyperlinksChanged>\n	<AppVersion>16.0000</AppVersion>\n	</Properties>");
    }
    function makeXmlCore(title, subject, author, revision) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n	<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n		<dc:title>'.concat(encodeXmlEntities(title), "</dc:title>\n		<dc:subject>").concat(encodeXmlEntities(subject), "</dc:subject>\n		<dc:creator>").concat(encodeXmlEntities(author), "</dc:creator>\n		<cp:lastModifiedBy>").concat(encodeXmlEntities(author), "</cp:lastModifiedBy>\n		<cp:revision>").concat(revision, '</cp:revision>\n		<dcterms:created xsi:type="dcterms:W3CDTF">').concat((/* @__PURE__ */ new Date()).toISOString().replace(/\.\d\d\dZ/, "Z"), '</dcterms:created>\n		<dcterms:modified xsi:type="dcterms:W3CDTF">').concat((/* @__PURE__ */ new Date()).toISOString().replace(/\.\d\d\dZ/, "Z"), "</dcterms:modified>\n	</cp:coreProperties>");
    }
    function makeXmlPresentationRels(slides) {
      var intRelNum = 1;
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml += '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
      strXml += '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="slideMasters/slideMaster1.xml"/>';
      for (var idx = 1; idx <= slides.length; idx++) {
        strXml += '<Relationship Id="rId'.concat(++intRelNum, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="slides/slide').concat(idx, '.xml"/>');
      }
      intRelNum++;
      strXml += '<Relationship Id="rId'.concat(intRelNum + 0, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster" Target="notesMasters/notesMaster1.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 1, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps" Target="presProps.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 2, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps" Target="viewProps.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 3, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/>') + '<Relationship Id="rId'.concat(intRelNum + 4, '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles" Target="tableStyles.xml"/>') + "</Relationships>";
      return strXml;
    }
    function makeXmlSlide(slide) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF) + '<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"' + "".concat((slide === null || slide === void 0 ? void 0 : slide.hidden) ? ' show="0"' : "", ">") + "".concat(slideObjectToXml(slide)) + "<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sld>";
    }
    function getNotesFromSlide(slide) {
      var notesText = "";
      slide._slideObjects.forEach(function(data) {
        if (data._type === SLIDE_OBJECT_TYPES.notes)
          notesText += (data === null || data === void 0 ? void 0 : data.text) && data.text[0] ? data.text[0].text : "";
      });
      return notesText.replace(/\r*\n/g, CRLF);
    }
    function makeXmlNotesMaster() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:notesMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Header Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="hdr" sz="quarter"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Date Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="dt" idx="1"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{5282F153-3F37-0F45-9E97-73ACFA13230C}" type="datetimeFigureOut"><a:rPr lang="en-US"/><a:t>7/23/19</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Image Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg" idx="2"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="1143000"/><a:ext cx="5486400" cy="3086100"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/><a:ln w="12700"><a:solidFill><a:prstClr val="black"/></a:solidFill></a:ln></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr"/><a:lstStyle/><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Notes Placeholder 4"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" sz="quarter" idx="3"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="4400550"/><a:ext cx="5486400" cy="3600450"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle/><a:p><a:pPr lvl="0"/><a:r><a:rPr lang="en-US"/><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1"/><a:r><a:rPr lang="en-US"/><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2"/><a:r><a:rPr lang="en-US"/><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3"/><a:r><a:rPr lang="en-US"/><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4"/><a:r><a:rPr lang="en-US"/><a:t>Fifth level</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="4"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="5"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{CE5E9CC1-C706-0F49-92D6-E571CC5EEA8F}" type="slidenum"><a:rPr lang="en-US"/><a:t>\u2039#\u203A</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/><p:notesStyle><a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr><a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr><a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr><a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr></p:notesStyle></p:notesMaster>');
    }
    function makeXmlNotesSlide(slide) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:notes xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Slide Image Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg"/></p:nvPr></p:nvSpPr><p:spPr/></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Notes Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:r><a:rPr lang="en-US" dirty="0"/><a:t>').concat(encodeXmlEntities(getNotesFromSlide(slide)), '</a:t></a:r><a:endParaRPr lang="en-US" dirty="0"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Number Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="10"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:fld id="').concat(SLDNUMFLDID, '" type="slidenum"><a:rPr lang="en-US"/><a:t>').concat(slide._slideNum, '</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:notes>');
    }
    function makeXmlLayout(layout) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n		<p:sldLayout xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" preserve="1">\n		'.concat(slideObjectToXml(layout), "\n		<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sldLayout>");
    }
    function makeXmlMaster(slide, layouts) {
      var layoutDefs = layouts.map(function(_layoutDef, idx) {
        return '<p:sldLayoutId id="'.concat(LAYOUT_IDX_SERIES_BASE + idx, '" r:id="rId').concat(slide._rels.length + idx + 1, '"/>');
      });
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml += '<p:sldMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">';
      strXml += slideObjectToXml(slide);
      strXml += '<p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/>';
      strXml += "<p:sldLayoutIdLst>" + layoutDefs.join("") + "</p:sldLayoutIdLst>";
      strXml += '<p:hf sldNum="0" hdr="0" ftr="0" dt="0"/>';
      strXml += '<p:txStyles> <p:titleStyle>  <a:lvl1pPr algn="ctr" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="0"/></a:spcBef><a:buNone/><a:defRPr sz="4400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mj-lt"/><a:ea typeface="+mj-ea"/><a:cs typeface="+mj-cs"/></a:defRPr></a:lvl1pPr> </p:titleStyle> <p:bodyStyle>  <a:lvl1pPr marL="342900" indent="-342900" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="3200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>  <a:lvl2pPr marL="742950" indent="-285750" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2013"/><a:defRPr sz="2800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>  <a:lvl3pPr marL="1143000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>  <a:lvl4pPr marL="1600200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2013"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>  <a:lvl5pPr marL="2057400" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\xBB"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>  <a:lvl6pPr marL="2514600" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>  <a:lvl7pPr marL="2971800" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>  <a:lvl8pPr marL="3429000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>  <a:lvl9pPr marL="3886200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr> </p:bodyStyle> <p:otherStyle>  <a:defPPr><a:defRPr lang="en-US"/></a:defPPr>  <a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>  <a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>  <a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>  <a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>  <a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>  <a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>  <a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>  <a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>  <a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr> </p:otherStyle></p:txStyles>';
      strXml += "</p:sldMaster>";
      return strXml;
    }
    function makeXmlSlideLayoutRel(layoutNumber, slideLayouts) {
      return slideObjectRelationsToXml(slideLayouts[layoutNumber - 1], [
        {
          target: "../slideMasters/slideMaster1.xml",
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster"
        }
      ]);
    }
    function makeXmlSlideRel(slides, slideLayouts, slideNumber) {
      return slideObjectRelationsToXml(slides[slideNumber - 1], [
        {
          target: "../slideLayouts/slideLayout".concat(getLayoutIdxForSlide(slides, slideLayouts, slideNumber), ".xml"),
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
        },
        {
          target: "../notesSlides/notesSlide".concat(slideNumber, ".xml"),
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide"
        }
      ]);
    }
    function makeXmlNotesSlideRel(slideNumber) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n		<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n			<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster" Target="../notesMasters/notesMaster1.xml"/>\n			<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide" Target="../slides/slide'.concat(slideNumber, '.xml"/>\n		</Relationships>');
    }
    function makeXmlMasterRel(masterSlide, slideLayouts) {
      var defaultRels = slideLayouts.map(function(_layoutDef, idx) {
        return {
          target: "../slideLayouts/slideLayout".concat(idx + 1, ".xml"),
          type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
        };
      });
      defaultRels.push({ target: "../theme/theme1.xml", type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" });
      return slideObjectRelationsToXml(masterSlide, defaultRels);
    }
    function makeXmlNotesMasterRel() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n		<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="../theme/theme1.xml"/>\n		</Relationships>');
    }
    function getLayoutIdxForSlide(slides, slideLayouts, slideNumber) {
      for (var i = 0; i < slideLayouts.length; i++) {
        if (slideLayouts[i]._name === slides[slideNumber - 1]._slideLayout._name) {
          return i + 1;
        }
      }
      return 1;
    }
    function makeXmlTheme(pres) {
      var _a, _b, _c, _d;
      var majorFont = ((_a = pres.theme) === null || _a === void 0 ? void 0 : _a.headFontFace) ? '<a:latin typeface="'.concat((_b = pres.theme) === null || _b === void 0 ? void 0 : _b.headFontFace, '"/>') : '<a:latin typeface="Calibri Light" panose="020F0302020204030204"/>';
      var minorFont = ((_c = pres.theme) === null || _c === void 0 ? void 0 : _c.bodyFontFace) ? '<a:latin typeface="'.concat((_d = pres.theme) === null || _d === void 0 ? void 0 : _d.bodyFontFace, '"/>') : '<a:latin typeface="Calibri" panose="020F0502020204030204"/>';
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont>'.concat(majorFont, '<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF Light"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF Light"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Angsana New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont>').concat(minorFont, '<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Cordia New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>');
    }
    function makeXmlPresentation(pres) {
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF) + '<p:presentation xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ' + 'xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" '.concat(pres.rtlMode ? 'rtl="1"' : "", ' saveSubsetFonts="1" autoCompressPictures="0">');
      strXml += '<p:sldMasterIdLst><p:sldMasterId id="2147483648" r:id="rId1"/></p:sldMasterIdLst>';
      strXml += "<p:sldIdLst>";
      pres.slides.forEach(function(slide) {
        return strXml += '<p:sldId id="'.concat(slide._slideId, '" r:id="rId').concat(slide._rId, '"/>');
      });
      strXml += "</p:sldIdLst>";
      strXml += '<p:notesMasterIdLst><p:notesMasterId r:id="rId'.concat(pres.slides.length + 2, '"/></p:notesMasterIdLst>');
      strXml += '<p:sldSz cx="'.concat(pres.presLayout.width, '" cy="').concat(pres.presLayout.height, '"/>');
      strXml += '<p:notesSz cx="'.concat(pres.presLayout.height, '" cy="').concat(pres.presLayout.width, '"/>');
      strXml += "<p:defaultTextStyle>";
      for (var idy = 1; idy < 10; idy++) {
        strXml += "<a:lvl".concat(idy, 'pPr marL="').concat((idy - 1) * 457200, '" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1">') + '<a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/>' + "</a:defRPr></a:lvl".concat(idy, "pPr>");
      }
      strXml += "</p:defaultTextStyle>";
      if (pres.sections && pres.sections.length > 0) {
        strXml += '<p:extLst><p:ext uri="{521415D9-36F7-43E2-AB2F-B90AF26B5E84}">';
        strXml += '<p14:sectionLst xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main">';
        pres.sections.forEach(function(sect) {
          strXml += '<p14:section name="'.concat(encodeXmlEntities(sect.title), '" id="{').concat(getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"), '}"><p14:sldIdLst>');
          sect._slides.forEach(function(slide) {
            return strXml += '<p14:sldId id="'.concat(slide._slideId, '"/>');
          });
          strXml += "</p14:sldIdLst></p14:section>";
        });
        strXml += "</p14:sectionLst></p:ext>";
        strXml += '<p:ext uri="{EFAFB233-063F-42B5-8137-9DF3F51BA10A}"><p15:sldGuideLst xmlns:p15="http://schemas.microsoft.com/office/powerpoint/2012/main"/></p:ext>';
        strXml += "</p:extLst>";
      }
      strXml += "</p:presentation>";
      return strXml;
    }
    function makeXmlPresProps() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:presentationPr xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"/>');
    }
    function makeXmlTableStyles() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<a:tblStyleLst xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" def="{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}"/>');
    }
    function makeXmlViewProps() {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'.concat(CRLF, '<p:viewPr xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:normalViewPr horzBarState="maximized"><p:restoredLeft sz="15611"/><p:restoredTop sz="94610"/></p:normalViewPr><p:slideViewPr><p:cSldViewPr snapToGrid="0" snapToObjects="1"><p:cViewPr varScale="1"><p:scale><a:sx n="136" d="100"/><a:sy n="136" d="100"/></p:scale><p:origin x="216" y="312"/></p:cViewPr><p:guideLst/></p:cSldViewPr></p:slideViewPr><p:notesTextViewPr><p:cViewPr><p:scale><a:sx n="1" d="1"/><a:sy n="1" d="1"/></p:scale><p:origin x="0" y="0"/></p:cViewPr></p:notesTextViewPr><p:gridSpacing cx="76200" cy="76200"/></p:viewPr>');
    }
    var VERSION = "3.12.0";
    var PptxGenJS = (
      /** @class */
      function() {
        function PptxGenJS2() {
          var _this = this;
          this._version = VERSION;
          this._alignH = AlignH;
          this._alignV = AlignV;
          this._chartType = ChartType;
          this._outputType = OutputType;
          this._schemeColor = SchemeColor;
          this._shapeType = ShapeType;
          this._charts = CHART_TYPE;
          this._colors = SCHEME_COLOR_NAMES;
          this._shapes = SHAPE_TYPE;
          this.addNewSlide = function(options) {
            var sectAlreadyInUse = _this.sections.length > 0 && _this.sections[_this.sections.length - 1]._slides.filter(function(slide) {
              return slide._slideNum === _this.slides[_this.slides.length - 1]._slideNum;
            }).length > 0;
            options.sectionTitle = sectAlreadyInUse ? _this.sections[_this.sections.length - 1].title : null;
            return _this.addSlide(options);
          };
          this.getSlide = function(slideNum) {
            return _this.slides.filter(function(slide) {
              return slide._slideNum === slideNum;
            })[0];
          };
          this.setSlideNumber = function(slideNum) {
            _this.masterSlide._slideNumberProps = slideNum;
            _this.slideLayouts.filter(function(layout) {
              return layout._name === DEF_PRES_LAYOUT_NAME;
            })[0]._slideNumberProps = slideNum;
          };
          this.createChartMediaRels = function(slide, zip, chartPromises) {
            slide._relsChart.forEach(function(rel) {
              return chartPromises.push(createExcelWorksheet(rel, zip));
            });
            slide._relsMedia.forEach(function(rel) {
              if (rel.type !== "online" && rel.type !== "hyperlink") {
                var data = rel.data && typeof rel.data === "string" ? rel.data : "";
                if (!data.includes(",") && !data.includes(";"))
                  data = "image/png;base64," + data;
                else if (!data.includes(","))
                  data = "image/png;base64," + data;
                else if (!data.includes(";"))
                  data = "image/png;" + data;
                zip.file(rel.Target.replace("..", "ppt"), data.split(",").pop(), { base64: true });
              }
            });
          };
          this.writeFileToBrowser = function(exportName, blobContent) {
            return __awaiter(_this, void 0, void 0, function() {
              var eleLink, url_1;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    eleLink = document.createElement("a");
                    eleLink.setAttribute("style", "display:none;");
                    eleLink.dataset.interception = "off";
                    document.body.appendChild(eleLink);
                    if (!window.URL.createObjectURL) return [3, 2];
                    url_1 = window.URL.createObjectURL(new Blob([blobContent], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" }));
                    eleLink.href = url_1;
                    eleLink.download = exportName;
                    eleLink.click();
                    setTimeout(function() {
                      window.URL.revokeObjectURL(url_1);
                      document.body.removeChild(eleLink);
                    }, 100);
                    return [4, Promise.resolve(exportName)];
                  case 1:
                    return [2, _a.sent()];
                  case 2:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          };
          this.exportPresentation = function(props) {
            return __awaiter(_this, void 0, void 0, function() {
              var arrChartPromises, arrMediaPromises, zip;
              var _this2 = this;
              return __generator(this, function(_a) {
                switch (_a.label) {
                  case 0:
                    arrChartPromises = [];
                    arrMediaPromises = [];
                    zip = new JSZip__default["default"]();
                    this.slides.forEach(function(slide) {
                      arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(slide));
                    });
                    this.slideLayouts.forEach(function(layout) {
                      arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(layout));
                    });
                    arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(this.masterSlide));
                    return [4, Promise.all(arrMediaPromises).then(function() {
                      return __awaiter(_this2, void 0, void 0, function() {
                        var _this3 = this;
                        return __generator(this, function(_a2) {
                          switch (_a2.label) {
                            case 0:
                              this.slides.forEach(function(slide) {
                                if (slide._slideLayout)
                                  addPlaceholdersToSlideLayouts(slide);
                              });
                              zip.folder("_rels");
                              zip.folder("docProps");
                              zip.folder("ppt").folder("_rels");
                              zip.folder("ppt/charts").folder("_rels");
                              zip.folder("ppt/embeddings");
                              zip.folder("ppt/media");
                              zip.folder("ppt/slideLayouts").folder("_rels");
                              zip.folder("ppt/slideMasters").folder("_rels");
                              zip.folder("ppt/slides").folder("_rels");
                              zip.folder("ppt/theme");
                              zip.folder("ppt/notesMasters").folder("_rels");
                              zip.folder("ppt/notesSlides").folder("_rels");
                              zip.file("[Content_Types].xml", makeXmlContTypes(this.slides, this.slideLayouts, this.masterSlide));
                              zip.file("_rels/.rels", makeXmlRootRels());
                              zip.file("docProps/app.xml", makeXmlApp(this.slides, this.company));
                              zip.file("docProps/core.xml", makeXmlCore(this.title, this.subject, this.author, this.revision));
                              zip.file("ppt/_rels/presentation.xml.rels", makeXmlPresentationRels(this.slides));
                              zip.file("ppt/theme/theme1.xml", makeXmlTheme(this));
                              zip.file("ppt/presentation.xml", makeXmlPresentation(this));
                              zip.file("ppt/presProps.xml", makeXmlPresProps());
                              zip.file("ppt/tableStyles.xml", makeXmlTableStyles());
                              zip.file("ppt/viewProps.xml", makeXmlViewProps());
                              this.slideLayouts.forEach(function(layout, idx) {
                                zip.file("ppt/slideLayouts/slideLayout".concat(idx + 1, ".xml"), makeXmlLayout(layout));
                                zip.file("ppt/slideLayouts/_rels/slideLayout".concat(idx + 1, ".xml.rels"), makeXmlSlideLayoutRel(idx + 1, _this3.slideLayouts));
                              });
                              this.slides.forEach(function(slide, idx) {
                                zip.file("ppt/slides/slide".concat(idx + 1, ".xml"), makeXmlSlide(slide));
                                zip.file("ppt/slides/_rels/slide".concat(idx + 1, ".xml.rels"), makeXmlSlideRel(_this3.slides, _this3.slideLayouts, idx + 1));
                                zip.file("ppt/notesSlides/notesSlide".concat(idx + 1, ".xml"), makeXmlNotesSlide(slide));
                                zip.file("ppt/notesSlides/_rels/notesSlide".concat(idx + 1, ".xml.rels"), makeXmlNotesSlideRel(idx + 1));
                              });
                              zip.file("ppt/slideMasters/slideMaster1.xml", makeXmlMaster(this.masterSlide, this.slideLayouts));
                              zip.file("ppt/slideMasters/_rels/slideMaster1.xml.rels", makeXmlMasterRel(this.masterSlide, this.slideLayouts));
                              zip.file("ppt/notesMasters/notesMaster1.xml", makeXmlNotesMaster());
                              zip.file("ppt/notesMasters/_rels/notesMaster1.xml.rels", makeXmlNotesMasterRel());
                              this.slideLayouts.forEach(function(layout) {
                                _this3.createChartMediaRels(layout, zip, arrChartPromises);
                              });
                              this.slides.forEach(function(slide) {
                                _this3.createChartMediaRels(slide, zip, arrChartPromises);
                              });
                              this.createChartMediaRels(this.masterSlide, zip, arrChartPromises);
                              return [4, Promise.all(arrChartPromises).then(function() {
                                return __awaiter(_this3, void 0, void 0, function() {
                                  return __generator(this, function(_a3) {
                                    switch (_a3.label) {
                                      case 0:
                                        if (!(props.outputType === "STREAM")) return [3, 2];
                                        return [4, zip.generateAsync({ type: "nodebuffer", compression: props.compression ? "DEFLATE" : "STORE" })];
                                      case 1:
                                        return [2, _a3.sent()];
                                      case 2:
                                        if (!props.outputType) return [3, 4];
                                        return [4, zip.generateAsync({ type: props.outputType })];
                                      case 3:
                                        return [2, _a3.sent()];
                                      case 4:
                                        return [4, zip.generateAsync({ type: "blob", compression: props.compression ? "DEFLATE" : "STORE" })];
                                      case 5:
                                        return [2, _a3.sent()];
                                    }
                                  });
                                });
                              })];
                            case 1:
                              return [2, _a2.sent()];
                          }
                        });
                      });
                    })];
                  case 1:
                    return [2, _a.sent()];
                }
              });
            });
          };
          var layout4x3 = { name: "screen4x3", width: 9144e3, height: 6858e3 };
          var layout16x9 = { name: "screen16x9", width: 9144e3, height: 5143500 };
          var layout16x10 = { name: "screen16x10", width: 9144e3, height: 5715e3 };
          var layoutWide = { name: "custom", width: 12192e3, height: 6858e3 };
          this.LAYOUTS = {
            LAYOUT_4x3: layout4x3,
            LAYOUT_16x9: layout16x9,
            LAYOUT_16x10: layout16x10,
            LAYOUT_WIDE: layoutWide
          };
          this._author = "PptxGenJS";
          this._company = "PptxGenJS";
          this._revision = "1";
          this._subject = "PptxGenJS Presentation";
          this._title = "PptxGenJS Presentation";
          this._presLayout = {
            name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
            _sizeW: this.LAYOUTS[DEF_PRES_LAYOUT].width,
            _sizeH: this.LAYOUTS[DEF_PRES_LAYOUT].height,
            width: this.LAYOUTS[DEF_PRES_LAYOUT].width,
            height: this.LAYOUTS[DEF_PRES_LAYOUT].height
          };
          this._rtlMode = false;
          this._slideLayouts = [
            {
              _margin: DEF_SLIDE_MARGIN_IN,
              _name: DEF_PRES_LAYOUT_NAME,
              _presLayout: this._presLayout,
              _rels: [],
              _relsChart: [],
              _relsMedia: [],
              _slide: null,
              _slideNum: 1e3,
              _slideNumberProps: null,
              _slideObjects: []
            }
          ];
          this._slides = [];
          this._sections = [];
          this._masterSlide = {
            addChart: null,
            addImage: null,
            addMedia: null,
            addNotes: null,
            addShape: null,
            addTable: null,
            addText: null,
            //
            _name: null,
            _presLayout: this._presLayout,
            _rId: null,
            _rels: [],
            _relsChart: [],
            _relsMedia: [],
            _slideId: null,
            _slideLayout: null,
            _slideNum: null,
            _slideNumberProps: null,
            _slideObjects: []
          };
        }
        Object.defineProperty(PptxGenJS2.prototype, "layout", {
          get: function() {
            return this._layout;
          },
          set: function(value) {
            var newLayout = this.LAYOUTS[value];
            if (newLayout) {
              this._layout = value;
              this._presLayout = newLayout;
            } else {
              throw new Error("UNKNOWN-LAYOUT");
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "author", {
          get: function() {
            return this._author;
          },
          set: function(value) {
            this._author = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "company", {
          get: function() {
            return this._company;
          },
          set: function(value) {
            this._company = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "revision", {
          get: function() {
            return this._revision;
          },
          set: function(value) {
            this._revision = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "subject", {
          get: function() {
            return this._subject;
          },
          set: function(value) {
            this._subject = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "theme", {
          get: function() {
            return this._theme;
          },
          set: function(value) {
            this._theme = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "title", {
          get: function() {
            return this._title;
          },
          set: function(value) {
            this._title = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "rtlMode", {
          get: function() {
            return this._rtlMode;
          },
          set: function(value) {
            this._rtlMode = value;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "masterSlide", {
          get: function() {
            return this._masterSlide;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "slides", {
          get: function() {
            return this._slides;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "sections", {
          get: function() {
            return this._sections;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "slideLayouts", {
          get: function() {
            return this._slideLayouts;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "AlignH", {
          get: function() {
            return this._alignH;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "AlignV", {
          get: function() {
            return this._alignV;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "ChartType", {
          get: function() {
            return this._chartType;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "OutputType", {
          get: function() {
            return this._outputType;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "presLayout", {
          get: function() {
            return this._presLayout;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "SchemeColor", {
          get: function() {
            return this._schemeColor;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "ShapeType", {
          get: function() {
            return this._shapeType;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "charts", {
          get: function() {
            return this._charts;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "colors", {
          get: function() {
            return this._colors;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(PptxGenJS2.prototype, "shapes", {
          get: function() {
            return this._shapes;
          },
          enumerable: false,
          configurable: true
        });
        PptxGenJS2.prototype.stream = function(props) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.exportPresentation({
                    compression: props === null || props === void 0 ? void 0 : props.compression,
                    outputType: "STREAM"
                  })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        PptxGenJS2.prototype.write = function(props) {
          return __awaiter(this, void 0, void 0, function() {
            var propsOutpType, propsCompress;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  propsOutpType = typeof props === "object" && (props === null || props === void 0 ? void 0 : props.outputType) ? props.outputType : props ? props : null;
                  propsCompress = typeof props === "object" && (props === null || props === void 0 ? void 0 : props.compression) ? props.compression : false;
                  return [4, this.exportPresentation({
                    compression: propsCompress,
                    outputType: propsOutpType
                  })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        PptxGenJS2.prototype.writeFile = function(props) {
          return __awaiter(this, void 0, void 0, function() {
            var fs2, propsExpName, propsCompress, fileName;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  fs2 = typeof require !== "undefined" && typeof window === "undefined" ? require("fs") : null;
                  if (typeof props === "string")
                    console.log("Warning: `writeFile(filename)` is deprecated - please use `WriteFileProps` argument (v3.5.0)");
                  propsExpName = typeof props === "object" && (props === null || props === void 0 ? void 0 : props.fileName) ? props.fileName : typeof props === "string" ? props : "";
                  propsCompress = typeof props === "object" && (props === null || props === void 0 ? void 0 : props.compression) ? props.compression : false;
                  fileName = propsExpName ? propsExpName.toString().toLowerCase().endsWith(".pptx") ? propsExpName : propsExpName + ".pptx" : "Presentation.pptx";
                  return [4, this.exportPresentation({
                    compression: propsCompress,
                    outputType: fs2 ? "nodebuffer" : null
                  }).then(function(content) {
                    return __awaiter(_this, void 0, void 0, function() {
                      return __generator(this, function(_a2) {
                        switch (_a2.label) {
                          case 0:
                            if (!fs2) return [3, 2];
                            return [4, new Promise(function(resolve, reject) {
                              fs2.writeFile(fileName, content, function(err) {
                                if (err) {
                                  reject(err);
                                } else {
                                  resolve(fileName);
                                }
                              });
                            })];
                          case 1:
                            return [2, _a2.sent()];
                          case 2:
                            return [4, this.writeFileToBrowser(fileName, content)];
                          case 3:
                            return [2, _a2.sent()];
                        }
                      });
                    });
                  })];
                case 1:
                  return [2, _a.sent()];
              }
            });
          });
        };
        PptxGenJS2.prototype.addSection = function(section) {
          if (!section)
            console.warn("addSection requires an argument");
          else if (!section.title)
            console.warn("addSection requires a title");
          var newSection = {
            _type: "user",
            _slides: [],
            title: section.title
          };
          if (section.order)
            this.sections.splice(section.order, 0, newSection);
          else
            this._sections.push(newSection);
        };
        PptxGenJS2.prototype.addSlide = function(options) {
          var masterSlideName = typeof options === "string" ? options : (options === null || options === void 0 ? void 0 : options.masterName) ? options.masterName : "";
          var slideLayout = {
            _name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
            _presLayout: this.presLayout,
            _rels: [],
            _relsChart: [],
            _relsMedia: [],
            _slideNum: this.slides.length + 1
          };
          if (masterSlideName) {
            var tmpLayout = this.slideLayouts.filter(function(layout) {
              return layout._name === masterSlideName;
            })[0];
            if (tmpLayout)
              slideLayout = tmpLayout;
          }
          var newSlide = new Slide({
            addSlide: this.addNewSlide,
            getSlide: this.getSlide,
            presLayout: this.presLayout,
            setSlideNum: this.setSlideNumber,
            slideId: this.slides.length + 256,
            slideRId: this.slides.length + 2,
            slideNumber: this.slides.length + 1,
            slideLayout
          });
          this._slides.push(newSlide);
          if (options === null || options === void 0 ? void 0 : options.sectionTitle) {
            var sect = this.sections.filter(function(section) {
              return section.title === options.sectionTitle;
            })[0];
            if (!sect)
              console.warn('addSlide: unable to find section with title: "'.concat(options.sectionTitle, '"'));
            else
              sect._slides.push(newSlide);
          } else if (this.sections && this.sections.length > 0 && !(options === null || options === void 0 ? void 0 : options.sectionTitle)) {
            var lastSect = this._sections[this.sections.length - 1];
            if (lastSect._type === "default")
              lastSect._slides.push(newSlide);
            else {
              this._sections.push({
                title: "Default-".concat(this.sections.filter(function(sect2) {
                  return sect2._type === "default";
                }).length + 1),
                _type: "default",
                _slides: [newSlide]
              });
            }
          }
          return newSlide;
        };
        PptxGenJS2.prototype.defineLayout = function(layout) {
          if (!layout)
            console.warn("defineLayout requires `{name, width, height}`");
          else if (!layout.name)
            console.warn("defineLayout requires `name`");
          else if (!layout.width)
            console.warn("defineLayout requires `width`");
          else if (!layout.height)
            console.warn("defineLayout requires `height`");
          else if (typeof layout.height !== "number")
            console.warn("defineLayout `height` should be a number (inches)");
          else if (typeof layout.width !== "number")
            console.warn("defineLayout `width` should be a number (inches)");
          this.LAYOUTS[layout.name] = {
            name: layout.name,
            _sizeW: Math.round(Number(layout.width) * EMU),
            _sizeH: Math.round(Number(layout.height) * EMU),
            width: Math.round(Number(layout.width) * EMU),
            height: Math.round(Number(layout.height) * EMU)
          };
        };
        PptxGenJS2.prototype.defineSlideMaster = function(props) {
          if (!props.title)
            throw new Error("defineSlideMaster() object argument requires a `title` value. (https://gitbrent.github.io/PptxGenJS/docs/masters.html)");
          var newLayout = {
            _margin: props.margin || DEF_SLIDE_MARGIN_IN,
            _name: props.title,
            _presLayout: this.presLayout,
            _rels: [],
            _relsChart: [],
            _relsMedia: [],
            _slide: null,
            _slideNum: 1e3 + this.slideLayouts.length + 1,
            _slideNumberProps: props.slideNumber || null,
            _slideObjects: [],
            background: props.background || null,
            bkgd: props.bkgd || null
          };
          createSlideMaster(props, newLayout);
          this.slideLayouts.push(newLayout);
          if (props.background || props.bkgd)
            addBackgroundDefinition(props.background, newLayout);
          if (newLayout._slideNumberProps && !this.masterSlide._slideNumberProps)
            this.masterSlide._slideNumberProps = newLayout._slideNumberProps;
        };
        PptxGenJS2.prototype.tableToSlides = function(eleId, options) {
          if (options === void 0) {
            options = {};
          }
          genTableToSlides(this, eleId, options, (options === null || options === void 0 ? void 0 : options.masterSlideName) ? this.slideLayouts.filter(function(layout) {
            return layout._name === options.masterSlideName;
          })[0] : null);
        };
        return PptxGenJS2;
      }()
    );
    module2.exports = PptxGenJS;
  }
});

// node_modules/pptx-automizer/dist/helper/generate/generate-pptxgenjs.js
var require_generate_pptxgenjs = __commonJS({
  "node_modules/pptx-automizer/dist/helper/generate/generate-pptxgenjs.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var crypto_1 = require("crypto");
    var pptxgenjs_1 = __importDefault(require_pptxgen_cjs());
    var GeneratePptxGenJs = class {
      constructor(automizer, slides) {
        this.countSlides = 0;
        this.addSlideItems = (pgenSlide, generateElement, addedObjects) => {
          const getObjectName = () => {
            return this.generateObjectName(generateElement, addedObjects);
          };
          return {
            addChart: (type, data, options) => {
              pgenSlide.addChart(type, data, this.getOptions(options, getObjectName()));
            },
            addImage: (options) => {
              pgenSlide.addImage(this.getOptions(options, getObjectName()));
            },
            addShape: (shapeName, options) => {
              pgenSlide.addShape(shapeName, this.getOptions(options, getObjectName()));
            },
            addTable: (tableRows, options) => {
              pgenSlide.addTable(tableRows, this.getOptions(options, getObjectName()));
            },
            addText: (text, options) => {
              pgenSlide.addText(text, this.getOptions(options, getObjectName()));
            }
          };
        };
        this.getOptions = (options, objectName) => {
          options = options || {};
          return Object.assign(Object.assign({}, options), { objectName });
        };
        this.automizer = automizer;
        this.slides = slides;
        this.create();
      }
      create() {
        if (this.automizer.params.pptxGenJs) {
          this.generator = this.automizer.params.pptxGenJs;
        } else {
          this.generator = new pptxgenjs_1.default();
        }
      }
      generateSlides() {
        return __awaiter(this, void 0, void 0, function* () {
          this.tmpFile = (0, crypto_1.randomUUID)() + ".pptx";
          for (const slide of this.slides) {
            const generate = slide.getGeneratedElements();
            if (generate.length) {
              this.countSlides++;
              const pgenSlide = this.appendPptxGenSlide();
              yield this.generateElements(generate, pgenSlide, this.countSlides);
            }
          }
          for (const slide of this.slides) {
            const generate = slide.getGeneratedElements();
            if (generate.length) {
              this.addElements(generate, slide);
            }
          }
          if (this.countSlides > 0) {
            const data = yield this.generator.stream();
            this.automizer.load(data, this.tmpFile);
          }
        });
      }
      generateElements(generate, pgenSlide, tmpSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          for (const generateElement of generate) {
            generateElement.tmpSlideNumber = tmpSlideNumber;
            const addedObjects = [];
            yield generateElement.callback(this.addSlideItems(pgenSlide, generateElement, addedObjects), this.generator);
            generateElement.addedObjects = [...addedObjects];
          }
        });
      }
      addElements(generate, slide) {
        generate.forEach((generateElement) => {
          generateElement.addedObjects.forEach((addedObjectName) => {
            slide.addElement(this.tmpFile, generateElement.tmpSlideNumber, addedObjectName);
          });
        });
      }
      generateObjectName(generateElement, addedObjects) {
        const objectName = (generateElement.objectName ? generateElement.objectName + "-" : "") + (0, crypto_1.randomUUID)();
        addedObjects.push(objectName);
        return objectName;
      }
      appendPptxGenSlide() {
        return this.generator.addSlide();
      }
      cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
        });
      }
    };
    exports2.default = GeneratePptxGenJs;
  }
});

// node_modules/pptx-automizer/dist/classes/template.js
var require_template = __commonJS({
  "node_modules/pptx-automizer/dist/classes/template.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Template = void 0;
    var file_helper_1 = require_file_helper();
    var count_helper_1 = require_count_helper();
    var xml_template_helper_1 = require_xml_template_helper();
    var xml_helper_1 = require_xml_helper();
    var generate_pptxgenjs_1 = __importDefault(require_generate_pptxgenjs());
    var Template = class _Template {
      constructor(file, params) {
        this.contentMap = [];
        this.mediaFiles = [];
        this.file = file;
        const archive = file_helper_1.FileHelper.importArchive(file, params);
        this.archive = archive;
      }
      static import(file, params, automizer) {
        let newTemplate;
        if (params.name) {
          newTemplate = new _Template(file, params);
          newTemplate.name = params.name;
        } else {
          newTemplate = new _Template(file, params);
          newTemplate.automizer = automizer;
          newTemplate.slides = [];
          newTemplate.masters = [];
          newTemplate.counter = [
            new count_helper_1.CountHelper("slides", newTemplate),
            new count_helper_1.CountHelper("charts", newTemplate),
            new count_helper_1.CountHelper("images", newTemplate),
            new count_helper_1.CountHelper("masters", newTemplate),
            new count_helper_1.CountHelper("layouts", newTemplate),
            new count_helper_1.CountHelper("themes", newTemplate),
            new count_helper_1.CountHelper("oleObjects", newTemplate)
          ];
        }
        return newTemplate;
      }
      mapContents(type, key, sourceId, targetId, name) {
        this.contentMap.push({
          type,
          key,
          sourceId,
          targetId,
          name
        });
      }
      getNamedMappedContent(type, name) {
        return this.contentMap.find((map) => map.type === type && map.name === name);
      }
      getMappedContent(type, key, sourceId) {
        return this.contentMap.find((map) => map.type === type && map.key === key && map.sourceId === sourceId);
      }
      /**
       * Returns the slide numbers of a given template as a sorted array of integers.
       * @returns {Promise<number[]>} - A promise that resolves to a sorted array of slide numbers in the template.
       */
      getAllSlideNumbers() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const xmlTemplateHelper = new xml_template_helper_1.XmlTemplateHelper(this.archive);
            this.slideNumbers = yield xmlTemplateHelper.getAllSlideNumbers();
            return this.slideNumbers;
          } catch (error) {
            throw new Error(error.message);
          }
        });
      }
      setCreationIds() {
        return __awaiter(this, void 0, void 0, function* () {
          const archive = yield this.archive;
          const xmlTemplateHelper = new xml_template_helper_1.XmlTemplateHelper(archive);
          this.creationIds = yield xmlTemplateHelper.getCreationIds();
          return this.creationIds;
        });
      }
      appendMasterSlide(slideMaster) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.counter[0].get() === void 0) {
            yield this.initializeCounter();
          }
          yield slideMaster.append(this).catch((e) => {
            throw e;
          });
        });
      }
      appendSlide(slide) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.counter[0].get() === void 0) {
            yield this.initializeCounter();
          }
          yield slide.append(this).catch((e) => {
            throw e;
          });
        });
      }
      appendLayout(slideLayout) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.counter[0].get() === void 0) {
            yield this.initializeCounter();
          }
          yield slideLayout.append(this).catch((e) => {
            throw e;
          });
        });
      }
      countExistingSlides() {
        return __awaiter(this, void 0, void 0, function* () {
          const xml = yield this.getSlideIdList();
          const sldIdLst = xml.getElementsByTagName("p:sldIdLst");
          if (sldIdLst.length > 0) {
            const existingSlides = sldIdLst[0].getElementsByTagName("p:sldId");
            this.existingSlides = existingSlides.length;
          }
        });
      }
      truncate() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.existingSlides > 0) {
            const xml = yield this.getSlideIdList();
            const existingSlides = xml.getElementsByTagName("p:sldId");
            xml_helper_1.XmlHelper.sliceCollection(existingSlides, this.existingSlides, 0);
            xml_helper_1.XmlHelper.writeXmlToArchive(yield this.archive, `ppt/presentation.xml`, xml);
          }
        });
      }
      getSlideIdList() {
        return __awaiter(this, void 0, void 0, function* () {
          const archive = yield this.archive;
          const xml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, `ppt/presentation.xml`);
          return xml;
        });
      }
      initializeCounter() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const c of this.counter) {
            yield c.set();
          }
        });
      }
      incrementCounter(name) {
        return count_helper_1.CountHelper.increment(name, this.counter);
      }
      count(name) {
        return count_helper_1.CountHelper.count(name, this.counter);
      }
      runExternalGenerator() {
        return __awaiter(this, void 0, void 0, function* () {
          this.generator = new generate_pptxgenjs_1.default(this.automizer, this.slides);
          yield this.generator.generateSlides();
        });
      }
      cleanupExternalGenerator() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.generator.cleanup();
        });
      }
    };
    exports2.Template = Template;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-presentation-helper.js
var require_modify_presentation_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-presentation-helper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xml_helper_1 = require_xml_helper();
    var content_tracker_1 = require_content_tracker();
    var file_helper_1 = require_file_helper();
    var ModifyPresentationHelper = class {
      /**
       * Tracker.files includes all files that have been
       * copied to the root template by automizer. We remove all other files.
       */
      static removeUnusedFiles(xml, i, archive) {
        return __awaiter(this, void 0, void 0, function* () {
          const skipDirs = [
            "ppt/slideMasters",
            "ppt/slideMasters/_rels",
            "ppt/slideLayouts",
            "ppt/slideLayouts/_rels"
          ];
          for (const dir in content_tracker_1.contentTracker.files) {
            if (skipDirs.includes(dir)) {
              continue;
            }
            const requiredFiles = content_tracker_1.contentTracker.files[dir];
            yield file_helper_1.FileHelper.removeFromDirectory(archive, dir, (file) => {
              return !requiredFiles.includes(file.relativePath);
            });
          }
        });
      }
      /**
       * PPT won't complain about unused items in [Content_Types].xml,
       * but we remove them anyway in case the file mentioned in PartName-
       * attribute does not exist.
       */
      static removeUnusedContentTypes(xml, i, archive) {
        return __awaiter(this, void 0, void 0, function* () {
          yield xml_helper_1.XmlHelper.removeIf({
            archive,
            file: `[Content_Types].xml`,
            tag: "Override",
            clause: (xml2, element) => {
              const filename = element.getAttribute("PartName").substring(1);
              const exists = file_helper_1.FileHelper.fileExistsInArchive(archive, filename);
              return exists ? false : true;
            }
          });
        });
      }
      static removedUnusedImages(xml, i, archive) {
        return __awaiter(this, void 0, void 0, function* () {
          yield content_tracker_1.contentTracker.analyzeContents(archive);
          const extensions = ["jpg", "jpeg", "png", "gif", "svg", "emf"];
          const keepFiles = [];
          yield content_tracker_1.contentTracker.collect("ppt/slides", "image", keepFiles);
          yield content_tracker_1.contentTracker.collect("ppt/slideMasters", "image", keepFiles);
          yield content_tracker_1.contentTracker.collect("ppt/slideLayouts", "image", keepFiles);
          yield file_helper_1.FileHelper.removeFromDirectory(archive, "ppt/media", (file) => {
            const info = file_helper_1.FileHelper.getFileInfo(file.name);
            return extensions.includes(info.extension.toLowerCase()) && !keepFiles.includes(info.base);
          });
        });
      }
    };
    exports2.default = ModifyPresentationHelper;
    _a = ModifyPresentationHelper;
    ModifyPresentationHelper.getSlidesCollection = (xml) => {
      return xml.getElementsByTagName("p:sldId");
    };
    ModifyPresentationHelper.getSlideMastersCollection = (xml) => {
      return xml.getElementsByTagName("p:sldMasterId");
    };
    ModifyPresentationHelper.sortSlides = (order) => (xml) => {
      const slides = ModifyPresentationHelper.getSlidesCollection(xml);
      order.map((index, i) => order[i]--);
      xml_helper_1.XmlHelper.sortCollection(slides, order);
    };
    ModifyPresentationHelper.normalizeSlideIds = (xml) => {
      const slides = ModifyPresentationHelper.getSlidesCollection(xml);
      const firstId = 256;
      xml_helper_1.XmlHelper.modifyCollection(slides, (slide, i) => {
        slide.setAttribute("id", String(firstId + i));
      });
    };
    ModifyPresentationHelper.normalizeSlideMasterIds = (xml, i, archive) => __awaiter(void 0, void 0, void 0, function* () {
      const slides = ModifyPresentationHelper.getSlideMastersCollection(xml);
      let currentId;
      yield xml_helper_1.XmlHelper.modifyCollectionAsync(slides, (slide, i2) => __awaiter(void 0, void 0, void 0, function* () {
        const masterId = i2 + 1;
        if (i2 === 0) {
          currentId = Number(slide.getAttribute("id"));
        }
        slide.setAttribute("id", String(currentId));
        currentId++;
        const slideMasterXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, `ppt/slideMasters/slideMaster${masterId}.xml`);
        const slideLayouts = slideMasterXml.getElementsByTagName("p:sldLayoutId");
        xml_helper_1.XmlHelper.modifyCollection(slideLayouts, (slideLayout) => {
          slideLayout.setAttribute("id", String(currentId));
          currentId++;
        });
      }));
    });
  }
});

// node_modules/slugify/slugify.js
var require_slugify = __commonJS({
  "node_modules/slugify/slugify.js"(exports2, module2) {
    (function(name, root, factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
        module2.exports["default"] = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root[name] = factory();
      }
    })("slugify", exports2, function() {
      var charMap = JSON.parse(`{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xA2":"cent","\xA3":"pound","\xA4":"currency","\xA5":"yen","\xA9":"(c)","\xAA":"a","\xAE":"(r)","\xBA":"o","\xC0":"A","\xC1":"A","\xC2":"A","\xC3":"A","\xC4":"A","\xC5":"A","\xC6":"AE","\xC7":"C","\xC8":"E","\xC9":"E","\xCA":"E","\xCB":"E","\xCC":"I","\xCD":"I","\xCE":"I","\xCF":"I","\xD0":"D","\xD1":"N","\xD2":"O","\xD3":"O","\xD4":"O","\xD5":"O","\xD6":"O","\xD8":"O","\xD9":"U","\xDA":"U","\xDB":"U","\xDC":"U","\xDD":"Y","\xDE":"TH","\xDF":"ss","\xE0":"a","\xE1":"a","\xE2":"a","\xE3":"a","\xE4":"a","\xE5":"a","\xE6":"ae","\xE7":"c","\xE8":"e","\xE9":"e","\xEA":"e","\xEB":"e","\xEC":"i","\xED":"i","\xEE":"i","\xEF":"i","\xF0":"d","\xF1":"n","\xF2":"o","\xF3":"o","\xF4":"o","\xF5":"o","\xF6":"o","\xF8":"o","\xF9":"u","\xFA":"u","\xFB":"u","\xFC":"u","\xFD":"y","\xFE":"th","\xFF":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0531":"A","\u0532":"B","\u0533":"G","\u0534":"D","\u0535":"E","\u0536":"Z","\u0537":"E'","\u0538":"Y'","\u0539":"T'","\u053A":"JH","\u053B":"I","\u053C":"L","\u053D":"X","\u053E":"C'","\u053F":"K","\u0540":"H","\u0541":"D'","\u0542":"GH","\u0543":"TW","\u0544":"M","\u0545":"Y","\u0546":"N","\u0547":"SH","\u0549":"CH","\u054A":"P","\u054B":"J","\u054C":"R'","\u054D":"S","\u054E":"V","\u054F":"T","\u0550":"R","\u0551":"C","\u0553":"P'","\u0554":"Q'","\u0555":"O''","\u0556":"F","\u0587":"EV","\u0621":"a","\u0622":"aa","\u0623":"a","\u0624":"u","\u0625":"i","\u0626":"e","\u0627":"a","\u0628":"b","\u0629":"h","\u062A":"t","\u062B":"th","\u062C":"j","\u062D":"h","\u062E":"kh","\u062F":"d","\u0630":"th","\u0631":"r","\u0632":"z","\u0633":"s","\u0634":"sh","\u0635":"s","\u0636":"dh","\u0637":"t","\u0638":"z","\u0639":"a","\u063A":"gh","\u0641":"f","\u0642":"q","\u0643":"k","\u0644":"l","\u0645":"m","\u0646":"n","\u0647":"h","\u0648":"w","\u0649":"a","\u064A":"y","\u064B":"an","\u064C":"on","\u064D":"en","\u064E":"a","\u064F":"u","\u0650":"e","\u0652":"","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u067E":"p","\u0686":"ch","\u0698":"zh","\u06A9":"k","\u06AF":"g","\u06CC":"y","\u06F0":"0","\u06F1":"1","\u06F2":"2","\u06F3":"3","\u06F4":"4","\u06F5":"5","\u06F6":"6","\u06F7":"7","\u06F8":"8","\u06F9":"9","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E62":"S","\u1E63":"s","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2013":"-","\u2018":"'","\u2019":"'","\u201C":"\\"","\u201D":"\\"","\u201E":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial","\uFEF5":"laa","\uFEF7":"laa","\uFEF9":"lai","\uFEFB":"la"}`);
      var locales = JSON.parse('{"bg":{"\u0419":"Y","\u0426":"Ts","\u0429":"Sht","\u042A":"A","\u042C":"Y","\u0439":"y","\u0446":"ts","\u0449":"sht","\u044A":"a","\u044C":"y"},"de":{"\xC4":"AE","\xE4":"ae","\xD6":"OE","\xF6":"oe","\xDC":"UE","\xFC":"ue","\xDF":"ss","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","\xA2":"centavos","\xA3":"libras","\xA4":"moneda","\u20A3":"francos","\u2211":"suma","\u221E":"infinito","\u2665":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xA2":"centime","\xA3":"livre","\xA4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","\xA2":"centavo","\u2211":"soma","\xA3":"libra","\u221E":"infinito","\u2665":"amor"},"uk":{"\u0418":"Y","\u0438":"y","\u0419":"Y","\u0439":"y","\u0426":"Ts","\u0446":"ts","\u0425":"Kh","\u0445":"kh","\u0429":"Shch","\u0449":"shch","\u0413":"H","\u0433":"h"},"vi":{"\u0110":"D","\u0111":"d"},"da":{"\xD8":"OE","\xF8":"oe","\xC5":"AA","\xE5":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"st\xF8rre end"},"nb":{"&":"og","\xC5":"AA","\xC6":"AE","\xD8":"OE","\xE5":"aa","\xE6":"ae","\xF8":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","\xC5":"AA","\xC4":"AE","\xD6":"OE","\xE5":"aa","\xE4":"ae","\xF6":"oe"}}');
      function replace(string, options) {
        if (typeof string !== "string") {
          throw new Error("slugify: string argument expected");
        }
        options = typeof options === "string" ? { replacement: options } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === void 0 ? "-" : options.replacement;
        var trim = options.trim === void 0 ? true : options.trim;
        var slug = string.normalize().split("").reduce(function(result, ch) {
          var appendChar = locale[ch];
          if (appendChar === void 0) appendChar = charMap[ch];
          if (appendChar === void 0) appendChar = ch;
          if (appendChar === replacement) appendChar = " ";
          return result + appendChar.replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "");
        if (options.strict) {
          slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
        }
        if (trim) {
          slug = slug.trim();
        }
        slug = slug.replace(/\s+/g, replacement);
        if (options.lower) {
          slug = slug.toLowerCase();
        }
        return slug;
      }
      replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
      };
      return replace;
    });
  }
});

// node_modules/pptx-automizer/dist/automizer.js
var require_automizer = __commonJS({
  "node_modules/pptx-automizer/dist/automizer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var slide_1 = require_slide();
    var template_1 = require_template();
    var general_helper_1 = require_general_helper();
    var master_1 = require_master();
    var path_1 = __importDefault(require("path"));
    var fs2 = __importStar(require("fs"));
    var xml_helper_1 = require_xml_helper();
    var modify_presentation_helper_1 = __importDefault(require_modify_presentation_helper());
    var content_tracker_1 = require_content_tracker();
    var slugify_1 = __importDefault(require_slugify());
    var Automizer2 = class {
      /**
       * Creates an instance of `pptx-automizer`.
       * @param [params]
       */
      constructor(params) {
        var _a, _b, _c, _d;
        this.templates = [];
        this.modifyPresentation = [];
        this.params = params;
        this.templateDir = (params === null || params === void 0 ? void 0 : params.templateDir) ? params.templateDir + "/" : "";
        this.templateFallbackDir = (params === null || params === void 0 ? void 0 : params.templateFallbackDir) ? params.templateFallbackDir + "/" : "";
        this.outputDir = (params === null || params === void 0 ? void 0 : params.outputDir) ? params.outputDir + "/" : "";
        this.archiveParams = {
          mode: ((_a = params === null || params === void 0 ? void 0 : params.archiveType) === null || _a === void 0 ? void 0 : _a.mode) || "jszip",
          baseDir: ((_b = params === null || params === void 0 ? void 0 : params.archiveType) === null || _b === void 0 ? void 0 : _b.baseDir) || __dirname + "/../cache",
          workDir: ((_c = params === null || params === void 0 ? void 0 : params.archiveType) === null || _c === void 0 ? void 0 : _c.workDir) || "tmp",
          cleanupWorkDir: (_d = params === null || params === void 0 ? void 0 : params.archiveType) === null || _d === void 0 ? void 0 : _d.cleanupWorkDir
        };
        this.timer = Date.now();
        this.setStatusTracker(params === null || params === void 0 ? void 0 : params.statusTracker);
        this.content = new content_tracker_1.ContentTracker();
        if (params.rootTemplate) {
          let file = params.rootTemplate;
          if (typeof file !== "object") {
            file = this.getLocation(file, "template");
          }
          this.rootTemplate = template_1.Template.import(file, this.archiveParams, this);
        }
        if (params.presTemplates) {
          this.params.presTemplates.forEach((file, i) => {
            let name;
            if (typeof file !== "object") {
              name = file;
              file = this.getLocation(file, "template");
            } else {
              name = `${i}.pptx`;
            }
            const archiveParams = Object.assign(Object.assign({}, this.archiveParams), { name });
            const newTemplate = template_1.Template.import(file, archiveParams);
            this.templates.push(newTemplate);
          });
        }
        if (params.verbosity) {
          general_helper_1.Logger.verbosity = params.verbosity;
        }
      }
      setStatusTracker(statusTracker) {
        const defaultStatusTracker = (status) => {
          (0, general_helper_1.log)(status.info + " (" + status.share + "%)", 2);
        };
        this.status = {
          current: 0,
          max: 0,
          share: 0,
          info: void 0,
          increment: () => {
            this.status.current++;
            const nextShare = this.status.max > 0 ? Math.round(this.status.current / this.status.max * 100) : 0;
            if (this.status.share !== nextShare) {
              this.status.share = nextShare;
              this.status.next(this.status);
            }
          },
          next: statusTracker || defaultStatusTracker
        };
      }
      /**
      
         */
      presentation() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (((_a = this.params) === null || _a === void 0 ? void 0 : _a.useCreationIds) === true) {
            yield this.setCreationIds();
          }
          return this;
        });
      }
      /**
       * Load a pptx file and set it as root template.
       * @param file - Filename, path to the template or Buffer containing the file.
       * Filenames and paths will be prefixed with 'templateDir'
       * @returns Instance of Automizer
       */
      loadRoot(file) {
        return this.loadTemplate(file);
      }
      /**
       * Load a template pptx file.
       * @param file - Filename, path to the template or Buffer containing the file.
       * Filenames and paths will be prefixed with 'templateDir'
       * @param name - Optional short name for a template loaded from a file. If skipped, the template will be named by its location.
       * if the file is a Buffer the name is required.
       * @returns Instance of Automizer
       */
      load(file, name) {
        if (!name && typeof file !== "object") {
          name = name === void 0 ? file : name;
        } else if (typeof file === "object" && !name) {
          throw new Error("Name is required when loading a template from a Buffer");
        }
        return this.loadTemplate(file, name);
      }
      /**
       * Loads a pptx file either as a root template as a template file.
       * A name can be specified to give templates an alias.
       * @param location
       * @param [name]
       * @returns template
       */
      loadTemplate(file, name) {
        if (typeof file !== "object") {
          file = this.getLocation(file, "template");
        }
        const alreadyLoaded = this.templates.find((template) => template.name === name);
        if (alreadyLoaded) {
          return this;
        }
        const importParams = Object.assign(Object.assign({}, this.archiveParams), { name });
        const newTemplate = template_1.Template.import(file, importParams, this);
        if (!this.isPresTemplate(newTemplate)) {
          this.rootTemplate = newTemplate;
        } else {
          this.templates.push(newTemplate);
        }
        return this;
      }
      /**
       * Load media files to output presentation.
       * @returns Instance of Automizer
       * @param filename Filename or path to the media file.
       * @param dir Specify custom path for media instead of mediaDir from AutomizerParams.
       */
      loadMedia(filename, dir, prefix) {
        const files = general_helper_1.GeneralHelper.arrayify(filename);
        if (!this.rootTemplate) {
          throw "Can't load media, you need to load a root template first";
        }
        files.forEach((file) => {
          const directory = dir || this.params.mediaDir;
          const filepath = path_1.default.join(directory, file);
          const extension = path_1.default.extname(file).replace(".", "");
          try {
            fs2.accessSync(filepath, fs2.constants.F_OK);
          } catch (e) {
            throw `Can't load media: ${filepath} does not exist.`;
          }
          this.rootTemplate.mediaFiles.push({
            file,
            directory,
            filepath,
            extension,
            prefix
          });
        });
        return this;
      }
      /**
       * Parses all loaded templates and collects creationIds for slides and
       * elements. This will make finding templates and elements independent
       * of slide number and element name.
       * @returns Promise<TemplateInfo[]>
       */
      setCreationIds() {
        return __awaiter(this, void 0, void 0, function* () {
          const templateCreationId = [];
          for (const template of this.templates) {
            const creationIds = template.creationIds || (yield template.setCreationIds());
            template.useCreationIds = this.params.useCreationIds;
            templateCreationId.push({
              name: template.name,
              slides: creationIds
            });
          }
          return templateCreationId;
        });
      }
      /**
       * Get some info about the imported templates
       * @returns Promise<PresentationInfo>
       */
      getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
          const creationIds = yield this.setCreationIds();
          const info = {
            templateByName: (tplName) => {
              return creationIds.find((template) => template.name === tplName);
            },
            slidesByTemplate: (tplName) => {
              var _a;
              return ((_a = info.templateByName(tplName)) === null || _a === void 0 ? void 0 : _a.slides) || [];
            },
            slideByNumber: (tplName, slideNumber) => {
              return info.slidesByTemplate(tplName).find((slide) => slide.number === slideNumber);
            },
            elementByName: (tplName, slideNumber, elementName) => {
              var _a;
              return (_a = info.slideByNumber(tplName, slideNumber)) === null || _a === void 0 ? void 0 : _a.elements.find((element) => elementName === element.name);
            }
          };
          return info;
        });
      }
      /**
       * Determines whether template is root or default template.
       * @param template
       * @returns pres template
       */
      isPresTemplate(template) {
        return "name" in template;
      }
      /**
       * Add a slide from one of the imported templates by slide number or creationId.
       * @param name - Name or alias of the template; must have been loaded with `Automizer.load()`
       * @param slideIdentifier - Number or creationId of slide in template presentation
       * @param callback - Executed after slide was added. The newly created slide will be passed to the callback as first argument.
       * @returns Instance of Automizer
       */
      addSlide(name, slideIdentifier, callback) {
        if (this.rootTemplate === void 0) {
          throw new Error("You have to set a root template first.");
        }
        const template = this.getTemplate(name);
        const newSlide = new slide_1.Slide({
          presentation: this,
          template,
          slideIdentifier
        });
        if (this.params.autoImportSlideMasters) {
          newSlide.useSlideLayout();
        }
        if (callback !== void 0) {
          newSlide.root = this;
          callback(newSlide);
        }
        this.rootTemplate.slides.push(newSlide);
        return this;
      }
      /**
       * Copy and modify a master and the associated layouts from template to output.
       *
       * @param name
       * @param sourceIdentifier
       * @param callback
       */
      addMaster(name, sourceIdentifier, callback) {
        const key = sourceIdentifier + "@" + name;
        if (this.rootTemplate.masters.find((master) => master.key === key)) {
          console.log("Already imported " + key);
          return this;
        }
        const template = this.getTemplate(name);
        const newMaster = new master_1.Master({
          presentation: this,
          template,
          sourceIdentifier
        });
        if (callback !== void 0) {
          newMaster.root = this;
          callback(newMaster);
        }
        this.rootTemplate.masters.push(newMaster);
        return this;
      }
      /**
       * Searches this.templates to find template by given name.
       * @internal
       * @param name Alias name if given to loaded template.
       * @returns template
       */
      getTemplate(name) {
        const template = this.templates.find((t) => t.name === name);
        if (template === void 0) {
          throw new Error(`Template not found: ${name}`);
        }
        return template;
      }
      /**
       * Write all imports and modifications to a file.
       * @param location - Filename or path for the file. Will be prefixed with 'outputDir'
       * @returns summary object.
       */
      write(location) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.finalizePresentation();
          yield this.rootTemplate.archive.output(this.getLocation(location, "output"), this.params);
          const duration = (Date.now() - this.timer) / 600;
          return {
            status: "finished",
            duration,
            file: location,
            filename: path_1.default.basename(location),
            templates: this.templates.length,
            slides: this.rootTemplate.count("slides"),
            charts: this.rootTemplate.count("charts"),
            images: this.rootTemplate.count("images"),
            masters: this.rootTemplate.count("masters")
          };
        });
      }
      /**
       * Create a ReadableStream from output pptx file.
       * @param generatorOptions - JSZipGeneratorOptions for nodebuffer Output type
       * @returns Promise<NodeJS.ReadableStream>
       */
      stream(generatorOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.finalizePresentation();
          if (!this.rootTemplate.archive.stream) {
            throw "Streaming is not implemented for current archive type";
          }
          return this.rootTemplate.archive.stream(this.params, generatorOptions);
        });
      }
      /**
       * Pass final JSZip instance.
       * @returns Promise<NodeJS.ReadableStream>
       */
      getJSZip() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.finalizePresentation();
          if (!this.rootTemplate.archive.getFinalArchive) {
            throw "GetFinalArchive is not implemented for current archive type";
          }
          return this.rootTemplate.archive.getFinalArchive();
        });
      }
      finalizePresentation() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.writeMasterSlides();
          yield this.writeSlides();
          yield this.writeMediaFiles();
          yield this.normalizePresentation();
          yield this.applyModifyPresentationCallbacks();
          content_tracker_1.contentTracker.reset();
        });
      }
      /**
       * Write all masterSlides to archive.
       */
      writeMasterSlides() {
        return __awaiter(this, void 0, void 0, function* () {
          for (const slide of this.rootTemplate.masters) {
            yield this.rootTemplate.appendMasterSlide(slide);
          }
        });
      }
      /**
       * Write all slides to archive.
       */
      writeSlides() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.rootTemplate.countExistingSlides();
          this.status.max = this.rootTemplate.slides.length;
          yield this.rootTemplate.runExternalGenerator();
          for (const slide of this.rootTemplate.slides) {
            yield this.rootTemplate.appendSlide(slide);
          }
          yield this.rootTemplate.cleanupExternalGenerator();
          if (this.params.removeExistingSlides) {
            yield this.rootTemplate.truncate();
          }
        });
      }
      /**
       * Write all media files to archive.
       */
      writeMediaFiles() {
        return __awaiter(this, void 0, void 0, function* () {
          const mediaDir = "ppt/media/";
          for (const file of this.rootTemplate.mediaFiles) {
            const data = fs2.readFileSync(file.filepath);
            let archiveFilename = file.file;
            if (file.prefix) {
              archiveFilename = file.prefix + file.file;
            }
            archiveFilename = (0, slugify_1.default)(archiveFilename);
            yield this.rootTemplate.archive.write(mediaDir + archiveFilename, data);
            yield xml_helper_1.XmlHelper.appendImageExtensionToContentType(this.rootTemplate.archive, file.extension);
          }
        });
      }
      /**
       * Applies all callbacks in this.modifyPresentation-array.
       * The callback array can be pushed by this.modify()
       */
      applyModifyPresentationCallbacks() {
        return __awaiter(this, void 0, void 0, function* () {
          yield xml_helper_1.XmlHelper.modifyXmlInArchive(this.rootTemplate.archive, `ppt/presentation.xml`, this.modifyPresentation);
        });
      }
      /**
       * Apply some callbacks to restore archive/xml structure
       * and prevent corrupted pptx files.
       *
       * TODO: Use every imported image only once
       * TODO: Check for lost relations
       */
      normalizePresentation() {
        return __awaiter(this, void 0, void 0, function* () {
          this.modify(modify_presentation_helper_1.default.normalizeSlideIds);
          this.modify(modify_presentation_helper_1.default.normalizeSlideMasterIds);
          if (this.params.cleanup) {
            if (this.params.removeExistingSlides) {
              this.modify(modify_presentation_helper_1.default.removeUnusedFiles);
            }
            this.modify(modify_presentation_helper_1.default.removedUnusedImages);
            this.modify(modify_presentation_helper_1.default.removeUnusedContentTypes);
          }
        });
      }
      modify(cb) {
        this.modifyPresentation.push(cb);
        return this;
      }
      /**
       * Applies path prefix to given location string.
       * @param location path and/or filename
       * @param [type] template or output
       * @returns location
       */
      getLocation(location, type) {
        switch (type) {
          case "template":
            if (fs2.existsSync(this.templateDir + location)) {
              return this.templateDir + location;
            } else if (fs2.existsSync(this.templateFallbackDir + location)) {
              return this.templateFallbackDir + location;
            } else {
              if (typeof location === "string") {
                (0, general_helper_1.log)('No file matches "' + location + '"', 0);
              } else {
                (0, general_helper_1.log)("Invalid filename", 0);
              }
              (0, general_helper_1.log)("@templateDir: " + this.templateDir, 2);
              (0, general_helper_1.log)("@templateFallbackDir: " + this.templateFallbackDir, 2);
            }
            break;
          case "output":
            return this.outputDir + location;
          default:
            return location;
        }
      }
    };
    exports2.default = Automizer2;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-helper.js
var require_modify_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DxaToCm = exports2.CmToDxa = void 0;
    var xml_helper_1 = require_xml_helper();
    var ModifyHelper = class {
    };
    exports2.default = ModifyHelper;
    ModifyHelper.setAttribute = (tagName, attribute, value, count) => (element) => {
      const item = element.getElementsByTagName(tagName)[count || 0];
      if (item.setAttribute !== void 0) {
        item.setAttribute(attribute, String(value));
      }
    };
    ModifyHelper.dump = (element) => {
      xml_helper_1.XmlHelper.dump(element);
    };
    ModifyHelper.dumpChart = (element, chart) => {
      xml_helper_1.XmlHelper.dump(chart);
    };
    var CmToDxa = (cm) => {
      return Math.round(cm * 36e4);
    };
    exports2.CmToDxa = CmToDxa;
    var DxaToCm = (dxa) => {
      return dxa / 36e4;
    };
    exports2.DxaToCm = DxaToCm;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/es-abstract/helpers/callBind.js
var require_callBind = __commonJS({
  "node_modules/es-abstract/helpers/callBind.js"(exports2, module2) {
    "use strict";
    module2.exports = require_call_bind();
  }
});

// node_modules/es-abstract/2019/ToString.js
var require_ToString = __commonJS({
  "node_modules/es-abstract/2019/ToString.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module2.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/es-abstract/helpers/callBound.js
var require_callBound = __commonJS({
  "node_modules/es-abstract/helpers/callBound.js"(exports2, module2) {
    "use strict";
    module2.exports = require_call_bound();
  }
});

// node_modules/regexp.escape/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/regexp.escape/implementation.js"(exports2, module2) {
    "use strict";
    var ToString = require_ToString();
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var syntaxChars = /[\^$\\.*+?()[\]{}|]/g;
    module2.exports = function escape(S) {
      return $replace(ToString(S), syntaxChars, "\\$&");
    };
  }
});

// node_modules/regexp.escape/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/regexp.escape/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      return RegExp.escape || implementation;
    };
  }
});

// node_modules/regexp.escape/shim.js
var require_shim = __commonJS({
  "node_modules/regexp.escape/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var escapePolyfill = require_polyfill()();
    module2.exports = function shimRegExpEscape() {
      define2(RegExp, {
        escape: escapePolyfill
      });
      return RegExp.escape;
    };
  }
});

// node_modules/regexp.escape/index.js
var require_regexp = __commonJS({
  "node_modules/regexp.escape/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_callBind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var bound = callBind(implementation, null);
    define2(bound, {
      getPolyfill,
      implementation,
      method: implementation,
      // TODO: remove at semver-major
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/pptx-automizer/dist/helper/xml/dLbl.js
var require_dLbl = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml/dLbl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dLblXml = void 0;
    exports2.dLblXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<c:chartSpace xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:c16r2="http://schemas.microsoft.com/office/drawing/2015/06/chart">
    <c:chart>
        <c:plotArea>
            <c:barChart>
                <c:ser>
                    <c:dLbls>
                        <c:dLbl>
                            <c:idx val="0"/>
                            <c:spPr>
                                <a:noFill/>
                                <a:ln>
                                    <a:noFill/>
                                </a:ln>
                                <a:effectLst/>
                            </c:spPr>
                            <c:txPr>
                                <a:bodyPr rot="0" spcFirstLastPara="1" vertOverflow="ellipsis" vert="horz" wrap="square" lIns="38100" tIns="19050" rIns="38100" bIns="19050" anchor="ctr" anchorCtr="1">
                                    <a:spAutoFit/>
                                </a:bodyPr>
                                <a:lstStyle/>
                                <a:p>
                                    <a:pPr>
                                        <a:defRPr sz="1400" b="0" i="0" u="none" strike="noStrike" kern="1200" baseline="0">
                                            <a:solidFill>
                                                <a:schemeClr val="accent1"/>
                                            </a:solidFill>
                                            <a:latin typeface="+mn-lt"/>
                                            <a:ea typeface="+mn-ea"/>
                                            <a:cs typeface="+mn-cs"/>
                                        </a:defRPr>
                                    </a:pPr>
                                    <a:endParaRPr lang="en-US"/>
                                </a:p>
                            </c:txPr>
                            <c:showLegendKey val="0"/>
                            <c:showVal val="1"/>
                            <c:showCatName val="0"/>
                            <c:showSerName val="0"/>
                            <c:showPercent val="0"/>
                            <c:showBubbleSize val="0"/>
                            <c:extLst>
                                <c:ext uri="{C3380CC4-5D6E-409C-BE32-E72D297353CC}" xmlns:c16="http://schemas.microsoft.com/office/drawing/2014/chart">
                                    <c16:uniqueId val="{00000001-04B4-49A4-AD60-4DBFE8A0F479}"/>
                                </c:ext>
                            </c:extLst>
                        </c:dLbl>
                    </c:dLbls>
                </c:ser>
            </c:barChart>
        </c:plotArea>
    </c:chart>
</c:chartSpace>
`;
  }
});

// node_modules/pptx-automizer/dist/helper/xml/lnLRTB.js
var require_lnLRTB = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml/lnLRTB.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lnLRTB = void 0;
    exports2.lnLRTB = `<?xml version="1.0" encoding="UTF-8" standalone="yes" ?> 
<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">
  <p:cSld>
    <p:spTree>
      <p:graphicFrame>
        <a:graphic>
          <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table">
            <a:tbl>
              <a:tr h="370840">
                <a:tc>
                  <a:tcPr>
                    <a:lnL w="35000" cap="flat" cmpd="sng" algn="ctr">
                      <a:solidFill>
                        <a:srgbClr val="aacc00" /> 
                      </a:solidFill>
                      <a:prstDash val="solid" /> 
                      <a:round /> 
                      <a:headEnd type="none" w="med" len="med" /> 
                      <a:tailEnd type="none" w="med" len="med" /> 
                    </a:lnL>
                    <a:lnR w="35000" cap="flat" cmpd="sng" algn="ctr">
                      <a:solidFill>
                        <a:srgbClr val="aacc00" /> 
                      </a:solidFill>
                      <a:prstDash val="solid" /> 
                      <a:round /> 
                      <a:headEnd type="none" w="med" len="med" /> 
                      <a:tailEnd type="none" w="med" len="med" /> 
                    </a:lnR>
                    <a:lnT w="35000" cap="flat" cmpd="sng" algn="ctr">
                      <a:solidFill>
                        <a:srgbClr val="aacc00" /> 
                      </a:solidFill>
                      <a:prstDash val="solid" /> 
                      <a:round /> 
                      <a:headEnd type="none" w="med" len="med" /> 
                      <a:tailEnd type="none" w="med" len="med" /> 
                    </a:lnT>
                    <a:lnB w="35000" cap="flat" cmpd="sng" algn="ctr">
                      <a:solidFill>
                        <a:srgbClr val="aacc00" /> 
                      </a:solidFill>
                      <a:prstDash val="solid" /> 
                      <a:round /> 
                      <a:headEnd type="none" w="med" len="med" /> 
                      <a:tailEnd type="none" w="med" len="med" /> 
                    </a:lnB>
                  </a:tcPr>
                </a:tc>
              </a:tr>
            </a:tbl>
          </a:graphicData>
        </a:graphic>
      </p:graphicFrame>
    </p:spTree>
  </p:cSld>
</p:sld>
`;
  }
});

// node_modules/pptx-automizer/dist/helper/xml-elements.js
var require_xml_elements = __commonJS({
  "node_modules/pptx-automizer/dist/helper/xml-elements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xml_helper_1 = require_xml_helper();
    var xmldom_1 = require_lib();
    var dLbl_1 = require_dLbl();
    var lnLRTB_1 = require_lnLRTB();
    var XmlElements = class {
      constructor(element, params) {
        this.element = element;
        this.document = element.ownerDocument;
        this.params = params;
        this.defaultValues = {
          color: "CCCCCC",
          size: "1000"
        };
      }
      text() {
        const r = this.document.createElement("a:r");
        r.appendChild(this.textRangeProps());
        r.appendChild(this.textContent());
        let paragraphProps = this.element.getElementsByTagName("a:pPr").item(0);
        if (!paragraphProps) {
          paragraphProps = this.paragraphProps();
        }
        xml_helper_1.XmlHelper.insertAfter(r, paragraphProps);
        return this;
      }
      createTextBody() {
        let txBody = this.element.getElementsByTagName("p:txBody")[0];
        if (!txBody) {
          txBody = this.document.createElement("p:txBody");
          this.element.appendChild(txBody);
          const bodyPr = this.document.createElement("a:bodyPr");
          txBody.appendChild(bodyPr);
          const lstStyle = this.document.createElement("a:lstStyle");
          txBody.appendChild(lstStyle);
          this.paragraphTemplate = this.document.createElement("a:p");
          txBody.appendChild(this.paragraphTemplate);
          this.runTemplate = this.document.createElement("a:r");
          const rPr = this.document.createElement("a:rPr");
          this.runTemplate.appendChild(rPr);
        } else {
          let bodyPr = txBody.getElementsByTagName("a:bodyPr")[0];
          if (!bodyPr) {
            bodyPr = this.document.createElement("a:bodyPr");
            txBody.insertBefore(bodyPr, txBody.firstChild);
          }
          let lstStyle = txBody.getElementsByTagName("a:lstStyle")[0];
          if (!lstStyle) {
            lstStyle = this.document.createElement("a:lstStyle");
            txBody.insertBefore(lstStyle, bodyPr.nextSibling);
          }
          const paragraphs = txBody.getElementsByTagName("a:p");
          this.paragraphTemplate = paragraphs[0];
          xml_helper_1.XmlHelper.sliceCollection(paragraphs, 0);
          const runs = this.paragraphTemplate.getElementsByTagName("a:r");
          if (runs.length > 0) {
            this.runTemplate = runs[0];
          } else {
            this.runTemplate = this.document.createElement("a:r");
            const rPr = this.document.createElement("a:rPr");
            this.runTemplate.appendChild(rPr);
          }
        }
        return txBody;
      }
      createBodyProperties(txBody) {
        const bodyPr = this.document.createElement("a:bodyPr");
        txBody.appendChild(bodyPr);
        return bodyPr;
      }
      addBulletList(list) {
        const txBody = this.createTextBody();
        this.createBodyProperties(txBody);
        this.processList(txBody, list, 0);
      }
      processList(txBody, items, level) {
        items.forEach((item) => {
          if (Array.isArray(item)) {
            this.processList(txBody, item, level + 1);
          } else {
            const p = this.createParagraph(level);
            const r = this.createTextRun(String(item));
            p.appendChild(r);
            txBody.appendChild(p);
          }
        });
      }
      createParagraph(level) {
        const p = this.paragraphTemplate.cloneNode(true);
        const pPr = p.getElementsByTagName("a:pPr")[0];
        if (pPr) {
          if (level > 0) {
            pPr.setAttribute("lvl", String(level));
            pPr.removeAttribute("indent");
            pPr.removeAttribute("marL");
          } else {
            pPr.removeAttribute("lvl");
          }
        } else {
          const newPPr = this.document.createElement("a:pPr");
          if (level > 0) {
            newPPr.setAttribute("lvl", String(level));
          }
          p.insertBefore(newPPr, p.firstChild);
        }
        const runs = p.getElementsByTagName("a:r");
        xml_helper_1.XmlHelper.sliceCollection(runs, 0);
        return p;
      }
      createTextRun(text) {
        const r = this.runTemplate.cloneNode(true);
        const t = r.getElementsByTagName("a:t")[0];
        if (t) {
          t.textContent = text;
        } else {
          const newT = this.document.createElement("a:t");
          newT.textContent = text;
          r.appendChild(newT);
        }
        return r;
      }
      paragraphProps() {
        const p = this.element.getElementsByTagName("a:p").item(0);
        p.appendChild(this.document.createElement("a:pPr"));
        const paragraphRangeProps = this.element.getElementsByTagName("a:pPr").item(0);
        const endParaRPr = this.element.getElementsByTagName("a:endParaRPr").item(0);
        xml_helper_1.XmlHelper.moveChild(endParaRPr);
        return paragraphRangeProps;
      }
      textRangeProps() {
        const rPr = this.document.createElement("a:rPr");
        const endParaRPr = this.element.getElementsByTagName("a:endParaRPr")[0];
        rPr.setAttribute("lang", endParaRPr.getAttribute("lang"));
        rPr.setAttribute("sz", endParaRPr.getAttribute("sz") || this.defaultValues.size);
        rPr.appendChild(this.line());
        rPr.appendChild(this.effectLst());
        rPr.appendChild(this.lineTexture());
        rPr.appendChild(this.fillTexture());
        return rPr;
      }
      textContent() {
        const t = this.document.createElement("a:t");
        t.textContent = " ";
        return t;
      }
      effectLst() {
        return this.document.createElement("a:effectLst");
      }
      lineTexture() {
        return this.document.createElement("a:uLnTx");
      }
      fillTexture() {
        return this.document.createElement("a:uFillTx");
      }
      line() {
        const ln = this.document.createElement("a:ln");
        const noFill = this.document.createElement("a:noFill");
        ln.appendChild(noFill);
        return ln;
      }
      solidFill() {
        const solidFill = this.document.createElement("a:solidFill");
        const colorType = this.colorType();
        solidFill.appendChild(colorType);
        return solidFill;
      }
      colorType() {
        var _a, _b;
        const tag = "a:" + (((_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.color) === null || _b === void 0 ? void 0 : _b.type) || "srgbClr");
        const colorType = this.document.createElement(tag);
        this.colorValue(colorType);
        return colorType;
      }
      colorValue(colorType) {
        var _a, _b;
        colorType.setAttribute("val", ((_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.color) === null || _b === void 0 ? void 0 : _b.value) || this.defaultValues.color);
      }
      dataPoint() {
        const dPt = this.document.createElement("c:dPt");
        dPt.appendChild(this.idx());
        dPt.appendChild(this.spPr());
        const nextSibling = this.element.getElementsByTagName("c:cat")[0];
        if (nextSibling) {
          nextSibling.parentNode.insertBefore(dPt, nextSibling);
        }
        return this;
      }
      spPr() {
        const spPr = this.document.createElement("c:spPr");
        spPr.appendChild(this.solidFill());
        spPr.appendChild(this.line());
        spPr.appendChild(this.effectLst());
        return spPr;
      }
      idx() {
        const idx = this.document.createElement("c:idx");
        idx.setAttribute("val", String(0));
        return idx;
      }
      cellBorder(tag) {
        const border = this.document.createElement(tag);
        border.appendChild(this.solidFill());
        border.appendChild(this.prstDash());
        border.appendChild(this.round());
        border.appendChild(this.lineEnd("headEnd"));
        border.appendChild(this.lineEnd("tailEnd"));
        return this;
      }
      prstDash() {
        const prstDash = this.document.createElement("a:prstDash");
        prstDash.setAttribute("val", "solid");
        return prstDash;
      }
      round() {
        const round = this.document.createElement("a:round");
        return round;
      }
      lineEnd(type) {
        const lineEnd = this.document.createElement(type);
        lineEnd.setAttribute("type", "none");
        lineEnd.setAttribute("w", "med");
        lineEnd.setAttribute("len", "med");
        return lineEnd;
      }
      shapeProperties() {
        const spPr = this.spPr();
        this.element.appendChild(spPr);
      }
      dataPointLabel() {
        const doc = new xmldom_1.DOMParser().parseFromString(dLbl_1.dLblXml, "application/xml");
        const ele = doc.getElementsByTagName("c:dLbl")[0];
        const firstChild = this.element.firstChild;
        this.element.insertBefore(ele.cloneNode(true), firstChild);
      }
      tableCellBorder(tag) {
        const doc = new xmldom_1.DOMParser().parseFromString(lnLRTB_1.lnLRTB, "application/xml");
        const ele = doc.getElementsByTagName(tag)[0];
        const firstChild = this.element.firstChild;
        this.element.insertBefore(ele.cloneNode(true), firstChild);
      }
    };
    exports2.default = XmlElements;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-color-helper.js
var require_modify_color_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-color-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xml_elements_1 = __importDefault(require_xml_elements());
    var xml_helper_1 = require_xml_helper();
    var ModifyColorHelper = class {
    };
    exports2.default = ModifyColorHelper;
    ModifyColorHelper.solidFill = (color, index) => (element) => {
      if (!color || !color.type || (element === null || element === void 0 ? void 0 : element.getElementsByTagName) === void 0)
        return;
      ModifyColorHelper.normalizeColorObject(color);
      const solidFills = element.getElementsByTagName("a:solidFill");
      if (!solidFills.length) {
        const solidFill2 = new xml_elements_1.default(element, {
          color
        }).solidFill();
        element.appendChild(solidFill2);
        return;
      }
      let targetIndex = !index ? 0 : index === "last" ? solidFills.length - 1 : index;
      const solidFill = solidFills[targetIndex];
      const colorType = new xml_elements_1.default(element, {
        color
      }).colorType();
      xml_helper_1.XmlHelper.sliceCollection(solidFill.childNodes, 0);
      solidFill.appendChild(colorType);
    };
    ModifyColorHelper.removeNoFill = () => (element) => {
      const hasNoFill = element.getElementsByTagName("a:noFill")[0];
      if (hasNoFill) {
        element.removeChild(hasNoFill);
      }
    };
    ModifyColorHelper.normalizeColorObject = (color) => {
      if (color.value.indexOf("#") === 0) {
        color.value = color.value.replace("#", "");
      }
      if (color.value.toLowerCase().indexOf("rgb(") === 0) {
        color.value = "cccccc";
      }
      return color;
    };
  }
});

// node_modules/pptx-automizer/dist/helper/cell-id-helper.js
var require_cell_id_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/cell-id-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CellIdHelper = class _CellIdHelper {
      constructor(chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") {
        this._chars = chars;
        this._nextId = [0];
      }
      start(index) {
        this._nextId = [index];
        return this;
      }
      next() {
        const r = [];
        for (const char of this._nextId) {
          r.unshift(this._chars[char]);
        }
        this._increment();
        return r.join("");
      }
      _increment() {
        for (let i = 0; i < this._nextId.length; i++) {
          const val = ++this._nextId[i];
          if (val >= this._chars.length) {
            this._nextId[i] = 0;
          } else {
            return;
          }
        }
        this._nextId.push(0);
      }
      // eslint-disable-next-line
      *[Symbol.iterator]() {
        while (true) {
          yield this.next();
        }
      }
      static increment(letterNumber) {
        const Generator = new this("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        return Generator.start(letterNumber).next();
      }
      static setRange(range, colId, length) {
        const info = range.split("!");
        const spans = info[1].split(":");
        const start = spans[0].split("$");
        const startRow = Number(spans[0].split("$")[2]);
        const colLetter = _CellIdHelper.increment(colId);
        let endCell = "";
        if (length !== void 0) {
          const endRow = String(startRow + length - 1);
          endCell = `:$${colLetter}$${endRow}`;
        }
        const newRange = `${info[0]}!$${colLetter}$${start[2]}${endCell}`;
        return newRange;
      }
      static getSpanString(startColNumber, startRowNumber, cols, rows) {
        const startColLetter = _CellIdHelper.increment(startColNumber);
        const endColLetter = _CellIdHelper.increment(startColNumber + cols);
        const endRowNumber = startRowNumber + rows;
        return `${startColLetter}${startRowNumber}:${endColLetter}${endRowNumber}`;
      }
      static getCellAddressString(c, r) {
        const colLetter = _CellIdHelper.increment(c);
        return `${colLetter}${r + 1}`;
      }
    };
    exports2.default = CellIdHelper;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-xml-helper.js
var require_modify_xml_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-xml-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cell_id_helper_1 = __importDefault(require_cell_id_helper());
    var general_helper_1 = require_general_helper();
    var xml_helper_1 = require_xml_helper();
    var xml_elements_1 = __importDefault(require_xml_elements());
    var ModifyXmlHelper = class {
      constructor(root) {
        this.root = root;
        this.templates = {};
      }
      modify(tags, root) {
        root = root || this.root;
        for (const tag in tags) {
          const modifier = tags[tag];
          if (modifier.all) {
            this.modifyAll(tag, modifier, root);
          }
          if (modifier.collection) {
            const modifies = general_helper_1.GeneralHelper.arrayify(modifier.collection);
            const collection = root.getElementsByTagName(tag);
            Object.values(modifies).forEach((modifyXml) => modifyXml(collection));
            return;
          }
          const index = modifier.index || 0;
          const isRequired = modifier.isRequired !== void 0 ? modifier.isRequired : true;
          const element = this.assertElement(root.getElementsByTagName(tag), index, tag, root, modifier);
          if (element === false) {
            if (isRequired === true) {
            }
          } else {
            if (modifier.modify) {
              const modifies = general_helper_1.GeneralHelper.arrayify(modifier.modify);
              Object.values(modifies).forEach((modifyXml) => modifyXml(element));
            }
            if (modifier.children) {
              this.modify(modifier.children, element);
            }
          }
        }
      }
      modifyAll(tag, modifier, root) {
        const elements = Array.from(root.getElementsByTagName(tag));
        elements.forEach((element) => {
          this.modify(modifier.children, element);
        });
      }
      assertElement(collection, index, tag, parent, modifier) {
        if (!collection[index]) {
          if (collection[collection.length - 1] === void 0) {
            this.createElement(parent, tag);
          } else {
            const lastSibling = collection[collection.length - 1];
            let sourceSibling = lastSibling;
            if (modifier.fromIndex && collection.item(modifier.fromIndex)) {
              sourceSibling = collection.item(modifier.fromIndex);
            } else if (modifier.fromPrevious && collection.item(index - 1)) {
              sourceSibling = collection.item(index - 1);
            }
            if ((!sourceSibling || modifier.forceCreate) && this.templates[tag]) {
              sourceSibling = this.templates[tag];
            }
            const newChild = sourceSibling.cloneNode(true);
            xml_helper_1.XmlHelper.insertAfter(newChild, lastSibling);
          }
        }
        const element = parent.getElementsByTagName(tag)[index];
        if (element) {
          this.templates[tag] = this.templates[tag] || element.cloneNode(true);
          return element;
        }
        return false;
      }
      createElement(parent, tag) {
        switch (tag) {
          case "a:t":
            new xml_elements_1.default(parent).text();
            return true;
          case "c:dPt":
            new xml_elements_1.default(parent).dataPoint();
            return true;
          case "c:spPr":
            new xml_elements_1.default(parent).shapeProperties();
            return true;
          case "c:dLbl":
            new xml_elements_1.default(parent).dataPointLabel();
            return true;
          case "a:lnL":
          case "a:lnR":
          case "a:lnT":
          case "a:lnB":
            new xml_elements_1.default(parent).tableCellBorder(tag);
            return true;
        }
        return false;
      }
    };
    exports2.default = ModifyXmlHelper;
    ModifyXmlHelper.getText = (element) => {
      return element.firstChild.textContent;
    };
    ModifyXmlHelper.value = (value, index) => (element) => {
      const valueElement = element.getElementsByTagName("c:v");
      if (!valueElement.length) {
        xml_helper_1.XmlHelper.dump(element);
        throw "Unable to set value @index: " + index;
      }
      valueElement[0].firstChild.textContent = String(value);
      if (index !== void 0) {
        element.setAttribute("idx", String(index));
      }
    };
    ModifyXmlHelper.textContent = (value) => (element) => {
      element.firstChild.textContent = String(value);
    };
    ModifyXmlHelper.attribute = (attribute, value) => (element) => {
      if (value != void 0)
        element.setAttribute(attribute, String(value));
    };
    ModifyXmlHelper.booleanAttribute = (attribute, state) => (element) => {
      element.setAttribute(attribute, state === true ? "1" : "0");
    };
    ModifyXmlHelper.range = (series, length) => (element) => {
      const range = element.firstChild.textContent;
      element.firstChild.textContent = cell_id_helper_1.default.setRange(range, series, length);
    };
  }
});

// node_modules/pptx-automizer/dist/helper/modify-text-helper.js
var require_modify_text_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-text-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var modify_color_helper_1 = __importDefault(require_modify_color_helper());
    var modify_xml_helper_1 = __importDefault(require_modify_xml_helper());
    var xml_elements_1 = __importDefault(require_xml_elements());
    var ModifyTextHelper = class {
    };
    exports2.default = ModifyTextHelper;
    ModifyTextHelper.setText = (text) => (element) => {
      const paragraphs = element.getElementsByTagName("a:p");
      const length = paragraphs.length;
      for (let i = 0; i < length; i++) {
        const paragraph = paragraphs[i];
        if (i === 0) {
          const blocks = element.getElementsByTagName("a:r");
          const length2 = blocks.length;
          for (let j = 0; j < length2; j++) {
            const block = blocks[j];
            if (j === 0) {
              const textNode = block.getElementsByTagName("a:t")[0];
              ModifyTextHelper.content(text)(textNode);
            } else {
              block.parentNode.removeChild(block);
            }
          }
        } else {
          paragraph.parentNode.removeChild(paragraph);
        }
      }
    };
    ModifyTextHelper.setBulletList = (list) => (element) => {
      const xmlElements = new xml_elements_1.default(element);
      xmlElements.addBulletList(list);
    };
    ModifyTextHelper.content = (label) => (element) => {
      if (label !== void 0 && element.firstChild) {
        element.firstChild.textContent = String(label);
      }
    };
    ModifyTextHelper.style = (style) => (element) => {
      if (!style)
        return;
      if (style.color !== void 0) {
        ModifyTextHelper.setColor(style.color)(element);
      }
      if (style.size !== void 0) {
        ModifyTextHelper.setSize(style.size)(element);
      }
      if (style.isBold !== void 0) {
        ModifyTextHelper.setBold(style.isBold)(element);
      }
      if (style.isItalics !== void 0) {
        ModifyTextHelper.setItalics(style.isItalics)(element);
      }
    };
    ModifyTextHelper.setColor = (color) => (element) => {
      modify_color_helper_1.default.solidFill(color)(element);
    };
    ModifyTextHelper.setSize = (size) => (element) => {
      if (!size)
        return;
      element.setAttribute("sz", String(Math.round(size)));
    };
    ModifyTextHelper.setBold = (isBold) => (element) => {
      modify_xml_helper_1.default.booleanAttribute("b", isBold)(element);
    };
    ModifyTextHelper.setItalics = (isItalics) => (element) => {
      modify_xml_helper_1.default.booleanAttribute("i", isItalics)(element);
    };
  }
});

// node_modules/pptx-automizer/dist/helper/text-replace-helper.js
var require_text_replace_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/text-replace-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var general_helper_1 = require_general_helper();
    var regexp_escape_1 = __importDefault(require_regexp());
    var xml_helper_1 = require_xml_helper();
    var modify_text_helper_1 = __importDefault(require_modify_text_helper());
    var TextReplaceHelper = class {
      constructor(options, element) {
        const defaultOptions = {
          openingTag: "{{",
          closingTag: "}}"
        };
        this.options = !options ? defaultOptions : Object.assign(Object.assign({}, defaultOptions), options);
        this.element = element;
        this.expressions = {
          openingTag: (0, regexp_escape_1.default)(this.options.openingTag),
          closingTag: (0, regexp_escape_1.default)(this.options.closingTag)
        };
      }
      isolateTaggedNodes() {
        const paragraphs = this.element.getElementsByTagName("a:p");
        const pattern = this.getRegExp();
        for (let p = 0; p < paragraphs.length; p++) {
          const blocks = paragraphs[p].getElementsByTagName("a:r");
          for (let r = 0; r < blocks.length; r++) {
            const block = blocks[r];
            const textContent = this.getTextElement(block).textContent;
            const match = textContent.matchAll(pattern);
            const matches = [...match];
            if (matches.length) {
              this.splitTextBlock(block, matches, textContent);
            }
          }
        }
        return this;
      }
      splitTextBlock(block, matches, textContent) {
        const split = this.getCharacterSplit(matches, textContent);
        let lastBlock = block;
        split.forEach((split2) => {
          lastBlock = this.insertBlock(lastBlock, split2.text);
        });
        block.parentNode.removeChild(block);
      }
      getCharacterSplit(matches, textContent) {
        let lastEnd;
        const split = [];
        matches.forEach((match, s) => {
          const start = match.index;
          const end = match.index + match[0].length;
          if (s === 0 && start > 0) {
            this.pushCharacterSplit(split, 0, start, textContent);
          }
          if (start > lastEnd) {
            this.pushCharacterSplit(split, lastEnd, match.index, textContent);
          }
          this.pushCharacterSplit(split, start, end, textContent);
          const length = textContent.length;
          if (!matches[s + 1] && end < length) {
            this.pushCharacterSplit(split, end, length, textContent);
          }
          lastEnd = end;
        });
        return split;
      }
      pushCharacterSplit(split, from, to, text) {
        split.push({
          from,
          to,
          text: text.slice(from, to)
        });
      }
      insertBlock(block, text) {
        const newBlock = block.cloneNode(true);
        const newTextElement = this.getTextElement(newBlock);
        modify_text_helper_1.default.content(text)(newTextElement);
        xml_helper_1.XmlHelper.insertAfter(newBlock, block);
        return newBlock;
      }
      applyReplacements(replaceTexts) {
        const textBlocks = this.element.getElementsByTagName("a:r");
        const length = textBlocks.length;
        for (let i = 0; i < length; i++) {
          const textBlock = textBlocks[i];
          replaceTexts.forEach((item) => {
            this.applyReplacement(item, textBlock, i);
          });
        }
      }
      applyReplacement(replaceText, textBlock, currentIndex) {
        var _a;
        const replace = this.options.openingTag + replaceText.replace + this.options.closingTag;
        let textNode = this.getTextElement(textBlock);
        const sourceText = (_a = textNode.firstChild) === null || _a === void 0 ? void 0 : _a.textContent;
        if (sourceText === null || sourceText === void 0 ? void 0 : sourceText.includes(replace)) {
          const bys = general_helper_1.GeneralHelper.arrayify(replaceText.by);
          const modifyBlocks = this.assertTextBlocks(bys.length, textBlock);
          bys.forEach((by, blockIndex) => {
            const textNode2 = modifyBlocks[blockIndex].getElementsByTagName("a:t")[0];
            this.updateTextNode(textNode2, sourceText, replace, by);
          });
        }
      }
      assertTextBlocks(length, textBlock) {
        const modifyBlocks = [];
        if (length > 1) {
          for (let i = 1; i < length; i++) {
            const addedTextBlock = textBlock.cloneNode(true);
            xml_helper_1.XmlHelper.insertAfter(addedTextBlock, textBlock);
            modifyBlocks.push(addedTextBlock);
          }
        }
        modifyBlocks.push(textBlock);
        modifyBlocks.reverse();
        return modifyBlocks;
      }
      updateTextNode(textNode, sourceText, replace, by) {
        const replacedText = sourceText.replace(replace, by.text);
        modify_text_helper_1.default.content(replacedText)(textNode);
        if (by.style) {
          const styleParent = textNode.parentNode;
          const styleElement = styleParent.getElementsByTagName("a:rPr")[0];
          modify_text_helper_1.default.style(by.style)(styleElement);
        }
      }
      getTextElement(block) {
        return block.getElementsByTagName("a:t")[0];
      }
      getRegExp() {
        return new RegExp([
          this.expressions.openingTag,
          "[^",
          this.expressions.openingTag,
          this.expressions.closingTag,
          "]+",
          this.expressions.closingTag
        ].join(""), "g");
      }
    };
    exports2.default = TextReplaceHelper;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-shape-helper.js
var require_modify_shape_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-shape-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var general_helper_1 = require_general_helper();
    var text_replace_helper_1 = __importDefault(require_text_replace_helper());
    var modify_text_helper_1 = __importDefault(require_modify_text_helper());
    var map = {
      x: { tag: "a:off", attribute: "x" },
      l: { tag: "a:off", attribute: "x" },
      left: { tag: "a:off", attribute: "x" },
      y: { tag: "a:off", attribute: "y" },
      t: { tag: "a:off", attribute: "y" },
      top: { tag: "a:off", attribute: "y" },
      cx: { tag: "a:ext", attribute: "cx" },
      w: { tag: "a:ext", attribute: "cx" },
      width: { tag: "a:ext", attribute: "cx" },
      cy: { tag: "a:ext", attribute: "cy" },
      h: { tag: "a:ext", attribute: "cy" },
      height: { tag: "a:ext", attribute: "cy" }
    };
    var ModifyShapeHelper = class {
    };
    exports2.default = ModifyShapeHelper;
    ModifyShapeHelper.setSolidFill = (element) => {
      element.getElementsByTagName("a:solidFill")[0].getElementsByTagName("a:schemeClr")[0].setAttribute("val", "accent6");
    };
    ModifyShapeHelper.setText = (text) => (element) => {
      modify_text_helper_1.default.setText(text)(element);
    };
    ModifyShapeHelper.setBulletList = (list) => (element) => {
      modify_text_helper_1.default.setBulletList(list)(element);
    };
    ModifyShapeHelper.replaceText = (replaceText, options) => (element) => {
      const replaceTexts = general_helper_1.GeneralHelper.arrayify(replaceText);
      new text_replace_helper_1.default(options, element).isolateTaggedNodes().applyReplacements(replaceTexts);
    };
    ModifyShapeHelper.setPosition = (pos) => (element) => {
      const aOff = element.getElementsByTagName("a:off");
      if (!(aOff === null || aOff === void 0 ? void 0 : aOff.item(0))) {
        return;
      }
      const xfrm = aOff.item(0).parentNode;
      Object.keys(pos).forEach((key) => {
        let value = Math.round(pos[key]);
        if (typeof value !== "number" || !map[key])
          return;
        value = value < 0 ? 0 : value;
        xfrm.getElementsByTagName(map[key].tag)[0].setAttribute(map[key].attribute, value);
      });
    };
    ModifyShapeHelper.updatePosition = (pos) => (element) => {
      const xfrm = element.getElementsByTagName("a:off")[0].parentNode;
      Object.keys(pos).forEach((key) => {
        let value = Math.round(pos[key]);
        if (typeof value !== "number" || !map[key])
          return;
        const currentValue = xfrm.getElementsByTagName(map[key].tag)[0].getAttribute(map[key].attribute);
        value += Number(currentValue);
        xfrm.getElementsByTagName(map[key].tag)[0].setAttribute(map[key].attribute, value);
      });
    };
    ModifyShapeHelper.rotate = (degrees) => (element) => {
      const spPr = element.getElementsByTagName("p:spPr");
      if (spPr) {
        const xfrm = spPr.item(0).getElementsByTagName("a:xfrm").item(0);
        degrees = degrees < 0 ? 360 + degrees : degrees;
        xfrm.setAttribute("rot", String(Math.round(degrees * 6e4)));
      }
    };
  }
});

// node_modules/pptx-automizer/dist/modify/modify-table.js
var require_modify_table = __commonJS({
  "node_modules/pptx-automizer/dist/modify/modify-table.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModifyTable = void 0;
    var xml_helper_1 = require_xml_helper();
    var modify_xml_helper_1 = __importDefault(require_modify_xml_helper());
    var modify_text_helper_1 = __importDefault(require_modify_text_helper());
    var index_1 = require_dist();
    var general_helper_1 = require_general_helper();
    var ModifyTable = class {
      constructor(table, data) {
        var _a;
        this.maxCols = 0;
        this.row = (index, children) => {
          return {
            "a:tr": {
              forceCreate: true,
              index,
              children
            }
          };
        };
        this.column = (index, children) => {
          return {
            "a:tc": {
              index,
              children,
              fromPrevious: true
            }
          };
        };
        this.cell = (value, style) => {
          return {
            "a:txBody": {
              children: {
                "a:t": {
                  modify: modify_text_helper_1.default.content(value)
                },
                "a:rPr": {
                  modify: modify_text_helper_1.default.style(style)
                },
                "a:r": {
                  collection: (collection) => {
                    xml_helper_1.XmlHelper.sliceCollection(collection, 1);
                  }
                }
              }
            },
            "a:tcPr": Object.assign({}, this.setCellStyle(style))
          };
        };
        this.expandRows = (count, rowId) => {
          const tplRow = this.xml.getElementsByTagName("a:tr").item(rowId);
          for (let r = 1; r <= count; r++) {
            const newRow = tplRow.cloneNode(true);
            xml_helper_1.XmlHelper.insertAfter(newRow, tplRow);
            this.updateId(newRow, "a16:rowId", r);
          }
        };
        this.expandSpanColumns = (count, colId, gridSpan) => {
          for (let cs = 1; cs <= count; cs++) {
            const rows = this.xml.getElementsByTagName("a:tr");
            for (let r = 0; r < rows.length; r++) {
              const row = rows.item(r);
              const columns = row.getElementsByTagName("a:tc");
              const maxC = colId + gridSpan;
              for (let c = colId; c < maxC; c++) {
                const sourceCell = columns.item(c);
                const insertAfter = columns.item(c + gridSpan - 1);
                const clone = sourceCell.cloneNode(true);
                xml_helper_1.XmlHelper.insertAfter(clone, insertAfter);
              }
            }
          }
          this.expandGrid(count, colId, gridSpan);
        };
        this.expandColumns = (count, colId) => {
          for (let cs = 1; cs <= count; cs++) {
            const rows = this.xml.getElementsByTagName("a:tr");
            for (let r = 0; r < rows.length; r++) {
              const row = rows.item(r);
              const columns = row.getElementsByTagName("a:tc");
              const sourceCell = columns.item(colId);
              const newCell = this.getExpandCellClone(columns, sourceCell, colId);
              xml_helper_1.XmlHelper.insertAfter(newCell, sourceCell);
            }
          }
          this.expandGrid(count, colId, 1);
        };
        this.expandGrid = (count, colId, gridSpan) => {
          const tblGrid = this.xml.getElementsByTagName("a:tblGrid").item(0);
          for (let cs = 1; cs <= count; cs++) {
            const maxC = colId + gridSpan;
            for (let c = colId; c < maxC; c++) {
              const sourceTblGridCol = tblGrid.getElementsByTagName("a:gridCol").item(c);
              const newCol = sourceTblGridCol.cloneNode(true);
              xml_helper_1.XmlHelper.insertAfter(newCol, sourceTblGridCol);
              this.updateId(newCol, "a16:colId", c * (cs + 1) * colId * 1e3);
            }
          }
        };
        this.updateId = (element, tag, id) => {
          const idElement = element.getElementsByTagName(tag).item(0);
          const previousId = Number(idElement.getAttribute("val"));
          idElement.setAttribute("val", String(previousId + id));
        };
        this.data = data;
        this.table = new modify_xml_helper_1.default(table);
        this.xml = table;
        (_a = this.data) === null || _a === void 0 ? void 0 : _a.body.forEach((row) => {
          this.maxCols = row.values.length > this.maxCols ? row.values.length : this.maxCols;
        });
      }
      modify(params) {
        this.params = params;
        this.setRows();
        this.setGridCols();
        this.sliceRows();
        this.sliceCols();
        return this;
      }
      setRows() {
        var _a, _b;
        const alreadyExpanded = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.expand) === null || _b === void 0 ? void 0 : _b.find((expand) => expand.mode === "column");
        this.data.body.forEach((row, r) => {
          row.values.forEach((cell, c) => {
            var _a2;
            const rowStyles = row.styles && row.styles[c] ? row.styles[c] : {};
            this.table.modify(this.row(r, this.column(c, this.cell(cell, rowStyles))));
            this.table.modify({
              "a16:rowId": {
                index: r,
                modify: modify_xml_helper_1.default.attribute("val", r)
              }
            });
            if (((_a2 = this.params) === null || _a2 === void 0 ? void 0 : _a2.expand) && !alreadyExpanded) {
              this.expandOtherMergedCellsInColumn(c, r);
            }
          });
        });
      }
      expandOtherMergedCellsInColumn(c, r) {
        const rows = this.xml.getElementsByTagName("a:tr");
        for (let rs = 0; rs < rows.length; rs++) {
          if (r !== rs) {
            const row = rows.item(r);
            const columns = row.getElementsByTagName("a:tc");
            const sourceCell = columns.item(c);
            this.expandGridSpan(sourceCell);
          }
        }
      }
      setGridCols() {
        for (let c = 0; c <= this.maxCols; c++) {
          this.table.modify({
            "a:gridCol": {
              index: c
            },
            "a16:colId": {
              index: c,
              modify: modify_xml_helper_1.default.attribute("val", c)
            }
          });
        }
      }
      sliceRows() {
        this.table.modify({
          "a:tbl": this.slice("a:tr", this.data.body.length)
        });
      }
      sliceCols() {
        this.table.modify({
          "a:tblGrid": this.slice("a:gridCol", this.maxCols)
        });
      }
      setCellStyle(style) {
        const cellProps = {
          modify: [],
          children: {}
        };
        if (style.background) {
          cellProps.modify.push(index_1.ModifyColorHelper.solidFill(style.background, "last"));
        }
        if (style.border) {
          cellProps.children = this.setCellBorder(style);
        }
        return cellProps;
      }
      setCellBorder(style) {
        const borders = general_helper_1.GeneralHelper.arrayify(style.border);
        const sortBorderTags = ["lnB", "lnT", "lnR", "lnL"];
        const modifications = {};
        borders.sort((b1, b2) => sortBorderTags.indexOf(b1.tag) < sortBorderTags.indexOf(b2.tag) ? -1 : 1).forEach((border) => {
          const tag = "a:" + border.tag;
          const modifyCell = [];
          if (border.color) {
            modifyCell.push(index_1.ModifyColorHelper.solidFill(border.color));
          }
          if (border.weight) {
            modifyCell.push(modify_xml_helper_1.default.attribute("w", border.weight));
          }
          modifications[tag] = {
            modify: modifyCell
          };
          if (border.type) {
            modifications[tag].children = {
              "a:prstDash": {
                modify: modify_xml_helper_1.default.attribute("val", border.type)
              }
            };
          }
        });
        return modifications;
      }
      slice(tag, length) {
        return {
          children: {
            [tag]: {
              collection: (collection) => {
                xml_helper_1.XmlHelper.sliceCollection(collection, length);
              }
            }
          }
        };
      }
      adjustHeight() {
        const tableHeight = this.getTableSize("cy");
        const rowHeight = tableHeight / this.data.body.length;
        this.data.body.forEach((row, r) => {
          this.table.modify({
            "a:tr": {
              index: r,
              modify: modify_xml_helper_1.default.attribute("h", Math.round(rowHeight))
            }
          });
        });
        return this;
      }
      adjustWidth() {
        var _a, _b, _c;
        const tableWidth = this.getTableSize("cx");
        const rowWidth = tableWidth / ((_b = (_a = this.data.body[0]) === null || _a === void 0 ? void 0 : _a.values) === null || _b === void 0 ? void 0 : _b.length) || 1;
        (_c = this.data.body[0]) === null || _c === void 0 ? void 0 : _c.values.forEach((cell, c) => {
          this.table.modify({
            "a:gridCol": {
              index: c,
              modify: modify_xml_helper_1.default.attribute("w", Math.round(rowWidth))
            }
          });
        });
        return this;
      }
      updateColumnWidth(c, size) {
        const tableWidth = this.getTableSize("cx");
        const targetSize = Math.round(size);
        let currentSize = 0;
        this.table.modify({
          "a:gridCol": {
            index: c,
            modify: [
              (ele) => {
                currentSize = Number(ele.getAttribute("w"));
              },
              modify_xml_helper_1.default.attribute("w", targetSize)
            ]
          }
        });
        const diff = currentSize - targetSize;
        const targetWidth = tableWidth - diff;
        this.setSize("cx", targetWidth);
        return this;
      }
      updateRowHeight(r, size) {
        const tableSize = this.getTableSize("cy");
        const targetSize = Math.round(size);
        let currentSize = 0;
        this.table.modify({
          "a:tr": {
            index: r,
            modify: [
              (ele) => {
                currentSize = Number(ele.getAttribute("h"));
              },
              modify_xml_helper_1.default.attribute("h", targetSize)
            ]
          }
        });
        const diff = currentSize - targetSize;
        const targetTableSize = tableSize - diff;
        this.setSize("cy", targetTableSize);
        return this;
      }
      setSize(orientation, size) {
        const sizeElement = this.xml.getElementsByTagName("p:xfrm")[0].getElementsByTagName("a:ext")[0];
        sizeElement.setAttribute(orientation, String(size));
      }
      getTableSize(orientation) {
        return Number(this.xml.getElementsByTagName("p:xfrm")[0].getElementsByTagName("a:ext")[0].getAttribute(orientation));
      }
      getExpandCellClone(columns, sourceCell, colId) {
        const hasGridSpan = this.expandGridSpan(sourceCell);
        if (hasGridSpan) {
          return columns.item(colId + 1).cloneNode(true);
        }
        const hMerge = sourceCell.getAttribute("hMerge");
        if (hMerge) {
          for (let findCol = colId - 1; colId >= 0; colId--) {
            const previousSibling = columns.item(findCol);
            if (!previousSibling) {
              break;
            }
            const siblingHasSpan = this.expandGridSpan(previousSibling);
            if (siblingHasSpan) {
              break;
            }
          }
        }
        return sourceCell.cloneNode(true);
      }
      expandGridSpan(sourceCell) {
        const gridSpan = sourceCell.getAttribute("gridSpan");
        if (gridSpan) {
          const incrementGridSpan = Number(gridSpan) + 1;
          sourceCell.setAttribute("gridSpan", String(incrementGridSpan));
          return true;
        }
      }
    };
    exports2.ModifyTable = ModifyTable;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-table-helper.js
var require_modify_table_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-table-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var modify_table_1 = require_modify_table();
    var xml_slide_helper_1 = require_xml_slide_helper();
    var ModifyTableHelper = class {
    };
    exports2.default = ModifyTableHelper;
    ModifyTableHelper.setTable = (data, params) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element, data);
      if (params === null || params === void 0 ? void 0 : params.expand) {
        params === null || params === void 0 ? void 0 : params.expand.forEach((expand) => {
          const tableInfo = xml_slide_helper_1.XmlSlideHelper.readTableInfo(element);
          const targetCell = tableInfo.find((infoCell) => infoCell.textContent === expand.tag);
          if (targetCell) {
            if (expand.mode === "row") {
              modTable.expandRows(expand.count, targetCell.row);
            } else {
              if (targetCell.gridSpan) {
                modTable.expandSpanColumns(expand.count, targetCell.column, targetCell.gridSpan);
              } else {
                modTable.expandColumns(expand.count, targetCell.column);
              }
            }
          }
        });
      }
      modTable.modify(params);
      if (params === null || params === void 0 ? void 0 : params.setHeight) {
        modTable.setSize("cy", params.setHeight);
      }
      if (params === null || params === void 0 ? void 0 : params.setWidth) {
        modTable.setSize("cx", params.setWidth);
      }
      if (!params || (params === null || params === void 0 ? void 0 : params.adjustHeight)) {
        modTable.adjustHeight();
      }
      if (!params || (params === null || params === void 0 ? void 0 : params.adjustWidth)) {
        modTable.adjustWidth();
      }
    };
    ModifyTableHelper.setTableData = (data) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element, data);
      modTable.modify();
    };
    ModifyTableHelper.adjustHeight = (data) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element, data);
      modTable.adjustHeight();
    };
    ModifyTableHelper.adjustWidth = (data) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element, data);
      modTable.adjustWidth();
    };
    ModifyTableHelper.updateColumnWidth = (index, size) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element);
      modTable.updateColumnWidth(index, size);
    };
    ModifyTableHelper.updateRowHeight = (index, size) => (element) => {
      const modTable = new modify_table_1.ModifyTable(element);
      modTable.updateRowHeight(index, size);
    };
  }
});

// node_modules/pptx-automizer/dist/modify/modify-chart.js
var require_modify_chart = __commonJS({
  "node_modules/pptx-automizer/dist/modify/modify-chart.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ModifyChart = void 0;
    var xml_helper_1 = require_xml_helper();
    var cell_id_helper_1 = __importDefault(require_cell_id_helper());
    var modify_xml_helper_1 = __importDefault(require_modify_xml_helper());
    var modify_text_helper_1 = __importDefault(require_modify_text_helper());
    var modify_color_helper_1 = __importDefault(require_modify_color_helper());
    var index_1 = require_dist();
    var ModifyChart = class {
      constructor(chart, workbook, data, slot) {
        this.setSeriesDataLabels = () => {
          this.data.series.forEach((series, s) => {
            var _a, _b, _c;
            this.chart.modify(this.series(s, this.seriesDataLabel(s, (_a = series.style) === null || _a === void 0 ? void 0 : _a.label)));
            if ((_b = series.style) === null || _b === void 0 ? void 0 : _b.label) {
              index_1.modify.setDataLabelAttributes(Object.assign({ applyToSeries: s }, (_c = series.style) === null || _c === void 0 ? void 0 : _c.label))(null, this.chart.root);
            }
            this.data.categories.forEach((category, c) => {
              this.chart.modify(this.series(s, this.seriesDataLabelsRange(c, category.label)));
            });
          });
        };
        this.series = (index, children) => {
          return {
            "c:ser": {
              index,
              children
            }
          };
        };
        this.chartPoint = (index, idx, style) => {
          if (!(style === null || style === void 0 ? void 0 : style.color) && !(style === null || style === void 0 ? void 0 : style.border) && !(style === null || style === void 0 ? void 0 : style.marker))
            return;
          return {
            "c:dPt": {
              index,
              children: Object.assign(Object.assign(Object.assign({ "c:idx": {
                modify: modify_xml_helper_1.default.attribute("val", idx)
              } }, this.chartPointFill(style === null || style === void 0 ? void 0 : style.color)), this.chartPointBorder(style === null || style === void 0 ? void 0 : style.border)), this.chartPointMarker(style === null || style === void 0 ? void 0 : style.marker))
            }
          };
        };
        this.chartPointFill = (color) => {
          if (!(color === null || color === void 0 ? void 0 : color.type))
            return;
          return {
            "c:spPr": {
              modify: modify_color_helper_1.default.solidFill(color)
            }
          };
        };
        this.chartPointMarker = (markerStyle) => {
          if (!markerStyle)
            return;
          return {
            "c:marker": {
              isRequired: false,
              children: {
                "c:spPr": {
                  modify: modify_color_helper_1.default.solidFill(markerStyle.color)
                }
              }
            }
          };
        };
        this.chartPointBorder = (style) => {
          if (!style)
            return;
          const modify = [];
          if (style.color) {
            modify.push(modify_color_helper_1.default.solidFill(style.color));
            modify.push(modify_color_helper_1.default.removeNoFill());
          }
          if (style.weight) {
            modify.push(modify_xml_helper_1.default.attribute("w", style.weight));
          }
          return {
            "a:ln": {
              modify
            }
          };
        };
        this.chartPointLabel = (index, idx, labelStyle) => {
          if (!labelStyle)
            return;
          return {
            "c:dLbls": {
              children: {
                "c:dLbl": {
                  index,
                  fromIndex: 0,
                  children: {
                    "c:idx": {
                      modify: modify_xml_helper_1.default.attribute("val", String(idx))
                    },
                    "a:pPr": {
                      modify: modify_color_helper_1.default.solidFill(labelStyle === null || labelStyle === void 0 ? void 0 : labelStyle.color),
                      children: {
                        "a:defRPr": {
                          isRequired: false,
                          modify: modify_text_helper_1.default.style(labelStyle)
                        }
                      }
                    },
                    "a:fld": {
                      children: {
                        "a:rPr": {
                          modify: [
                            modify_color_helper_1.default.solidFill(labelStyle === null || labelStyle === void 0 ? void 0 : labelStyle.color),
                            modify_text_helper_1.default.style(labelStyle)
                          ]
                        },
                        "a:defRPr": {
                          isRequired: false,
                          modify: [
                            modify_color_helper_1.default.solidFill(labelStyle === null || labelStyle === void 0 ? void 0 : labelStyle.color),
                            modify_text_helper_1.default.style(labelStyle)
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }
          };
        };
        this.seriesId = (series) => {
          return {
            "c:idx": {
              modify: modify_xml_helper_1.default.attribute("val", series)
            },
            "c:order": {
              modify: modify_xml_helper_1.default.attribute("val", series + 1)
            }
          };
        };
        this.seriesLabel = (label, series) => {
          return {
            "c:f": {
              modify: modify_xml_helper_1.default.range(series + 1)
            },
            "c:v": {
              modify: modify_text_helper_1.default.content(label)
            }
          };
        };
        this.extSeriesLabel = (label, series) => {
          return {
            "cx:f": {
              modify: modify_xml_helper_1.default.range(series + 1)
            },
            "cx:v": {
              modify: modify_text_helper_1.default.content(label)
            }
          };
        };
        this.seriesStyle = (series) => {
          var _a;
          if (!(series === null || series === void 0 ? void 0 : series.style))
            return;
          return {
            "c:spPr": {
              modify: modify_color_helper_1.default.solidFill(series.style.color)
            },
            "c:marker": {
              isRequired: false,
              children: {
                "c:spPr": {
                  isRequired: false,
                  modify: modify_color_helper_1.default.solidFill((_a = series.style.marker) === null || _a === void 0 ? void 0 : _a.color)
                }
              }
            }
          };
        };
        this.seriesDataLabelsRange = (r, value) => {
          return {
            "c15:datalabelsRange": {
              isRequired: false,
              children: {
                "c:pt": {
                  index: r,
                  modify: modify_xml_helper_1.default.value(value, r)
                },
                "c15:f": {
                  modify: modify_xml_helper_1.default.range(0, this.height)
                },
                "c:ptCount": {
                  modify: modify_xml_helper_1.default.attribute("val", this.height)
                }
              }
            }
          };
        };
        this.seriesDataLabel = (s, style) => {
          return {
            "c:dLbls": {
              isRequired: false,
              children: {
                "a:pPr": {
                  modify: modify_color_helper_1.default.solidFill(style === null || style === void 0 ? void 0 : style.color),
                  children: {
                    "a:defRPr": {
                      modify: modify_text_helper_1.default.style(style)
                    }
                  }
                }
              }
            }
          };
        };
        this.extPoint = (r, c, value) => {
          return {
            children: {
              "cx:pt": {
                index: r,
                modify: [
                  modify_xml_helper_1.default.attribute("idx", r),
                  modify_xml_helper_1.default.textContent(value)
                ]
              },
              "cx:f": {
                modify: modify_xml_helper_1.default.range(c, this.height)
              },
              "cx:lvl": {
                modify: modify_xml_helper_1.default.attribute("ptCount", this.height)
              }
            }
          };
        };
        this.extSeries = (index, children) => {
          return {
            "cx:series": {
              index,
              children
            }
          };
        };
        this.point = (r, c, value) => {
          return {
            children: {
              "c:pt": {
                index: r,
                modify: modify_xml_helper_1.default.value(value, r)
              },
              "c:f": {
                modify: modify_xml_helper_1.default.range(c, this.height)
              },
              "c:ptCount": {
                modify: modify_xml_helper_1.default.attribute("val", this.height)
              }
            }
          };
        };
        this.data = data;
        this.chart = new modify_xml_helper_1.default(chart);
        this.workbook = new modify_xml_helper_1.default(workbook.sheet);
        this.workbookTable = workbook.table ? new modify_xml_helper_1.default(workbook.table) : null;
        this.sharedStrings = workbook.sharedStrings;
        this.columns = this.setColumns(slot);
        this.height = this.data.categories.length;
        this.width = this.columns.length;
      }
      modify() {
        this.setValues();
        this.setSeries();
        this.setSeriesDataLabels();
        this.setPointStyles();
        this.sliceChartSpace();
        this.modifyWorkbook();
      }
      modifyExtended() {
        this.setExtData();
        this.setExtSeries();
        this.sliceExtChartSpace();
        this.modifyWorkbook();
      }
      modifyWorkbook() {
        this.prepareWorkbook();
        this.setWorkbook();
        this.sliceWorkbook();
        if (this.workbookTable) {
          this.setWorkbookTable();
          this.sliceWorkbookTable();
        }
      }
      setColumns(slots) {
        const columns = [];
        slots.forEach((slot) => {
          const series = slot.series;
          const index = slot.index;
          const targetCol = slot.targetCol;
          const targetYCol = slot.targetYCol || 1;
          const label = slot.label ? slot.label : series.label;
          const mapData = slot.mapData !== void 0 ? slot.mapData : (point) => point;
          const isStrRef = slot.isStrRef !== void 0 ? slot.isStrRef : true;
          const worksheetCb = (point, r, category) => {
            return this.workbook.modify(this.rowValues(r, targetCol, mapData(point, category)));
          };
          const chartCb = slot.type !== void 0 && this[slot.type] !== void 0 && typeof this[slot.type] === "function" ? (point, r, category) => {
            return this[slot.type](r, targetCol, point, category, slot.tag, mapData, targetYCol);
          } : null;
          const column = {
            series: index,
            label,
            worksheet: worksheetCb,
            chart: chartCb,
            isStrRef
          };
          columns.push(column);
        });
        return columns;
      }
      setValues() {
        this.setValuesByCategory((col) => {
          return this.series(col.series, col.modTags);
        });
      }
      setExtData() {
        this.setValuesByCategory((col) => {
          return {
            "cx:data": {
              children: col.modTags
            }
          };
        });
      }
      setValuesByCategory(cb) {
        this.data.categories.forEach((category, c) => {
          this.columns.filter((col) => col.chart).forEach((col, s) => {
            if (category.values[col.series] === void 0) {
              throw new Error(`No value for category "${category.label}" at series "${col.label}".`);
            }
            col.modTags = col.chart(category.values[col.series], c, category);
            this.chart.modify(cb(col));
          });
        });
      }
      setPointStyles() {
        const count = {};
        this.data.categories.forEach((category, c) => {
          if (category.styles) {
            category.styles.forEach((style, s) => {
              if (style === null || !Object.values(style).length)
                return;
              count[s] = !count[s] ? 0 : count[s];
              this.chart.modify(this.series(s, this.chartPoint(count[s], c, style)));
              if (style.label) {
                this.chart.modify(this.series(s, this.chartPointLabel(count[s], c, style.label)));
              }
              count[s]++;
            });
          }
        });
      }
      setSeries() {
        this.columns.forEach((column, colId) => {
          if (column.isStrRef === true) {
            this.chart.modify(this.series(column.series, Object.assign(Object.assign(Object.assign({}, this.seriesId(column.series)), this.seriesLabel(column.label, colId)), this.seriesStyle(this.data.series[column.series]))));
          }
        });
      }
      setExtSeries() {
        this.columns.forEach((column, colId) => {
          if (column.isStrRef === true) {
            this.chart.modify(this.extSeries(column.series, Object.assign({}, this.extSeriesLabel(column.label, colId))));
          }
        });
      }
      sliceChartSpace() {
        this.chart.modify({
          "c:plotArea": this.slice("c:ser", this.data.series.length)
        });
        this.columns.filter((column) => column.modTags).forEach((column) => {
          const sliceMod = {};
          Object.keys(column.modTags).forEach((tag) => {
            sliceMod[tag] = this.slice("c:pt", this.height);
          });
          this.chart.modify(this.series(column.series, sliceMod));
        });
      }
      sliceExtChartSpace() {
        this.chart.modify({
          "cx:plotArea": this.slice("cx:series", this.data.series.length)
        });
        this.columns.filter((column) => column.modTags).forEach((column) => {
          const sliceMod = {};
          Object.keys(column.modTags).forEach((tag) => {
            sliceMod[tag] = this.slice("cx:pt", this.height);
          });
          this.chart.modify({
            "cx:data": { index: column.series, children: sliceMod }
          });
        });
      }
      /*
        There might be rows in an excel workbook that appear to be empty, but
        contain either no cells or none with a "v"-tag. These rows are removed
        by prepareWorkbook(). See https://github.com/singerla/pptx-automizer/issues/11
       */
      prepareWorkbook() {
        const rows = this.workbook.root.getElementsByTagName("row");
        for (const r in rows) {
          if (!rows[r].getElementsByTagName)
            continue;
          const values = rows[r].getElementsByTagName("v");
          if (values.length === 0) {
            const toRemove = rows[r];
            toRemove.parentNode.removeChild(toRemove);
          }
        }
      }
      setWorkbook() {
        this.workbook.modify(this.spanString());
        this.workbook.modify(this.rowAttributes(0, 1));
        this.data.categories.forEach((category, c) => {
          const r = c + 1;
          this.workbook.modify(this.rowLabels(r, category.label));
          this.workbook.modify(this.rowAttributes(r, r + 1));
          this.columns.forEach((addCol) => addCol.worksheet(category.values[addCol.series], r, category));
        });
        this.columns.forEach((addCol, s) => {
          this.workbook.modify(this.colLabel(s + 1, addCol.label));
        });
      }
      sliceWorkbook() {
        this.data.categories.forEach((category, c) => {
          const r = c + 1;
          this.workbook.modify({
            row: Object.assign({ index: r }, this.slice("c", this.width + 1))
          });
        });
        this.workbook.modify({
          row: Object.assign({}, this.slice("c", this.width + 1))
        });
        this.workbook.modify({
          sheetData: this.slice("row", this.height + 1)
        });
      }
      defaultSeries(r, targetCol, point, category) {
        return {
          "c:val": this.point(r, targetCol, point),
          "c:cat": this.point(r, 0, category.label)
        };
      }
      xySeries(r, targetCol, point, category, tag, mapData, targetYCol) {
        return {
          "c:xVal": this.point(r, targetCol, point),
          "c:yVal": this.point(r, targetYCol, category.y)
        };
      }
      customSeries(r, targetCol, point, category, tag, mapData) {
        return {
          [tag]: this.point(r, targetCol, mapData(point, category))
        };
      }
      extendedSeries(r, targetCol, point, category) {
        return {
          "cx:strDim": this.extPoint(r, 0, category.label),
          "cx:numDim": this.extPoint(r, targetCol, point)
        };
      }
      colLabel(c, label) {
        return {
          row: {
            modify: modify_xml_helper_1.default.attribute("spans", `1:${this.width}`),
            children: {
              c: {
                index: c,
                modify: modify_xml_helper_1.default.attribute("r", cell_id_helper_1.default.getCellAddressString(c, 0)),
                children: this.sharedString(label)
              }
            }
          }
        };
      }
      rowAttributes(r, rowId) {
        return {
          row: {
            index: r,
            fromPrevious: true,
            modify: [
              modify_xml_helper_1.default.attribute("spans", `1:${this.width}`),
              modify_xml_helper_1.default.attribute("r", String(rowId))
            ]
          }
        };
      }
      rowLabels(r, label) {
        return {
          row: {
            index: r,
            fromPrevious: true,
            children: {
              c: {
                modify: modify_xml_helper_1.default.attribute("r", cell_id_helper_1.default.getCellAddressString(0, r)),
                children: this.sharedString(label)
              }
            }
          }
        };
      }
      rowValues(r, c, value) {
        return {
          row: {
            index: r,
            fromPrevious: true,
            children: {
              c: {
                index: c,
                fromPrevious: true,
                modify: modify_xml_helper_1.default.attribute("r", cell_id_helper_1.default.getCellAddressString(c, r)),
                children: this.cellValue(value)
              }
            }
          }
        };
      }
      slice(tag, length) {
        return {
          children: {
            [tag]: {
              collection: (collection) => {
                xml_helper_1.XmlHelper.sliceCollection(collection, length);
              }
            }
          }
        };
      }
      spanString() {
        return {
          dimension: {
            modify: modify_xml_helper_1.default.attribute("ref", cell_id_helper_1.default.getSpanString(0, 1, this.width, this.height))
          }
        };
      }
      cellValue(value) {
        return {
          v: {
            modify: modify_text_helper_1.default.content(value)
          }
        };
      }
      sharedString(label) {
        return this.cellValue(xml_helper_1.XmlHelper.appendSharedString(this.sharedStrings, label));
      }
      setWorkbookTable() {
        this.workbookTable.modify({
          table: {
            modify: modify_xml_helper_1.default.attribute("ref", cell_id_helper_1.default.getSpanString(0, 1, this.width, this.height))
          },
          tableColumns: {
            modify: modify_xml_helper_1.default.attribute("count", this.width + 1)
          }
        });
        this.setWorkbookTableFirstColumn();
        this.columns.forEach((addCol, s) => {
          this.setWorkbookTableColumn(s + 1, addCol.label);
        });
      }
      setWorkbookTableFirstColumn() {
        this.workbookTable.modify({
          tableColumn: {
            index: 0,
            modify: modify_xml_helper_1.default.attribute("id", 1)
          }
        });
      }
      setWorkbookTableColumn(c, label) {
        this.workbookTable.modify({
          tableColumn: {
            index: c,
            fromPrevious: true,
            modify: [
              modify_xml_helper_1.default.attribute("id", c + 1),
              modify_xml_helper_1.default.attribute("name", label)
            ]
          }
        });
      }
      sliceWorkbookTable() {
        this.workbookTable.modify({
          table: this.slice("tableColumn", this.width + 1)
        });
      }
    };
    exports2.ModifyChart = ModifyChart;
  }
});

// node_modules/pptx-automizer/dist/helper/modify-chart-helper.js
var require_modify_chart_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-chart-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var modify_chart_1 = require_modify_chart();
    var modify_xml_helper_1 = __importDefault(require_modify_xml_helper());
    var xml_helper_1 = require_xml_helper();
    var modify_color_helper_1 = __importDefault(require_modify_color_helper());
    var ModifyChartHelper = class {
    };
    exports2.default = ModifyChartHelper;
    _a = ModifyChartHelper;
    ModifyChartHelper.setChartData = (data) => (element, chart, workbook) => {
      const slots = [];
      data.series.forEach((series, s) => {
        slots.push({
          index: s,
          series,
          targetCol: s + 1,
          type: "defaultSeries"
        });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modify();
    };
    ModifyChartHelper.setChartVerticalLines = (data) => (element, chart, workbook) => {
      const slots = [];
      slots.push({
        label: `Y-Values`,
        mapData: (point, category) => category.y,
        targetCol: 1
      });
      data.series.forEach((series, s) => {
        slots.push({
          index: s,
          series,
          targetCol: s + 2,
          type: "xySeries"
        });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modify();
    };
    ModifyChartHelper.setChartScatter = (data) => (element, chart, workbook) => {
      const slots = [];
      data.series.forEach((series, s) => {
        const colId = s * 2;
        slots.push({
          index: s,
          series,
          targetCol: colId + 1,
          type: "customSeries",
          tag: "c:xVal",
          mapData: (point) => point.x
        });
        slots.push({
          label: `${series.label}-Y-Value`,
          index: s,
          series,
          targetCol: colId + 2,
          type: "customSeries",
          tag: "c:yVal",
          mapData: (point) => point.y,
          isStrRef: false
        });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modify();
    };
    ModifyChartHelper.setChartCombo = (data) => (element, chart, workbook) => {
      const slots = [];
      slots.push({
        index: 0,
        series: data.series[0],
        targetCol: 1,
        type: "defaultSeries"
      });
      slots.push({
        index: 1,
        label: `Y-Values`,
        mapData: (point, category) => category.y,
        targetCol: 2
      });
      data.series.forEach((series, s) => {
        if (s > 0)
          slots.push({
            index: s,
            series,
            targetCol: s + 2,
            targetYCol: 2,
            type: "xySeries"
          });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modify();
      ModifyChartHelper.setAxisRange({
        axisIndex: 1,
        min: 0,
        max: data.categories.length
      })(element, chart);
    };
    ModifyChartHelper.setChartBubbles = (data) => (element, chart, workbook) => {
      const slots = [];
      data.series.forEach((series, s) => {
        const colId = s * 3;
        slots.push({
          index: s,
          series,
          targetCol: colId + 1,
          type: "customSeries",
          tag: "c:xVal",
          mapData: (point) => point.x
        });
        slots.push({
          label: `${series.label}-Y-Value`,
          index: s,
          series,
          targetCol: colId + 2,
          type: "customSeries",
          tag: "c:yVal",
          mapData: (point) => point.y,
          isStrRef: false
        });
        slots.push({
          label: `${series.label}-Size`,
          index: s,
          series,
          targetCol: colId + 3,
          type: "customSeries",
          tag: "c:bubbleSize",
          mapData: (point) => point.size,
          isStrRef: false
        });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modify();
    };
    ModifyChartHelper.setExtendedChartData = (data) => (element, chart, workbook) => {
      const slots = [];
      data.series.forEach((series, s) => {
        slots.push({
          index: s,
          series,
          targetCol: s + 1,
          type: "extendedSeries"
        });
      });
      new modify_chart_1.ModifyChart(chart, workbook, data, slots).modifyExtended();
    };
    ModifyChartHelper.readWorkbookData = (data) => (element, chart, workbook) => {
      const getSharedString = (index) => {
        var _b;
        return (_b = workbook.sharedStrings.getElementsByTagName("si").item(index)) === null || _b === void 0 ? void 0 : _b.textContent;
      };
      const parseCell = (cell) => {
        const type = cell.getAttribute("t");
        const cellValue = cell.getElementsByTagName("v").item(0).textContent;
        if (type === "s") {
          return getSharedString(Number(cellValue));
        } else {
          return Number(cellValue);
        }
      };
      const rows = workbook.sheet.getElementsByTagName("row");
      for (let r = 0; r < rows.length; r++) {
        const row = rows.item(r);
        const columns = row.getElementsByTagName("c");
        const rowData = [];
        for (let c = 0; c < columns.length; c++) {
          rowData.push(parseCell(columns.item(c)));
        }
        data.push(rowData);
      }
    };
    ModifyChartHelper.readChartInfo = (info) => (element, chart, workbook) => {
      const series = chart.getElementsByTagName("c:ser");
      xml_helper_1.XmlHelper.modifyCollection(series, (tmpSeries, s) => {
        const solidFill = tmpSeries.getElementsByTagName("a:solidFill").item(0);
        if (!solidFill) {
          return;
        }
        const schemeClr = solidFill.getElementsByTagName("a:schemeClr").item(0);
        const srgbClr = solidFill.getElementsByTagName("a:srgbClr").item(0);
        const colorElement = schemeClr ? schemeClr : srgbClr;
        info.series.push({
          seriesId: s,
          colorType: colorElement.tagName,
          colorValue: colorElement.getAttribute("val")
        });
      });
      const chartTagName = series.item(0).parentNode.nodeName;
      info.chartType = chartTagName === null || chartTagName === void 0 ? void 0 : chartTagName.split(":")[1];
    };
    ModifyChartHelper.setAxisRange = (range) => (element, chart) => {
      const axis = chart.getElementsByTagName("c:valAx")[range.axisIndex || 0];
      if (!axis)
        return;
      ModifyChartHelper.setAxisAttribute(axis, "c:majorUnit", range.majorUnit);
      ModifyChartHelper.setAxisAttribute(axis, "c:minorUnit", range.minorUnit);
      ModifyChartHelper.setAxisAttribute(axis, "c:numFmt", range.formatCode, "formatCode");
      ModifyChartHelper.setAxisAttribute(axis, "c:numFmt", range.sourceLinked, "sourceLinked");
      const scaling = axis.getElementsByTagName("c:scaling")[0];
      ModifyChartHelper.setAxisAttribute(scaling, "c:min", range.min);
      ModifyChartHelper.setAxisAttribute(scaling, "c:max", range.max);
    };
    ModifyChartHelper.setAxisAttribute = (element, tag, value, attribute) => {
      if (value === void 0 || !element)
        return;
      const target = element.getElementsByTagName(tag);
      if (target.length > 0) {
        attribute = attribute || "val";
        if (typeof value === "boolean") {
          modify_xml_helper_1.default.booleanAttribute(attribute, value)(target[0]);
        } else {
          modify_xml_helper_1.default.attribute(attribute, value)(target[0]);
        }
      }
    };
    ModifyChartHelper.minimizeChartLegend = () => (element, chart, workbook) => {
      _a.setLegendPosition({
        w: 0,
        h: 0,
        x: 0,
        y: 0
      })(element, chart, workbook);
    };
    ModifyChartHelper.removeChartLegend = () => (element, chart) => {
      if (chart.getElementsByTagName("c:legend")) {
        xml_helper_1.XmlHelper.remove(chart.getElementsByTagName("c:legend")[0]);
      }
    };
    ModifyChartHelper.setLegendPosition = (legendArea) => (element, chart) => {
      const modifyXmlHelper = new modify_xml_helper_1.default(chart);
      modifyXmlHelper.modify({
        "c:legend": {
          children: {
            "c:manualLayout": {
              children: {
                "c:w": {
                  modify: [modify_xml_helper_1.default.attribute("val", legendArea.w)]
                },
                "c:h": {
                  modify: [modify_xml_helper_1.default.attribute("val", legendArea.h)]
                },
                "c:x": {
                  modify: [modify_xml_helper_1.default.attribute("val", legendArea.x)]
                },
                "c:y": {
                  modify: [modify_xml_helper_1.default.attribute("val", legendArea.y)]
                }
              }
            }
          }
        }
      });
    };
    ModifyChartHelper.setPlotArea = (plotArea) => (element, chart) => {
      const modifyXmlHelper = new modify_xml_helper_1.default(chart);
      if (!chart.getElementsByTagName("c:plotArea")[0].getElementsByTagName("c:manualLayout")[0]) {
        console.error("Can't update plot area. No c:manualLayout found.");
        return;
      }
      modifyXmlHelper.modify({
        "c:plotArea": {
          children: {
            "c:manualLayout": {
              children: {
                "c:w": {
                  // Finally, we attach ModifyCallbacks to all
                  // matching elements
                  modify: [
                    modify_xml_helper_1.default.attribute("val", plotArea.w)
                    // ...
                  ]
                },
                "c:h": {
                  modify: [modify_xml_helper_1.default.attribute("val", plotArea.h)]
                },
                "c:x": {
                  modify: [modify_xml_helper_1.default.attribute("val", plotArea.x)]
                },
                "c:y": {
                  modify: [modify_xml_helper_1.default.attribute("val", plotArea.y)]
                }
              }
            }
          }
        }
      });
    };
    ModifyChartHelper.setWaterFallColumnTotalToLast = (TotalColumnIDX) => (element, chart) => {
      var _b, _c, _d, _e, _f;
      const plotArea = chart.getElementsByTagName("cx:plotArea")[0];
      const subTotals = (_b = plotArea === null || plotArea === void 0 ? void 0 : plotArea.getElementsByTagName("cx:layoutPr")[0]) === null || _b === void 0 ? void 0 : _b.getElementsByTagName("cx:subtotals")[0];
      if (subTotals) {
        if (!TotalColumnIDX) {
          const GetTotalPoints = (_f = (_e = (_d = (_c = chart.getElementsByTagName("cx:chartData")[0]) === null || _c === void 0 ? void 0 : _c.getElementsByTagName("cx:data")[0]) === null || _d === void 0 ? void 0 : _d.getElementsByTagName("cx:strDim")[0]) === null || _e === void 0 ? void 0 : _e.getElementsByTagName("cx:lvl")[0]) === null || _f === void 0 ? void 0 : _f.getAttribute("ptCount");
          if (GetTotalPoints) {
            TotalColumnIDX = Number(GetTotalPoints) - 1;
          }
        }
        if (TotalColumnIDX !== void 0) {
          const stIndexes = Array.from(subTotals.getElementsByTagName("cx:idx"));
          stIndexes.forEach((sTValue, index) => {
            modify_xml_helper_1.default.attribute("val", TotalColumnIDX.toString())(sTValue);
            if (index > 0) {
              subTotals.removeChild(sTValue);
            }
          });
        }
      }
    };
    ModifyChartHelper.setChartTitle = (newTitle) => (element, chart) => {
      const chartTitle = chart.getElementsByTagName("c:title").item(0);
      const chartTitleText = chartTitle === null || chartTitle === void 0 ? void 0 : chartTitle.getElementsByTagName("a:t").item(0);
      if (chartTitleText) {
        chartTitleText.textContent = newTitle;
      }
    };
    ModifyChartHelper.setDataLabelAttributes = (dataLabel) => (element, chart) => {
      const modifyXmlHelper = new modify_xml_helper_1.default(chart);
      const applyToSeries = typeof dataLabel.applyToSeries === "number" ? {
        index: dataLabel.applyToSeries
      } : {
        all: true
      };
      modifyXmlHelper.modify({
        "c:ser": Object.assign(Object.assign({}, applyToSeries), { children: {
          "c:dLbls": {
            children: ModifyChartHelper.setDataPointLabelAttributes(dataLabel)
          }
        } })
      });
    };
    ModifyChartHelper.setDataPointLabelAttributes = (dataLabel) => {
      return {
        "c:spPr": {
          modify: [modify_color_helper_1.default.solidFill(dataLabel.solidFill)]
        },
        "c:dLblPos": {
          modify: [modify_xml_helper_1.default.attribute("val", dataLabel.dLblPos)]
        },
        "c:showLegendKey": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showLegendKey)
          ]
        },
        "c:showVal": {
          modify: [modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showVal)]
        },
        "c:showCatName": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showCatName)
          ]
        },
        "c:showSerName": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showSerName)
          ]
        },
        "c:showPercent": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showPercent)
          ]
        },
        "c:showBubbleSize": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showBubbleSize)
          ]
        },
        "c:showLeaderLines": {
          modify: [
            modify_xml_helper_1.default.booleanAttribute("val", dataLabel.showLeaderLines)
          ]
        }
      };
    };
  }
});

// node_modules/pptx-automizer/dist/helper/modify-image-helper.js
var require_modify_image_helper = __commonJS({
  "node_modules/pptx-automizer/dist/helper/modify-image-helper.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var slugify_1 = __importDefault(require_slugify());
    var ModifyImageHelper = class {
    };
    exports2.default = ModifyImageHelper;
    ModifyImageHelper.setRelationTarget = (filename) => {
      return (element, arg1) => {
        arg1.setAttribute("Target", "../media/" + (0, slugify_1.default)(filename));
      };
    };
    ModifyImageHelper.setDuotoneFill = (duotoneParams) => (element) => {
      const blipFill = element.getElementsByTagName("p:blipFill");
      if (!blipFill) {
        return;
      }
      const duotone = blipFill.item(0).getElementsByTagName("a:duotone")[0];
      if (duotone) {
        if (duotoneParams === null || duotoneParams === void 0 ? void 0 : duotoneParams.color) {
          const srgbClr = duotone.getElementsByTagName("a:srgbClr")[0];
          if (srgbClr) {
            srgbClr.setAttribute("val", String(duotoneParams.color.value));
            if ((duotoneParams === null || duotoneParams === void 0 ? void 0 : duotoneParams.tint) !== void 0) {
              const tint = srgbClr.getElementsByTagName("a:tint")[0];
              if (tint) {
                tint.setAttribute("val", String(duotoneParams.tint));
              }
            }
            if ((duotoneParams === null || duotoneParams === void 0 ? void 0 : duotoneParams.satMod) !== void 0) {
              const satMod = srgbClr.getElementsByTagName("a:satMod")[0];
              if (satMod) {
                satMod.setAttribute("val", String(duotoneParams.satMod));
              }
            }
          }
        }
        if (duotoneParams === null || duotoneParams === void 0 ? void 0 : duotoneParams.prstClr) {
          const prstClr = duotone.getElementsByTagName("a:prstClr")[0];
          if (prstClr) {
            prstClr.setAttribute("val", String(duotoneParams.prstClr));
          }
        }
      }
    };
  }
});

// node_modules/pptx-automizer/dist/enums/chart-type.js
var require_chart_type = __commonJS({
  "node_modules/pptx-automizer/dist/enums/chart-type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LabelPosition = void 0;
    var LabelPosition;
    (function(LabelPosition2) {
      LabelPosition2["BestFit"] = "bestFit";
      LabelPosition2["Bottom"] = "b";
      LabelPosition2["Center"] = "ctr";
      LabelPosition2["InsideEnd"] = "inEnd";
      LabelPosition2["InsideBase"] = "inBase";
      LabelPosition2["Left"] = "l";
      LabelPosition2["OutsideEnd"] = "outEnd";
      LabelPosition2["Right"] = "r";
      LabelPosition2["Top"] = "t";
    })(LabelPosition = exports2.LabelPosition || (exports2.LabelPosition = {}));
  }
});

// node_modules/pptx-automizer/dist/index.js
var require_dist = __commonJS({
  "node_modules/pptx-automizer/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DxaToCm = exports2.CmToDxa = exports2.read = exports2.modify = exports2.LabelPosition = exports2.ModifyImageHelper = exports2.ModifyColorHelper = exports2.ModifyTextHelper = exports2.ModifyChartHelper = exports2.ModifyTableHelper = exports2.ModifyShapeHelper = exports2.ModifyHelper = exports2.XmlHelper = exports2.Automizer = void 0;
    var automizer_1 = __importDefault(require_automizer());
    exports2.Automizer = automizer_1.default;
    var modify_helper_1 = __importStar(require_modify_helper());
    exports2.ModifyHelper = modify_helper_1.default;
    Object.defineProperty(exports2, "CmToDxa", { enumerable: true, get: function() {
      return modify_helper_1.CmToDxa;
    } });
    Object.defineProperty(exports2, "DxaToCm", { enumerable: true, get: function() {
      return modify_helper_1.DxaToCm;
    } });
    var modify_shape_helper_1 = __importDefault(require_modify_shape_helper());
    exports2.ModifyShapeHelper = modify_shape_helper_1.default;
    var modify_table_helper_1 = __importDefault(require_modify_table_helper());
    exports2.ModifyTableHelper = modify_table_helper_1.default;
    var modify_chart_helper_1 = __importDefault(require_modify_chart_helper());
    exports2.ModifyChartHelper = modify_chart_helper_1.default;
    var xml_helper_1 = require_xml_helper();
    Object.defineProperty(exports2, "XmlHelper", { enumerable: true, get: function() {
      return xml_helper_1.XmlHelper;
    } });
    var modify_text_helper_1 = __importDefault(require_modify_text_helper());
    exports2.ModifyTextHelper = modify_text_helper_1.default;
    var modify_color_helper_1 = __importDefault(require_modify_color_helper());
    exports2.ModifyColorHelper = modify_color_helper_1.default;
    var modify_image_helper_1 = __importDefault(require_modify_image_helper());
    exports2.ModifyImageHelper = modify_image_helper_1.default;
    var chart_type_1 = require_chart_type();
    Object.defineProperty(exports2, "LabelPosition", { enumerable: true, get: function() {
      return chart_type_1.LabelPosition;
    } });
    var dump = modify_helper_1.default.dump;
    var dumpChart = modify_helper_1.default.dumpChart;
    var setAttribute = modify_helper_1.default.setAttribute;
    var setSolidFill = modify_shape_helper_1.default.setSolidFill;
    var setText = modify_shape_helper_1.default.setText;
    var setBulletList = modify_shape_helper_1.default.setBulletList;
    var replaceText = modify_shape_helper_1.default.replaceText;
    var setPosition = modify_shape_helper_1.default.setPosition;
    var updatePosition = modify_shape_helper_1.default.updatePosition;
    var rotateShape = modify_shape_helper_1.default.rotate;
    var setTableData = modify_table_helper_1.default.setTableData;
    var adjustHeight = modify_table_helper_1.default.adjustHeight;
    var adjustWidth = modify_table_helper_1.default.adjustWidth;
    var setTable = modify_table_helper_1.default.setTable;
    var updateColumnWidth = modify_table_helper_1.default.updateColumnWidth;
    var updateRowHeight = modify_table_helper_1.default.updateRowHeight;
    var setRelationTarget = modify_image_helper_1.default.setRelationTarget;
    var setDuotoneFill = modify_image_helper_1.default.setDuotoneFill;
    var setChartData = modify_chart_helper_1.default.setChartData;
    var setExtendedChartData = modify_chart_helper_1.default.setExtendedChartData;
    var setChartVerticalLines = modify_chart_helper_1.default.setChartVerticalLines;
    var setChartScatter = modify_chart_helper_1.default.setChartScatter;
    var setChartBubbles = modify_chart_helper_1.default.setChartBubbles;
    var setChartCombo = modify_chart_helper_1.default.setChartCombo;
    var setAxisRange = modify_chart_helper_1.default.setAxisRange;
    var setPlotArea = modify_chart_helper_1.default.setPlotArea;
    var setLegendPosition = modify_chart_helper_1.default.setLegendPosition;
    var removeChartLegend = modify_chart_helper_1.default.removeChartLegend;
    var minimizeChartLegend = modify_chart_helper_1.default.minimizeChartLegend;
    var setWaterFallColumnTotalToLast = modify_chart_helper_1.default.setWaterFallColumnTotalToLast;
    var setChartTitle = modify_chart_helper_1.default.setChartTitle;
    var setDataLabelAttributes = modify_chart_helper_1.default.setDataLabelAttributes;
    var readWorkbookData = modify_chart_helper_1.default.readWorkbookData;
    var readChartInfo = modify_chart_helper_1.default.readChartInfo;
    exports2.modify = {
      dump,
      dumpChart,
      setAttribute,
      setSolidFill,
      setText,
      setBulletList,
      replaceText,
      setPosition,
      updatePosition,
      rotateShape,
      setTableData,
      adjustHeight,
      adjustWidth,
      updateColumnWidth,
      updateRowHeight,
      setTable,
      setRelationTarget,
      setDuotoneFill,
      setChartData,
      setAxisRange,
      setExtendedChartData,
      setChartVerticalLines,
      setChartScatter,
      setChartCombo,
      setChartBubbles,
      setPlotArea,
      setLegendPosition,
      removeChartLegend,
      minimizeChartLegend,
      setWaterFallColumnTotalToLast,
      setChartTitle,
      setDataLabelAttributes
    };
    exports2.read = {
      readWorkbookData,
      readChartInfo
    };
    exports2.default = automizer_1.default;
  }
});

// src/services/merge_pptx.js
var Automizer = require_dist().default;
var fs = require("fs");
var path = require("path");
async function MergePptx(folderPath2, outputPath2) {
  if (!fs.existsSync(outputPath2)) {
    fs.mkdirSync(outputPath2, { recursive: true });
  }
  const files = fs.readdirSync(folderPath2).filter((f) => f.toLowerCase().endsWith(".pptx")).sort();
  if (files.length === 0) {
    throw new Error(`No .pptx files found in ${folderPath2}`);
  }
  const rootFile = files.shift();
  const pres = new Automizer({
    templateDir: folderPath2,
    outputDir: outputPath2
  }).loadRoot(path.join(folderPath2, rootFile));
  for (const file of files) {
    const key = path.basename(file, ".pptx");
    pres.load(path.join(folderPath2, file), key);
    const slideNumbers = await pres.getTemplate(key).getAllSlideNumbers();
    for (const num of slideNumbers) {
      pres.addSlide(key, num);
    }
  }
  await pres.write(path.join("fusion.pptx"));
  console.log("Merge completed in", path.join("fusion.pptx"));
}
function printUsage() {
  console.log(`
Usage:
  node merge_pptx.js <dossier_source> <dossier_sortie>

Exemple:
  node merge_pptx.js ./pptx_folder ./test
`);
}
var [, , folderPath, outputPath] = process.argv;
if (!folderPath || !outputPath) {
  printUsage();
  process.exit(1);
}
MergePptx(folderPath, outputPath).catch((err) => {
  console.error("Error during fusion :", err.message);
  process.exit(1);
});
